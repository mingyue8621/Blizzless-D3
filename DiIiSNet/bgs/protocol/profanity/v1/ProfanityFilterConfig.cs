// Generated by ProtoGen, Version=2.4.1.473, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace bgs.protocol.profanity.v1 {
  
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public static partial class ProfanityFilterConfig {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_bgs_protocol_profanity_v1_WordFilter__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::bgs.protocol.profanity.v1.WordFilter, global::bgs.protocol.profanity.v1.WordFilter.Builder> internal__static_bgs_protocol_profanity_v1_WordFilter__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_bgs_protocol_profanity_v1_WordFilters__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::bgs.protocol.profanity.v1.WordFilters, global::bgs.protocol.profanity.v1.WordFilters.Builder> internal__static_bgs_protocol_profanity_v1_WordFilters__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static ProfanityFilterConfig() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          "Ci9iZ3MvbG93L3BiL2NsaWVudC9wcm9mYW5pdHlfZmlsdGVyX2NvbmZpZy5w" + 
          "cm90bxIZYmdzLnByb3RvY29sLnByb2Zhbml0eS52MSI2CgpXb3JkRmlsdGVy" + 
          "EhIKBHR5cGUYASACKAlSBHR5cGUSFAoFcmVnZXgYAiACKAlSBXJlZ2V4Ik4K" + 
          "C1dvcmRGaWx0ZXJzEj8KB2ZpbHRlcnMYASADKAsyJS5iZ3MucHJvdG9jb2wu" + 
          "cHJvZmFuaXR5LnYxLldvcmRGaWx0ZXJSB2ZpbHRlcnNCOgoaYm5ldC5wcm90" + 
          "b2NvbC5wcm9mYW5pdHkudjFCGlByb2Zhbml0eUZpbHRlckNvbmZpZ1Byb3Rv" + 
          "SAI=");
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_bgs_protocol_profanity_v1_WordFilter__Descriptor = Descriptor.MessageTypes[0];
        internal__static_bgs_protocol_profanity_v1_WordFilter__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::bgs.protocol.profanity.v1.WordFilter, global::bgs.protocol.profanity.v1.WordFilter.Builder>(internal__static_bgs_protocol_profanity_v1_WordFilter__Descriptor,
                new string[] { "Type", "Regex", });
        internal__static_bgs_protocol_profanity_v1_WordFilters__Descriptor = Descriptor.MessageTypes[1];
        internal__static_bgs_protocol_profanity_v1_WordFilters__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::bgs.protocol.profanity.v1.WordFilters, global::bgs.protocol.profanity.v1.WordFilters.Builder>(internal__static_bgs_protocol_profanity_v1_WordFilters__Descriptor,
                new string[] { "Filters", });
        pb::ExtensionRegistry registry = pb::ExtensionRegistry.CreateInstance();
        RegisterAllExtensions(registry);
        return registry;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class WordFilter : pb::GeneratedMessage<WordFilter, WordFilter.Builder> {
    private WordFilter() { }
    private static readonly WordFilter defaultInstance = new WordFilter().MakeReadOnly();
    public static WordFilter DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override WordFilter DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override WordFilter ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::bgs.protocol.profanity.v1.ProfanityFilterConfig.internal__static_bgs_protocol_profanity_v1_WordFilter__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<WordFilter, WordFilter.Builder> InternalFieldAccessors {
      get { return global::bgs.protocol.profanity.v1.ProfanityFilterConfig.internal__static_bgs_protocol_profanity_v1_WordFilter__FieldAccessorTable; }
    }
    
    public const int TypeFieldNumber = 1;
    private bool hasType;
    private string type_ = "";
    public bool HasType {
      get { return hasType; }
    }
    public string Type {
      get { return type_; }
    }
    
    public const int RegexFieldNumber = 2;
    private bool hasRegex;
    private string regex_ = "";
    public bool HasRegex {
      get { return hasRegex; }
    }
    public string Regex {
      get { return regex_; }
    }
    
    public static WordFilter ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WordFilter ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WordFilter ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WordFilter ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WordFilter ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WordFilter ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static WordFilter ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static WordFilter ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static WordFilter ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WordFilter ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private WordFilter MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(WordFilter prototype) {
      return new Builder(prototype);
    }
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<WordFilter, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(WordFilter cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private WordFilter result;
      
      private WordFilter PrepareBuilder() {
        if (resultIsReadOnly) {
          WordFilter original = result;
          result = new WordFilter();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override WordFilter MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::bgs.protocol.profanity.v1.WordFilter.Descriptor; }
      }
      
      public override WordFilter DefaultInstanceForType {
        get { return global::bgs.protocol.profanity.v1.WordFilter.DefaultInstance; }
      }
      
      public override WordFilter BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      
      public bool HasType {
        get { return result.hasType; }
      }
      public string Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = "";
        return this;
      }
      
      public bool HasRegex {
        get { return result.hasRegex; }
      }
      public string Regex {
        get { return result.Regex; }
        set { SetRegex(value); }
      }
      public Builder SetRegex(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRegex = true;
        result.regex_ = value;
        return this;
      }
      public Builder ClearRegex() {
        PrepareBuilder();
        result.hasRegex = false;
        result.regex_ = "";
        return this;
      }
    }
    static WordFilter() {
      object.ReferenceEquals(global::bgs.protocol.profanity.v1.ProfanityFilterConfig.Descriptor, null);
    }
  }
  
  
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class WordFilters : pb::GeneratedMessage<WordFilters, WordFilters.Builder> {
    private WordFilters() { }
    private static readonly WordFilters defaultInstance = new WordFilters().MakeReadOnly();
    public static WordFilters DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override WordFilters DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override WordFilters ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::bgs.protocol.profanity.v1.ProfanityFilterConfig.internal__static_bgs_protocol_profanity_v1_WordFilters__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<WordFilters, WordFilters.Builder> InternalFieldAccessors {
      get { return global::bgs.protocol.profanity.v1.ProfanityFilterConfig.internal__static_bgs_protocol_profanity_v1_WordFilters__FieldAccessorTable; }
    }
    
    public const int FiltersFieldNumber = 1;
    private pbc::PopsicleList<global::bgs.protocol.profanity.v1.WordFilter> filters_ = new pbc::PopsicleList<global::bgs.protocol.profanity.v1.WordFilter>();
    public scg::IList<global::bgs.protocol.profanity.v1.WordFilter> FiltersList {
      get { return filters_; }
    }
    public int FiltersCount {
      get { return filters_.Count; }
    }
    public global::bgs.protocol.profanity.v1.WordFilter GetFilters(int index) {
      return filters_[index];
    }
    
    public static WordFilters ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WordFilters ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WordFilters ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WordFilters ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WordFilters ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WordFilters ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static WordFilters ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static WordFilters ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static WordFilters ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WordFilters ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private WordFilters MakeReadOnly() {
      filters_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(WordFilters prototype) {
      return new Builder(prototype);
    }
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<WordFilters, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(WordFilters cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private WordFilters result;
      
      private WordFilters PrepareBuilder() {
        if (resultIsReadOnly) {
          WordFilters original = result;
          result = new WordFilters();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override WordFilters MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::bgs.protocol.profanity.v1.WordFilters.Descriptor; }
      }
      
      public override WordFilters DefaultInstanceForType {
        get { return global::bgs.protocol.profanity.v1.WordFilters.DefaultInstance; }
      }
      
      public override WordFilters BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      
      public pbc::IPopsicleList<global::bgs.protocol.profanity.v1.WordFilter> FiltersList {
        get { return PrepareBuilder().filters_; }
      }
      public int FiltersCount {
        get { return result.FiltersCount; }
      }
      public global::bgs.protocol.profanity.v1.WordFilter GetFilters(int index) {
        return result.GetFilters(index);
      }
      public Builder SetFilters(int index, global::bgs.protocol.profanity.v1.WordFilter value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.filters_[index] = value;
        return this;
      }
      public Builder SetFilters(int index, global::bgs.protocol.profanity.v1.WordFilter.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.filters_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddFilters(global::bgs.protocol.profanity.v1.WordFilter value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.filters_.Add(value);
        return this;
      }
      public Builder AddFilters(global::bgs.protocol.profanity.v1.WordFilter.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.filters_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeFilters(scg::IEnumerable<global::bgs.protocol.profanity.v1.WordFilter> values) {
        PrepareBuilder();
        result.filters_.Add(values);
        return this;
      }
      public Builder ClearFilters() {
        PrepareBuilder();
        result.filters_.Clear();
        return this;
      }
    }
    static WordFilters() {
      object.ReferenceEquals(global::bgs.protocol.profanity.v1.ProfanityFilterConfig.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
