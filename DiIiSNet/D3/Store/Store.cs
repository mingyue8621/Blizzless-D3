// Generated by ProtoGen, Version=2.4.1.473, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace D3.Store {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public static partial class Store {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_D3_Store_ProductPrice__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.ProductPrice, global::D3.Store.ProductPrice.Builder> internal__static_D3_Store_ProductPrice__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_ProductEntitlement__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.ProductEntitlement, global::D3.Store.ProductEntitlement.Builder> internal__static_D3_Store_ProductEntitlement__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_ContentLicenseRestriction__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.ContentLicenseRestriction, global::D3.Store.ContentLicenseRestriction.Builder> internal__static_D3_Store_ContentLicenseRestriction__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_Currency__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.Currency, global::D3.Store.Currency.Builder> internal__static_D3_Store_Currency__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_Product__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.Product, global::D3.Store.Product.Builder> internal__static_D3_Store_Product__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_ProductCategory__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.ProductCategory, global::D3.Store.ProductCategory.Builder> internal__static_D3_Store_ProductCategory__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_Risk__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.Risk, global::D3.Store.Risk.Builder> internal__static_D3_Store_Risk__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_Wallet__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.Wallet, global::D3.Store.Wallet.Builder> internal__static_D3_Store_Wallet__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_Order__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.Order, global::D3.Store.Order.Builder> internal__static_D3_Store_Order__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetProductList__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetProductList, global::D3.Store.GetProductList.Builder> internal__static_D3_Store_GetProductList__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetProductListResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetProductListResponse, global::D3.Store.GetProductListResponse.Builder> internal__static_D3_Store_GetProductListResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetProduct__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetProduct, global::D3.Store.GetProduct.Builder> internal__static_D3_Store_GetProduct__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetProductResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetProductResponse, global::D3.Store.GetProductResponse.Builder> internal__static_D3_Store_GetProductResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetProductCategories__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetProductCategories, global::D3.Store.GetProductCategories.Builder> internal__static_D3_Store_GetProductCategories__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetProductCategoriesResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetProductCategoriesResponse, global::D3.Store.GetProductCategoriesResponse.Builder> internal__static_D3_Store_GetProductCategoriesResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetPrimaryCurrency__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetPrimaryCurrency, global::D3.Store.GetPrimaryCurrency.Builder> internal__static_D3_Store_GetPrimaryCurrency__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetPrimaryCurrencyResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetPrimaryCurrencyResponse, global::D3.Store.GetPrimaryCurrencyResponse.Builder> internal__static_D3_Store_GetPrimaryCurrencyResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetPaymentMethods__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetPaymentMethods, global::D3.Store.GetPaymentMethods.Builder> internal__static_D3_Store_GetPaymentMethods__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetPaymentMethodsResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetPaymentMethodsResponse, global::D3.Store.GetPaymentMethodsResponse.Builder> internal__static_D3_Store_GetPaymentMethodsResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_DetermineRisk__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.DetermineRisk, global::D3.Store.DetermineRisk.Builder> internal__static_D3_Store_DetermineRisk__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_DetermineRiskResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.DetermineRiskResponse, global::D3.Store.DetermineRiskResponse.Builder> internal__static_D3_Store_DetermineRiskResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_PlaceOrder__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.PlaceOrder, global::D3.Store.PlaceOrder.Builder> internal__static_D3_Store_PlaceOrder__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_PlaceOrderResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.PlaceOrderResponse, global::D3.Store.PlaceOrderResponse.Builder> internal__static_D3_Store_PlaceOrderResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_EntitlementUpdate__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.EntitlementUpdate, global::D3.Store.EntitlementUpdate.Builder> internal__static_D3_Store_EntitlementUpdate__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_OrderStatus__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.OrderStatus, global::D3.Store.OrderStatus.Builder> internal__static_D3_Store_OrderStatus__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_MissingEntitlement__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.MissingEntitlement, global::D3.Store.MissingEntitlement.Builder> internal__static_D3_Store_MissingEntitlement__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_MissingEntitlements__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.MissingEntitlements, global::D3.Store.MissingEntitlements.Builder> internal__static_D3_Store_MissingEntitlements__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_AcknowledgeOrder__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.AcknowledgeOrder, global::D3.Store.AcknowledgeOrder.Builder> internal__static_D3_Store_AcknowledgeOrder__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_AcknowledgeMissingLicenses__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.AcknowledgeMissingLicenses, global::D3.Store.AcknowledgeMissingLicenses.Builder> internal__static_D3_Store_AcknowledgeMissingLicenses__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_AcknowledgeOrderResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.AcknowledgeOrderResponse, global::D3.Store.AcknowledgeOrderResponse.Builder> internal__static_D3_Store_AcknowledgeOrderResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_CheckOrderStatus__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.CheckOrderStatus, global::D3.Store.CheckOrderStatus.Builder> internal__static_D3_Store_CheckOrderStatus__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_CheckOrderStatusResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.CheckOrderStatusResponse, global::D3.Store.CheckOrderStatusResponse.Builder> internal__static_D3_Store_CheckOrderStatusResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_StoreStatus__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.StoreStatus, global::D3.Store.StoreStatus.Builder> internal__static_D3_Store_StoreStatus__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetBalance__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetBalance, global::D3.Store.GetBalance.Builder> internal__static_D3_Store_GetBalance__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetBalanceResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetBalanceResponse, global::D3.Store.GetBalanceResponse.Builder> internal__static_D3_Store_GetBalanceResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_InternalOrder__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.InternalOrder, global::D3.Store.InternalOrder.Builder> internal__static_D3_Store_InternalOrder__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_InternalProduct__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.InternalProduct, global::D3.Store.InternalProduct.Builder> internal__static_D3_Store_InternalProduct__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_InternalPlaceOrderResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.InternalPlaceOrderResponse, global::D3.Store.InternalPlaceOrderResponse.Builder> internal__static_D3_Store_InternalPlaceOrderResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_ModifyLicense__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.ModifyLicense, global::D3.Store.ModifyLicense.Builder> internal__static_D3_Store_ModifyLicense__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_ModifyLicenseResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.ModifyLicenseResponse, global::D3.Store.ModifyLicenseResponse.Builder> internal__static_D3_Store_ModifyLicenseResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_BPayOrderStatus__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.BPayOrderStatus, global::D3.Store.BPayOrderStatus.Builder> internal__static_D3_Store_BPayOrderStatus__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetCurrency__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetCurrency, global::D3.Store.GetCurrency.Builder> internal__static_D3_Store_GetCurrency__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetCurrencyResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetCurrencyResponse, global::D3.Store.GetCurrencyResponse.Builder> internal__static_D3_Store_GetCurrencyResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_ConsumableLicense__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.ConsumableLicense, global::D3.Store.ConsumableLicense.Builder> internal__static_D3_Store_ConsumableLicense__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_LicenseInstance__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.LicenseInstance, global::D3.Store.LicenseInstance.Builder> internal__static_D3_Store_LicenseInstance__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_LicenseAttributes__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.LicenseAttributes, global::D3.Store.LicenseAttributes.Builder> internal__static_D3_Store_LicenseAttributes__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_ProductCatalog__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.ProductCatalog, global::D3.Store.ProductCatalog.Builder> internal__static_D3_Store_ProductCatalog__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_CountryInformation__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.CountryInformation, global::D3.Store.CountryInformation.Builder> internal__static_D3_Store_CountryInformation__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_CountryConfig__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.CountryConfig, global::D3.Store.CountryConfig.Builder> internal__static_D3_Store_CountryConfig__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_CheckGTAPPStatusResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.CheckGTAPPStatusResponse, global::D3.Store.CheckGTAPPStatusResponse.Builder> internal__static_D3_Store_CheckGTAPPStatusResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_Store_GetGTAPPBalance__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetGTAPPBalance, global::D3.Store.GetGTAPPBalance.Builder> internal__static_D3_Store_GetGTAPPBalance__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static Store() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          "CgtTdG9yZS5wcm90bxIIRDMuU3RvcmUaGU9ubGluZVNlcnZpY2VTZXJ2ZXIu" + 
          "cHJvdG8ijQEKDFByb2R1Y3RQcmljZRIaCghjdXJyZW5jeRgBIAEoBVIIY3Vy" + 
          "cmVuY3kSKAoQZml4ZWRfcG9pbnRfY29zdBgEIAEoElIOZml4ZWRQb2ludENv" + 
          "c3QSNwoYZml4ZWRfcG9pbnRfcmV0YWlsX3ByaWNlGAUgASgSUhVmaXhlZFBv" + 
          "aW50UmV0YWlsUHJpY2UipwEKElByb2R1Y3RFbnRpdGxlbWVudBISCgRnYmlk" + 
          "GAEgASgFUgRnYmlkEiwKEmNvbnRlbnRfbGljZW5zZV9pZBgCIAEoDVIQY29u" + 
          "dGVudExpY2Vuc2VJZBInCg9wbGF0aW51bV9hbW91bnQYAyABKARSDnBsYXRp" + 
          "bnVtQW1vdW50EiYKD21heF9zdGFja19jb3VudBgFIAEoDVINbWF4U3RhY2tD" + 
          "b3VudCJfChlDb250ZW50TGljZW5zZVJlc3RyaWN0aW9uEiwKEmNvbnRlbnRf" + 
          "bGljZW5zZV9pZBgBIAEoDVIQY29udGVudExpY2Vuc2VJZBIUCgVjb3VudBgC" + 
          "IAEoDVIFY291bnQiWgoIQ3VycmVuY3kSDgoCaWQYASABKAVSAmlkEhIKBGNv" + 
          "ZGUYAiABKAlSBGNvZGUSFgoGc3ltYm9sGAMgASgJUgZzeW1ib2wSEgoEbmFt" + 
          "ZRgEIAEoCVIEbmFtZSKvBAoHUHJvZHVjdBJACgxlbnRpdGxlbWVudHMYAiAD" + 
          "KAsyHC5EMy5TdG9yZS5Qcm9kdWN0RW50aXRsZW1lbnRSDGVudGl0bGVtZW50" + 
          "cxIuCgZwcmljZXMYAyADKAsyFi5EMy5TdG9yZS5Qcm9kdWN0UHJpY2VSBnBy" + 
          "aWNlcxIaCghjYXRlZ29yeRgEIAEoBVIIY2F0ZWdvcnkSJQoOYXZhaWxhYmxl" + 
          "X2Zyb20YBSABKANSDWF2YWlsYWJsZUZyb20SGgoIZmVhdHVyZWQYBiABKA1S" + 
          "CGZlYXR1cmVkEiMKDWR1cmF0aW9uX3NlY3MYByABKARSDGR1cmF0aW9uU2Vj" + 
          "cxJlChxtaW5fY29udGVudGxpY2Vuc2VzX3JlcXVpcmVkGAggAygLMiMuRDMu" + 
          "U3RvcmUuQ29udGVudExpY2Vuc2VSZXN0cmljdGlvblIabWluQ29udGVudGxp" + 
          "Y2Vuc2VzUmVxdWlyZWQSYwobbWF4X2NvbnRlbnRsaWNlbnNlc19hbGxvd2Vk" + 
          "GAkgAygLMiMuRDMuU3RvcmUuQ29udGVudExpY2Vuc2VSZXN0cmljdGlvblIZ" + 
          "bWF4Q29udGVudGxpY2Vuc2VzQWxsb3dlZBIhCgxidW5kbGVfbGFiZWwYCiAB" + 
          "KAlSC2J1bmRsZUxhYmVsEiAKDG5vdF9mb3Jfc2FsZRgLIAEoCFIKbm90Rm9y" + 
          "U2FsZRIdCgpwcm9kdWN0X2lkGAwgASgNUglwcm9kdWN0SWQiXQoPUHJvZHVj" + 
          "dENhdGVnb3J5EhoKCGNhdGVnb3J5GAEgASgFUghjYXRlZ29yeRIuChNuZXdl" + 
          "c3RfcHJvZHVjdF90aW1lGAIgASgDUhFuZXdlc3RQcm9kdWN0VGltZSKSAQoE" + 
          "UmlzaxIbCglyaXNrX3R5cGUYASABKAVSCHJpc2tUeXBlEiUKDnRyYW5zYWN0" + 
          "aW9uX2lkGAIgASgJUg10cmFuc2FjdGlvbklkEiEKDGNoYWxsZW5nZV9pZBgD" + 
          "IAEoCVILY2hhbGxlbmdlSWQSIwoNY2hhbGxlbmdlX3VybBgEIAEoCVIMY2hh" + 
          "bGxlbmdlVXJsIosCCgZXYWxsZXQSGwoJd2FsbGV0X2lkGAEgASgSUgh3YWxs" + 
          "ZXRJZBIfCgt3YWxsZXRfbmFtZRgCIAEoCVIKd2FsbGV0TmFtZRIYCgdwcmlt" + 
          "YXJ5GAQgASgIUgdwcmltYXJ5Eh8KC3dhbGxldF90eXBlGAUgASgFUgp3YWxs" + 
          "ZXRUeXBlEjQKFndhbGxldF9leHBpcmF0aW9uX2RhdGUYBiABKAlSFHdhbGxl" + 
          "dEV4cGlyYXRpb25EYXRlEiIKBHJpc2sYByABKAsyDi5EMy5TdG9yZS5SaXNr" + 
          "UgRyaXNrEi4KE2ZpeGVkX3BvaW50X2JhbGFuY2UYCSABKANSEWZpeGVkUG9p" + 
          "bnRCYWxhbmNlIokBCgVPcmRlchIWCgZzdGF0dXMYASABKA1SBnN0YXR1cxIl" + 
          "Cg50cmFuc2FjdGlvbl9pZBgCIAEoBFINdHJhbnNhY3Rpb25JZBIdCgplcnJv" + 
          "cl9jb2RlGAMgASgNUgllcnJvckNvZGUSIgoMYWNrbm93bGVkZ2VkGAQgASgI" + 
          "UgxhY2tub3dsZWRnZWQiVQoOR2V0UHJvZHVjdExpc3QSGgoIY2F0ZWdvcnkY" + 
          "ASABKAVSCGNhdGVnb3J5EicKD2NhdGFsb2dfdmVyc2lvbhgCIAEoBFIOY2F0" + 
          "YWxvZ1ZlcnNpb24ioQEKFkdldFByb2R1Y3RMaXN0UmVzcG9uc2USLQoIcHJv" + 
          "ZHVjdHMYASADKAsyES5EMy5TdG9yZS5Qcm9kdWN0Ughwcm9kdWN0cxIkCg52" + 
          "YWxpZF9mb3Jfc2VjcxgCIAEoDVIMdmFsaWRGb3JTZWNzEjIKCmN1cnJlbmNp" + 
          "ZXMYAyADKAsyEi5EMy5TdG9yZS5DdXJyZW5jeVIKY3VycmVuY2llcyIrCgpH" + 
          "ZXRQcm9kdWN0Eh0KCnByb2R1Y3RfaWQYAiABKA1SCXByb2R1Y3RJZCJ1ChJH" + 
          "ZXRQcm9kdWN0UmVzcG9uc2USKwoHcHJvZHVjdBgBIAEoCzIRLkQzLlN0b3Jl" + 
          "LlByb2R1Y3RSB3Byb2R1Y3QSMgoKY3VycmVuY2llcxgCIAMoCzISLkQzLlN0" + 
          "b3JlLkN1cnJlbmN5UgpjdXJyZW5jaWVzIj8KFEdldFByb2R1Y3RDYXRlZ29y" + 
          "aWVzEicKD2NhdGFsb2dfdmVyc2lvbhgBIAEoBFIOY2F0YWxvZ1ZlcnNpb24i" + 
          "WQocR2V0UHJvZHVjdENhdGVnb3JpZXNSZXNwb25zZRI5CgpjYXRlZ29yaWVz" + 
          "GAEgAygLMhkuRDMuU3RvcmUuUHJvZHVjdENhdGVnb3J5UgpjYXRlZ29yaWVz" + 
          "IhQKEkdldFByaW1hcnlDdXJyZW5jeSI4ChpHZXRQcmltYXJ5Q3VycmVuY3lS" + 
          "ZXNwb25zZRIaCghjdXJyZW5jeRgBIAEoBVIIY3VycmVuY3kiLwoRR2V0UGF5" + 
          "bWVudE1ldGhvZHMSGgoIY3VycmVuY3kYASABKAVSCGN1cnJlbmN5IkcKGUdl" + 
          "dFBheW1lbnRNZXRob2RzUmVzcG9uc2USKgoHd2FsbGV0cxgBIAMoCzIQLkQz" + 
          "LlN0b3JlLldhbGxldFIHd2FsbGV0cyKEAQoNRGV0ZXJtaW5lUmlzaxIbCgl3" + 
          "YWxsZXRfaWQYAiABKBJSCHdhbGxldElkEhoKCGN1cnJlbmN5GAMgASgFUghj" + 
          "dXJyZW5jeRIbCglkZXZpY2VfaWQYBCABKAlSCGRldmljZUlkEh0KCnByb2R1" + 
          "Y3RfaWQYBSABKA1SCXByb2R1Y3RJZCJYChVEZXRlcm1pbmVSaXNrUmVzcG9u" + 
          "c2USIgoEcmlzaxgBIAEoCzIOLkQzLlN0b3JlLlJpc2tSBHJpc2sSGwoJd2Fs" + 
          "bGV0X2lkGAIgASgSUgh3YWxsZXRJZCKRAgoKUGxhY2VPcmRlchIbCgl3YWxs" + 
          "ZXRfaWQYAiABKBJSCHdhbGxldElkEhoKCGN1cnJlbmN5GAMgASgFUghjdXJy" + 
          "ZW5jeRIuChNyaXNrX3RyYW5zYWN0aW9uX2lkGAUgASgJUhFyaXNrVHJhbnNh" + 
          "Y3Rpb25JZBIhCgxjaGFsbGVuZ2VfaWQYBiABKAlSC2NoYWxsZW5nZUlkEhsK" + 
          "CWRldmljZV9pZBgHIAEoCVIIZGV2aWNlSWQSHQoKcHJvZHVjdF9pZBgIIAEo" + 
          "DVIJcHJvZHVjdElkEjsKGmZpeGVkX3BvaW50X2V4cGVjdGVkX3ByaWNlGAkg" + 
          "ASgDUhdmaXhlZFBvaW50RXhwZWN0ZWRQcmljZSI7ChJQbGFjZU9yZGVyUmVz" + 
          "cG9uc2USJQoOdHJhbnNhY3Rpb25faWQYASABKARSDXRyYW5zYWN0aW9uSWQi" + 
          "dAoRRW50aXRsZW1lbnRVcGRhdGUSPgoLZW50aXRsZW1lbnQYASABKAsyHC5E" + 
          "My5TdG9yZS5Qcm9kdWN0RW50aXRsZW1lbnRSC2VudGl0bGVtZW50Eh8KC2V4" + 
          "cGlyZV90aW1lGAIgASgDUgpleHBpcmVUaW1lIsgBCgtPcmRlclN0YXR1cxIl" + 
          "CgVvcmRlchgBIAEoCzIPLkQzLlN0b3JlLk9yZGVyUgVvcmRlchJOChRsaW1p" + 
          "dGVkX2VudGl0bGVtZW50cxgDIAMoCzIbLkQzLlN0b3JlLkVudGl0bGVtZW50" + 
          "VXBkYXRlUhNsaW1pdGVkRW50aXRsZW1lbnRzEiMKDWNyZWF0aW9uX3RpbWUY" + 
          "BCABKBJSDGNyZWF0aW9uVGltZRIdCgpwcm9kdWN0X2lkGAUgASgNUglwcm9k" + 
          "dWN0SWQikwEKEk1pc3NpbmdFbnRpdGxlbWVudBI8CgpkZWZpbml0aW9uGAEg" + 
          "ASgLMhwuRDMuU3RvcmUuUHJvZHVjdEVudGl0bGVtZW50UgpkZWZpbml0aW9u" + 
          "EiUKDmFja25vd2xlZGdlX2lkGAIgASgEUg1hY2tub3dsZWRnZUlkEhgKB2V4" + 
          "cGlyZWQYAyABKAhSB2V4cGlyZWQiVQoTTWlzc2luZ0VudGl0bGVtZW50cxI+" + 
          "CgtlbnRpdGxlbWVudBgBIAMoCzIcLkQzLlN0b3JlLk1pc3NpbmdFbnRpdGxl" + 
          "bWVudFILZW50aXRsZW1lbnQiWAoQQWNrbm93bGVkZ2VPcmRlchIlCg50cmFu" + 
          "c2FjdGlvbl9pZBgBIAEoBFINdHJhbnNhY3Rpb25JZBIdCgplcnJvcl9jb2Rl" + 
          "GAIgASgNUgllcnJvckNvZGUiQwoaQWNrbm93bGVkZ2VNaXNzaW5nTGljZW5z" + 
          "ZXMSJQoOYWNrbm93bGVkZ2VfaWQYASADKARSDWFja25vd2xlZGdlSWQiGgoY" + 
          "QWNrbm93bGVkZ2VPcmRlclJlc3BvbnNlIjkKEENoZWNrT3JkZXJTdGF0dXMS" + 
          "JQoOdHJhbnNhY3Rpb25faWQYASABKARSDXRyYW5zYWN0aW9uSWQiQQoYQ2hl" + 
          "Y2tPcmRlclN0YXR1c1Jlc3BvbnNlEiUKDnRyYW5zYWN0aW9uX2lkGAEgASgE" + 
          "Ug10cmFuc2FjdGlvbklkImsKC1N0b3JlU3RhdHVzEiEKDHN0b3JlX3N0YXR1" + 
          "cxgBIAEoBVILc3RvcmVTdGF0dXMSOQoZc3RvcmVfc3RhdHVzX2NoYW5nZWRf" + 
          "dGltZRgCIAEoBFIWc3RvcmVTdGF0dXNDaGFuZ2VkVGltZSIoCgpHZXRCYWxh" + 
          "bmNlEhoKCGN1cnJlbmN5GAEgASgFUghjdXJyZW5jeSJEChJHZXRCYWxhbmNl" + 
          "UmVzcG9uc2USLgoTZml4ZWRfcG9pbnRfYmFsYW5jZRgCIAEoA1IRZml4ZWRQ" + 
          "b2ludEJhbGFuY2UiswIKDUludGVybmFsT3JkZXISJQoFb3JkZXIYASABKAsy" + 
          "Dy5EMy5TdG9yZS5PcmRlclIFb3JkZXISGQoIb3JkZXJfaWQYAiABKAlSB29y" + 
          "ZGVySWQSHQoKYWNjb3VudF9pZBgDIAEoBFIJYWNjb3VudElkEiYKD2dhbWVf" + 
          "YWNjb3VudF9pZBgEIAEoBFINZ2FtZUFjY291bnRJZBIjCg1jcmVhdGlvbl90" + 
          "aW1lGAYgASgSUgxjcmVhdGlvblRpbWUSLgoTdW5kZXJfbWFudWFsX3Jldmll" + 
          "dxgIIAEoCFIRdW5kZXJNYW51YWxSZXZpZXcSJQoOYm9vdHN0cmFwX3RpbWUY" + 
          "CSABKBJSDWJvb3RzdHJhcFRpbWUSHQoKcHJvZHVjdF9pZBgKIAEoDVIJcHJv" + 
          "ZHVjdElkIrUBCg9JbnRlcm5hbFByb2R1Y3QSKwoHcHJvZHVjdBgBIAEoCzIR" + 
          "LkQzLlN0b3JlLlByb2R1Y3RSB3Byb2R1Y3QSHwoLbGljZW5zZV9pZHMYAiAD" + 
          "KARSCmxpY2Vuc2VJZHMSHgoLZnJlZV9pbl9pZ3IYAyABKAhSCWZyZWVJbkln" + 
          "chI0ChZlYXJsaWVzdF92YWxpZF92ZXJzaW9uGAQgASgJUhRlYXJsaWVzdFZh" + 
          "bGlkVmVyc2lvbiI3ChpJbnRlcm5hbFBsYWNlT3JkZXJSZXNwb25zZRIZCghv" + 
          "cmRlcl9pZBgBIAEoCVIHb3JkZXJJZCJVCg1Nb2RpZnlMaWNlbnNlEiwKEmFj" + 
          "Y291bnRfbGljZW5zZV9pZBgBIAEoBFIQYWNjb3VudExpY2Vuc2VJZBIWCgZz" + 
          "dGF0dXMYAiABKAVSBnN0YXR1cyIXChVNb2RpZnlMaWNlbnNlUmVzcG9uc2Ui" + 
          "ugIKD0JQYXlPcmRlclN0YXR1cxIWCgZzdGF0dXMYASABKAVSBnN0YXR1cxI/" + 
          "CgxlbnRpdGxlbWVudHMYAyADKAsyGy5EMy5TdG9yZS5FbnRpdGxlbWVudFVw" + 
          "ZGF0ZVIMZW50aXRsZW1lbnRzEj0KC2NvbnN1bWFibGVzGAQgAygLMhsuRDMu" + 
          "U3RvcmUuQ29uc3VtYWJsZUxpY2Vuc2VSC2NvbnN1bWFibGVzEjsKCGxpY2Vu" + 
          "c2VzGAUgAygLMh8uRDMuT25saW5lU2VydmljZVNlcnZlci5MaWNlbnNlUghs" + 
          "aWNlbnNlcxIYCgdyZXZva2VkGAYgASgIUgdyZXZva2VkEhkKCG9yZGVyX2lk" + 
          "GAcgASgJUgdvcmRlcklkEh0KCnByb2R1Y3RfaWQYCCABKA1SCXByb2R1Y3RJ" + 
          "ZCINCgtHZXRDdXJyZW5jeSIxChNHZXRDdXJyZW5jeVJlc3BvbnNlEhoKCGN1" + 
          "cnJlbmN5GAEgASgFUghjdXJyZW5jeSKpAQoRQ29uc3VtYWJsZUxpY2Vuc2US" + 
          "HAoJbGljZW5zZWlkGAEgASgEUglsaWNlbnNlaWQSLgoTbGljZW5zZV9pbnN0" + 
          "YW5jZV9pZBgCIAEoBFIRbGljZW5zZUluc3RhbmNlSWQSFgoGYW1vdW50GAMg" + 
          "ASgDUgZhbW91bnQSEgoEdHlwZRgEIAEoBVIEdHlwZRIaCghjb25zdW1lZBgF" + 
          "IAEoCFIIY29uc3VtZWQiYgoPTGljZW5zZUluc3RhbmNlEjkKB2xpY2Vuc2UY" + 
          "ASABKAsyHy5EMy5PbmxpbmVTZXJ2aWNlU2VydmVyLkxpY2Vuc2VSB2xpY2Vu" + 
          "c2USFAoFc3RhdGUYAiABKAVSBXN0YXRlIsQBChFMaWNlbnNlQXR0cmlidXRl" + 
          "cxIcCglsaWNlbnNlaWQYASABKARSCWxpY2Vuc2VpZBInCg9wbGF0aW51bV9h" + 
          "bW91bnQYAiABKARSDnBsYXRpbnVtQW1vdW50EhIKBGdiaWQYAyABKAVSBGdi" + 
          "aWQSLAoSY29udGVudF9saWNlbnNlX2lkGAQgAygFUhBjb250ZW50TGljZW5z" + 
          "ZUlkEiYKD21heF9zdGFja19jb3VudBgFIAEoDVINbWF4U3RhY2tDb3VudCKe" + 
          "AgoOUHJvZHVjdENhdGFsb2cSIwoNcHJvdG9fdmVyc2lvbhgBIAIoDVIMcHJv" + 
          "dG9WZXJzaW9uEjUKCHByb2R1Y3RzGAIgAygLMhkuRDMuU3RvcmUuSW50ZXJu" + 
          "YWxQcm9kdWN0Ughwcm9kdWN0cxJKChJsaWNlbnNlX2F0dHJpYnV0ZXMYAyAD" + 
          "KAsyGy5EMy5TdG9yZS5MaWNlbnNlQXR0cmlidXRlc1IRbGljZW5zZUF0dHJp" + 
          "YnV0ZXMSFgoGZGlnZXN0GAQgASgMUgZkaWdlc3QSGAoHdmVyc2lvbhgFIAEo" + 
          "A1IHdmVyc2lvbhIyCgpjdXJyZW5jaWVzGAYgAygLMhIuRDMuU3RvcmUuQ3Vy" + 
          "cmVuY3lSCmN1cnJlbmNpZXMiUwoSQ291bnRyeUluZm9ybWF0aW9uEiEKDGNv" + 
          "dW50cnlfbmFtZRgBIAEoCVILY291bnRyeU5hbWUSGgoIY3VycmVuY3kYAiAB" + 
          "KAVSCGN1cnJlbmN5IlAKDUNvdW50cnlDb25maWcSPwoMY291bnRyeV9pbmZv" + 
          "GAEgAygLMhwuRDMuU3RvcmUuQ291bnRyeUluZm9ybWF0aW9uUgtjb3VudHJ5" + 
          "SW5mbyIyChhDaGVja0dUQVBQU3RhdHVzUmVzcG9uc2USFgoGc3RhdHVzGAEg" + 
          "ASgNUgZzdGF0dXMiTgoPR2V0R1RBUFBCYWxhbmNlEhgKB2JhbGFuY2UYASAB" + 
          "KBJSB2JhbGFuY2USIQoMaGVsZF9iYWxhbmNlGAIgASgSUgtoZWxkQmFsYW5j" + 
          "ZQ==");
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_D3_Store_ProductPrice__Descriptor = Descriptor.MessageTypes[0];
        internal__static_D3_Store_ProductPrice__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.ProductPrice, global::D3.Store.ProductPrice.Builder>(internal__static_D3_Store_ProductPrice__Descriptor,
                new string[] { "Currency", "FixedPointCost", "FixedPointRetailPrice", });
        internal__static_D3_Store_ProductEntitlement__Descriptor = Descriptor.MessageTypes[1];
        internal__static_D3_Store_ProductEntitlement__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.ProductEntitlement, global::D3.Store.ProductEntitlement.Builder>(internal__static_D3_Store_ProductEntitlement__Descriptor,
                new string[] { "Gbid", "ContentLicenseId", "PlatinumAmount", "MaxStackCount", });
        internal__static_D3_Store_ContentLicenseRestriction__Descriptor = Descriptor.MessageTypes[2];
        internal__static_D3_Store_ContentLicenseRestriction__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.ContentLicenseRestriction, global::D3.Store.ContentLicenseRestriction.Builder>(internal__static_D3_Store_ContentLicenseRestriction__Descriptor,
                new string[] { "ContentLicenseId", "Count", });
        internal__static_D3_Store_Currency__Descriptor = Descriptor.MessageTypes[3];
        internal__static_D3_Store_Currency__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.Currency, global::D3.Store.Currency.Builder>(internal__static_D3_Store_Currency__Descriptor,
                new string[] { "Id", "Code", "Symbol", "Name", });
        internal__static_D3_Store_Product__Descriptor = Descriptor.MessageTypes[4];
        internal__static_D3_Store_Product__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.Product, global::D3.Store.Product.Builder>(internal__static_D3_Store_Product__Descriptor,
                new string[] { "Entitlements", "Prices", "Category", "AvailableFrom", "Featured", "DurationSecs", "MinContentlicensesRequired", "MaxContentlicensesAllowed", "BundleLabel", "NotForSale", "ProductId", });
        internal__static_D3_Store_ProductCategory__Descriptor = Descriptor.MessageTypes[5];
        internal__static_D3_Store_ProductCategory__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.ProductCategory, global::D3.Store.ProductCategory.Builder>(internal__static_D3_Store_ProductCategory__Descriptor,
                new string[] { "Category", "NewestProductTime", });
        internal__static_D3_Store_Risk__Descriptor = Descriptor.MessageTypes[6];
        internal__static_D3_Store_Risk__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.Risk, global::D3.Store.Risk.Builder>(internal__static_D3_Store_Risk__Descriptor,
                new string[] { "RiskType", "TransactionId", "ChallengeId", "ChallengeUrl", });
        internal__static_D3_Store_Wallet__Descriptor = Descriptor.MessageTypes[7];
        internal__static_D3_Store_Wallet__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.Wallet, global::D3.Store.Wallet.Builder>(internal__static_D3_Store_Wallet__Descriptor,
                new string[] { "WalletId", "WalletName", "Primary", "WalletType", "WalletExpirationDate", "Risk", "FixedPointBalance", });
        internal__static_D3_Store_Order__Descriptor = Descriptor.MessageTypes[8];
        internal__static_D3_Store_Order__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.Order, global::D3.Store.Order.Builder>(internal__static_D3_Store_Order__Descriptor,
                new string[] { "Status", "TransactionId", "ErrorCode", "Acknowledged", });
        internal__static_D3_Store_GetProductList__Descriptor = Descriptor.MessageTypes[9];
        internal__static_D3_Store_GetProductList__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetProductList, global::D3.Store.GetProductList.Builder>(internal__static_D3_Store_GetProductList__Descriptor,
                new string[] { "Category", "CatalogVersion", });
        internal__static_D3_Store_GetProductListResponse__Descriptor = Descriptor.MessageTypes[10];
        internal__static_D3_Store_GetProductListResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetProductListResponse, global::D3.Store.GetProductListResponse.Builder>(internal__static_D3_Store_GetProductListResponse__Descriptor,
                new string[] { "Products", "ValidForSecs", "Currencies", });
        internal__static_D3_Store_GetProduct__Descriptor = Descriptor.MessageTypes[11];
        internal__static_D3_Store_GetProduct__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetProduct, global::D3.Store.GetProduct.Builder>(internal__static_D3_Store_GetProduct__Descriptor,
                new string[] { "ProductId", });
        internal__static_D3_Store_GetProductResponse__Descriptor = Descriptor.MessageTypes[12];
        internal__static_D3_Store_GetProductResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetProductResponse, global::D3.Store.GetProductResponse.Builder>(internal__static_D3_Store_GetProductResponse__Descriptor,
                new string[] { "Product", "Currencies", });
        internal__static_D3_Store_GetProductCategories__Descriptor = Descriptor.MessageTypes[13];
        internal__static_D3_Store_GetProductCategories__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetProductCategories, global::D3.Store.GetProductCategories.Builder>(internal__static_D3_Store_GetProductCategories__Descriptor,
                new string[] { "CatalogVersion", });
        internal__static_D3_Store_GetProductCategoriesResponse__Descriptor = Descriptor.MessageTypes[14];
        internal__static_D3_Store_GetProductCategoriesResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetProductCategoriesResponse, global::D3.Store.GetProductCategoriesResponse.Builder>(internal__static_D3_Store_GetProductCategoriesResponse__Descriptor,
                new string[] { "Categories", });
        internal__static_D3_Store_GetPrimaryCurrency__Descriptor = Descriptor.MessageTypes[15];
        internal__static_D3_Store_GetPrimaryCurrency__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetPrimaryCurrency, global::D3.Store.GetPrimaryCurrency.Builder>(internal__static_D3_Store_GetPrimaryCurrency__Descriptor,
                new string[] { });
        internal__static_D3_Store_GetPrimaryCurrencyResponse__Descriptor = Descriptor.MessageTypes[16];
        internal__static_D3_Store_GetPrimaryCurrencyResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetPrimaryCurrencyResponse, global::D3.Store.GetPrimaryCurrencyResponse.Builder>(internal__static_D3_Store_GetPrimaryCurrencyResponse__Descriptor,
                new string[] { "Currency", });
        internal__static_D3_Store_GetPaymentMethods__Descriptor = Descriptor.MessageTypes[17];
        internal__static_D3_Store_GetPaymentMethods__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetPaymentMethods, global::D3.Store.GetPaymentMethods.Builder>(internal__static_D3_Store_GetPaymentMethods__Descriptor,
                new string[] { "Currency", });
        internal__static_D3_Store_GetPaymentMethodsResponse__Descriptor = Descriptor.MessageTypes[18];
        internal__static_D3_Store_GetPaymentMethodsResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetPaymentMethodsResponse, global::D3.Store.GetPaymentMethodsResponse.Builder>(internal__static_D3_Store_GetPaymentMethodsResponse__Descriptor,
                new string[] { "Wallets", });
        internal__static_D3_Store_DetermineRisk__Descriptor = Descriptor.MessageTypes[19];
        internal__static_D3_Store_DetermineRisk__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.DetermineRisk, global::D3.Store.DetermineRisk.Builder>(internal__static_D3_Store_DetermineRisk__Descriptor,
                new string[] { "WalletId", "Currency", "DeviceId", "ProductId", });
        internal__static_D3_Store_DetermineRiskResponse__Descriptor = Descriptor.MessageTypes[20];
        internal__static_D3_Store_DetermineRiskResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.DetermineRiskResponse, global::D3.Store.DetermineRiskResponse.Builder>(internal__static_D3_Store_DetermineRiskResponse__Descriptor,
                new string[] { "Risk", "WalletId", });
        internal__static_D3_Store_PlaceOrder__Descriptor = Descriptor.MessageTypes[21];
        internal__static_D3_Store_PlaceOrder__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.PlaceOrder, global::D3.Store.PlaceOrder.Builder>(internal__static_D3_Store_PlaceOrder__Descriptor,
                new string[] { "WalletId", "Currency", "RiskTransactionId", "ChallengeId", "DeviceId", "ProductId", "FixedPointExpectedPrice", });
        internal__static_D3_Store_PlaceOrderResponse__Descriptor = Descriptor.MessageTypes[22];
        internal__static_D3_Store_PlaceOrderResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.PlaceOrderResponse, global::D3.Store.PlaceOrderResponse.Builder>(internal__static_D3_Store_PlaceOrderResponse__Descriptor,
                new string[] { "TransactionId", });
        internal__static_D3_Store_EntitlementUpdate__Descriptor = Descriptor.MessageTypes[23];
        internal__static_D3_Store_EntitlementUpdate__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.EntitlementUpdate, global::D3.Store.EntitlementUpdate.Builder>(internal__static_D3_Store_EntitlementUpdate__Descriptor,
                new string[] { "Entitlement", "ExpireTime", });
        internal__static_D3_Store_OrderStatus__Descriptor = Descriptor.MessageTypes[24];
        internal__static_D3_Store_OrderStatus__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.OrderStatus, global::D3.Store.OrderStatus.Builder>(internal__static_D3_Store_OrderStatus__Descriptor,
                new string[] { "Order", "LimitedEntitlements", "CreationTime", "ProductId", });
        internal__static_D3_Store_MissingEntitlement__Descriptor = Descriptor.MessageTypes[25];
        internal__static_D3_Store_MissingEntitlement__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.MissingEntitlement, global::D3.Store.MissingEntitlement.Builder>(internal__static_D3_Store_MissingEntitlement__Descriptor,
                new string[] { "Definition", "AcknowledgeId", "Expired", });
        internal__static_D3_Store_MissingEntitlements__Descriptor = Descriptor.MessageTypes[26];
        internal__static_D3_Store_MissingEntitlements__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.MissingEntitlements, global::D3.Store.MissingEntitlements.Builder>(internal__static_D3_Store_MissingEntitlements__Descriptor,
                new string[] { "Entitlement", });
        internal__static_D3_Store_AcknowledgeOrder__Descriptor = Descriptor.MessageTypes[27];
        internal__static_D3_Store_AcknowledgeOrder__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.AcknowledgeOrder, global::D3.Store.AcknowledgeOrder.Builder>(internal__static_D3_Store_AcknowledgeOrder__Descriptor,
                new string[] { "TransactionId", "ErrorCode", });
        internal__static_D3_Store_AcknowledgeMissingLicenses__Descriptor = Descriptor.MessageTypes[28];
        internal__static_D3_Store_AcknowledgeMissingLicenses__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.AcknowledgeMissingLicenses, global::D3.Store.AcknowledgeMissingLicenses.Builder>(internal__static_D3_Store_AcknowledgeMissingLicenses__Descriptor,
                new string[] { "AcknowledgeId", });
        internal__static_D3_Store_AcknowledgeOrderResponse__Descriptor = Descriptor.MessageTypes[29];
        internal__static_D3_Store_AcknowledgeOrderResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.AcknowledgeOrderResponse, global::D3.Store.AcknowledgeOrderResponse.Builder>(internal__static_D3_Store_AcknowledgeOrderResponse__Descriptor,
                new string[] { });
        internal__static_D3_Store_CheckOrderStatus__Descriptor = Descriptor.MessageTypes[30];
        internal__static_D3_Store_CheckOrderStatus__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.CheckOrderStatus, global::D3.Store.CheckOrderStatus.Builder>(internal__static_D3_Store_CheckOrderStatus__Descriptor,
                new string[] { "TransactionId", });
        internal__static_D3_Store_CheckOrderStatusResponse__Descriptor = Descriptor.MessageTypes[31];
        internal__static_D3_Store_CheckOrderStatusResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.CheckOrderStatusResponse, global::D3.Store.CheckOrderStatusResponse.Builder>(internal__static_D3_Store_CheckOrderStatusResponse__Descriptor,
                new string[] { "TransactionId", });
        internal__static_D3_Store_StoreStatus__Descriptor = Descriptor.MessageTypes[32];
        internal__static_D3_Store_StoreStatus__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.StoreStatus, global::D3.Store.StoreStatus.Builder>(internal__static_D3_Store_StoreStatus__Descriptor,
                new string[] { "StoreStatus_", "StoreStatusChangedTime", });
        internal__static_D3_Store_GetBalance__Descriptor = Descriptor.MessageTypes[33];
        internal__static_D3_Store_GetBalance__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetBalance, global::D3.Store.GetBalance.Builder>(internal__static_D3_Store_GetBalance__Descriptor,
                new string[] { "Currency", });
        internal__static_D3_Store_GetBalanceResponse__Descriptor = Descriptor.MessageTypes[34];
        internal__static_D3_Store_GetBalanceResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetBalanceResponse, global::D3.Store.GetBalanceResponse.Builder>(internal__static_D3_Store_GetBalanceResponse__Descriptor,
                new string[] { "FixedPointBalance", });
        internal__static_D3_Store_InternalOrder__Descriptor = Descriptor.MessageTypes[35];
        internal__static_D3_Store_InternalOrder__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.InternalOrder, global::D3.Store.InternalOrder.Builder>(internal__static_D3_Store_InternalOrder__Descriptor,
                new string[] { "Order", "OrderId", "AccountId", "GameAccountId", "CreationTime", "UnderManualReview", "BootstrapTime", "ProductId", });
        internal__static_D3_Store_InternalProduct__Descriptor = Descriptor.MessageTypes[36];
        internal__static_D3_Store_InternalProduct__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.InternalProduct, global::D3.Store.InternalProduct.Builder>(internal__static_D3_Store_InternalProduct__Descriptor,
                new string[] { "Product", "LicenseIds", "FreeInIgr", "EarliestValidVersion", });
        internal__static_D3_Store_InternalPlaceOrderResponse__Descriptor = Descriptor.MessageTypes[37];
        internal__static_D3_Store_InternalPlaceOrderResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.InternalPlaceOrderResponse, global::D3.Store.InternalPlaceOrderResponse.Builder>(internal__static_D3_Store_InternalPlaceOrderResponse__Descriptor,
                new string[] { "OrderId", });
        internal__static_D3_Store_ModifyLicense__Descriptor = Descriptor.MessageTypes[38];
        internal__static_D3_Store_ModifyLicense__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.ModifyLicense, global::D3.Store.ModifyLicense.Builder>(internal__static_D3_Store_ModifyLicense__Descriptor,
                new string[] { "AccountLicenseId", "Status", });
        internal__static_D3_Store_ModifyLicenseResponse__Descriptor = Descriptor.MessageTypes[39];
        internal__static_D3_Store_ModifyLicenseResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.ModifyLicenseResponse, global::D3.Store.ModifyLicenseResponse.Builder>(internal__static_D3_Store_ModifyLicenseResponse__Descriptor,
                new string[] { });
        internal__static_D3_Store_BPayOrderStatus__Descriptor = Descriptor.MessageTypes[40];
        internal__static_D3_Store_BPayOrderStatus__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.BPayOrderStatus, global::D3.Store.BPayOrderStatus.Builder>(internal__static_D3_Store_BPayOrderStatus__Descriptor,
                new string[] { "Status", "Entitlements", "Consumables", "Licenses", "Revoked", "OrderId", "ProductId", });
        internal__static_D3_Store_GetCurrency__Descriptor = Descriptor.MessageTypes[41];
        internal__static_D3_Store_GetCurrency__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetCurrency, global::D3.Store.GetCurrency.Builder>(internal__static_D3_Store_GetCurrency__Descriptor,
                new string[] { });
        internal__static_D3_Store_GetCurrencyResponse__Descriptor = Descriptor.MessageTypes[42];
        internal__static_D3_Store_GetCurrencyResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetCurrencyResponse, global::D3.Store.GetCurrencyResponse.Builder>(internal__static_D3_Store_GetCurrencyResponse__Descriptor,
                new string[] { "Currency", });
        internal__static_D3_Store_ConsumableLicense__Descriptor = Descriptor.MessageTypes[43];
        internal__static_D3_Store_ConsumableLicense__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.ConsumableLicense, global::D3.Store.ConsumableLicense.Builder>(internal__static_D3_Store_ConsumableLicense__Descriptor,
                new string[] { "Licenseid", "LicenseInstanceId", "Amount", "Type", "Consumed", });
        internal__static_D3_Store_LicenseInstance__Descriptor = Descriptor.MessageTypes[44];
        internal__static_D3_Store_LicenseInstance__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.LicenseInstance, global::D3.Store.LicenseInstance.Builder>(internal__static_D3_Store_LicenseInstance__Descriptor,
                new string[] { "License", "State", });
        internal__static_D3_Store_LicenseAttributes__Descriptor = Descriptor.MessageTypes[45];
        internal__static_D3_Store_LicenseAttributes__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.LicenseAttributes, global::D3.Store.LicenseAttributes.Builder>(internal__static_D3_Store_LicenseAttributes__Descriptor,
                new string[] { "Licenseid", "PlatinumAmount", "Gbid", "ContentLicenseId", "MaxStackCount", });
        internal__static_D3_Store_ProductCatalog__Descriptor = Descriptor.MessageTypes[46];
        internal__static_D3_Store_ProductCatalog__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.ProductCatalog, global::D3.Store.ProductCatalog.Builder>(internal__static_D3_Store_ProductCatalog__Descriptor,
                new string[] { "ProtoVersion", "Products", "LicenseAttributes", "Digest", "Version", "Currencies", });
        internal__static_D3_Store_CountryInformation__Descriptor = Descriptor.MessageTypes[47];
        internal__static_D3_Store_CountryInformation__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.CountryInformation, global::D3.Store.CountryInformation.Builder>(internal__static_D3_Store_CountryInformation__Descriptor,
                new string[] { "CountryName", "Currency", });
        internal__static_D3_Store_CountryConfig__Descriptor = Descriptor.MessageTypes[48];
        internal__static_D3_Store_CountryConfig__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.CountryConfig, global::D3.Store.CountryConfig.Builder>(internal__static_D3_Store_CountryConfig__Descriptor,
                new string[] { "CountryInfo", });
        internal__static_D3_Store_CheckGTAPPStatusResponse__Descriptor = Descriptor.MessageTypes[49];
        internal__static_D3_Store_CheckGTAPPStatusResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.CheckGTAPPStatusResponse, global::D3.Store.CheckGTAPPStatusResponse.Builder>(internal__static_D3_Store_CheckGTAPPStatusResponse__Descriptor,
                new string[] { "Status", });
        internal__static_D3_Store_GetGTAPPBalance__Descriptor = Descriptor.MessageTypes[50];
        internal__static_D3_Store_GetGTAPPBalance__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.Store.GetGTAPPBalance, global::D3.Store.GetGTAPPBalance.Builder>(internal__static_D3_Store_GetGTAPPBalance__Descriptor,
                new string[] { "Balance", "HeldBalance", });
        pb::ExtensionRegistry registry = pb::ExtensionRegistry.CreateInstance();
        RegisterAllExtensions(registry);
        global::D3.OnlineServiceServer.OnlineServiceServer.RegisterAllExtensions(registry);
        return registry;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          global::D3.OnlineServiceServer.OnlineServiceServer.Descriptor, 
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ProductPrice : pb::GeneratedMessage<ProductPrice, ProductPrice.Builder> {
    private ProductPrice() { }
    private static readonly ProductPrice defaultInstance = new ProductPrice().MakeReadOnly();
    private static readonly string[] _productPriceFieldNames = new string[] { "currency", "fixed_point_cost", "fixed_point_retail_price" };
    private static readonly uint[] _productPriceFieldTags = new uint[] { 8, 32, 40 };
    public static ProductPrice DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ProductPrice DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ProductPrice ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_ProductPrice__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ProductPrice, ProductPrice.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_ProductPrice__FieldAccessorTable; }
    }
    
    public const int CurrencyFieldNumber = 1;
    private bool hasCurrency;
    private int currency_;
    public bool HasCurrency {
      get { return hasCurrency; }
    }
    public int Currency {
      get { return currency_; }
    }
    
    public const int FixedPointCostFieldNumber = 4;
    private bool hasFixedPointCost;
    private long fixedPointCost_;
    public bool HasFixedPointCost {
      get { return hasFixedPointCost; }
    }
    public long FixedPointCost {
      get { return fixedPointCost_; }
    }
    
    public const int FixedPointRetailPriceFieldNumber = 5;
    private bool hasFixedPointRetailPrice;
    private long fixedPointRetailPrice_;
    public bool HasFixedPointRetailPrice {
      get { return hasFixedPointRetailPrice; }
    }
    public long FixedPointRetailPrice {
      get { return fixedPointRetailPrice_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _productPriceFieldNames;
      if (hasCurrency) {
        output.WriteInt32(1, field_names[0], Currency);
      }
      if (hasFixedPointCost) {
        output.WriteSInt64(4, field_names[1], FixedPointCost);
      }
      if (hasFixedPointRetailPrice) {
        output.WriteSInt64(5, field_names[2], FixedPointRetailPrice);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCurrency) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, Currency);
        }
        if (hasFixedPointCost) {
          size += pb::CodedOutputStream.ComputeSInt64Size(4, FixedPointCost);
        }
        if (hasFixedPointRetailPrice) {
          size += pb::CodedOutputStream.ComputeSInt64Size(5, FixedPointRetailPrice);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ProductPrice ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ProductPrice ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ProductPrice ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ProductPrice ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ProductPrice ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ProductPrice ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ProductPrice ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ProductPrice ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ProductPrice ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ProductPrice ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ProductPrice MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ProductPrice prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ProductPrice, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ProductPrice cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ProductPrice result;
      
      private ProductPrice PrepareBuilder() {
        if (resultIsReadOnly) {
          ProductPrice original = result;
          result = new ProductPrice();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ProductPrice MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.ProductPrice.Descriptor; }
      }
      
      public override ProductPrice DefaultInstanceForType {
        get { return global::D3.Store.ProductPrice.DefaultInstance; }
      }
      
      public override ProductPrice BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ProductPrice) {
          return MergeFrom((ProductPrice) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ProductPrice other) {
        if (other == global::D3.Store.ProductPrice.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCurrency) {
          Currency = other.Currency;
        }
        if (other.HasFixedPointCost) {
          FixedPointCost = other.FixedPointCost;
        }
        if (other.HasFixedPointRetailPrice) {
          FixedPointRetailPrice = other.FixedPointRetailPrice;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_productPriceFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _productPriceFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasCurrency = input.ReadInt32(ref result.currency_);
              break;
            }
            case 32: {
              result.hasFixedPointCost = input.ReadSInt64(ref result.fixedPointCost_);
              break;
            }
            case 40: {
              result.hasFixedPointRetailPrice = input.ReadSInt64(ref result.fixedPointRetailPrice_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCurrency {
        get { return result.hasCurrency; }
      }
      public int Currency {
        get { return result.Currency; }
        set { SetCurrency(value); }
      }
      public Builder SetCurrency(int value) {
        PrepareBuilder();
        result.hasCurrency = true;
        result.currency_ = value;
        return this;
      }
      public Builder ClearCurrency() {
        PrepareBuilder();
        result.hasCurrency = false;
        result.currency_ = 0;
        return this;
      }
      
      public bool HasFixedPointCost {
        get { return result.hasFixedPointCost; }
      }
      public long FixedPointCost {
        get { return result.FixedPointCost; }
        set { SetFixedPointCost(value); }
      }
      public Builder SetFixedPointCost(long value) {
        PrepareBuilder();
        result.hasFixedPointCost = true;
        result.fixedPointCost_ = value;
        return this;
      }
      public Builder ClearFixedPointCost() {
        PrepareBuilder();
        result.hasFixedPointCost = false;
        result.fixedPointCost_ = 0;
        return this;
      }
      
      public bool HasFixedPointRetailPrice {
        get { return result.hasFixedPointRetailPrice; }
      }
      public long FixedPointRetailPrice {
        get { return result.FixedPointRetailPrice; }
        set { SetFixedPointRetailPrice(value); }
      }
      public Builder SetFixedPointRetailPrice(long value) {
        PrepareBuilder();
        result.hasFixedPointRetailPrice = true;
        result.fixedPointRetailPrice_ = value;
        return this;
      }
      public Builder ClearFixedPointRetailPrice() {
        PrepareBuilder();
        result.hasFixedPointRetailPrice = false;
        result.fixedPointRetailPrice_ = 0;
        return this;
      }
    }
    static ProductPrice() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ProductEntitlement : pb::GeneratedMessage<ProductEntitlement, ProductEntitlement.Builder> {
    private ProductEntitlement() { }
    private static readonly ProductEntitlement defaultInstance = new ProductEntitlement().MakeReadOnly();
    private static readonly string[] _productEntitlementFieldNames = new string[] { "content_license_id", "gbid", "max_stack_count", "platinum_amount" };
    private static readonly uint[] _productEntitlementFieldTags = new uint[] { 16, 8, 40, 24 };
    public static ProductEntitlement DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ProductEntitlement DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ProductEntitlement ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_ProductEntitlement__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ProductEntitlement, ProductEntitlement.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_ProductEntitlement__FieldAccessorTable; }
    }
    
    public const int GbidFieldNumber = 1;
    private bool hasGbid;
    private int gbid_;
    public bool HasGbid {
      get { return hasGbid; }
    }
    public int Gbid {
      get { return gbid_; }
    }
    
    public const int ContentLicenseIdFieldNumber = 2;
    private bool hasContentLicenseId;
    private uint contentLicenseId_;
    public bool HasContentLicenseId {
      get { return hasContentLicenseId; }
    }
    public uint ContentLicenseId {
      get { return contentLicenseId_; }
    }
    
    public const int PlatinumAmountFieldNumber = 3;
    private bool hasPlatinumAmount;
    private ulong platinumAmount_;
    public bool HasPlatinumAmount {
      get { return hasPlatinumAmount; }
    }
    public ulong PlatinumAmount {
      get { return platinumAmount_; }
    }
    
    public const int MaxStackCountFieldNumber = 5;
    private bool hasMaxStackCount;
    private uint maxStackCount_;
    public bool HasMaxStackCount {
      get { return hasMaxStackCount; }
    }
    public uint MaxStackCount {
      get { return maxStackCount_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _productEntitlementFieldNames;
      if (hasGbid) {
        output.WriteInt32(1, field_names[1], Gbid);
      }
      if (hasContentLicenseId) {
        output.WriteUInt32(2, field_names[0], ContentLicenseId);
      }
      if (hasPlatinumAmount) {
        output.WriteUInt64(3, field_names[3], PlatinumAmount);
      }
      if (hasMaxStackCount) {
        output.WriteUInt32(5, field_names[2], MaxStackCount);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasGbid) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, Gbid);
        }
        if (hasContentLicenseId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, ContentLicenseId);
        }
        if (hasPlatinumAmount) {
          size += pb::CodedOutputStream.ComputeUInt64Size(3, PlatinumAmount);
        }
        if (hasMaxStackCount) {
          size += pb::CodedOutputStream.ComputeUInt32Size(5, MaxStackCount);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ProductEntitlement ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ProductEntitlement ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ProductEntitlement ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ProductEntitlement ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ProductEntitlement ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ProductEntitlement ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ProductEntitlement ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ProductEntitlement ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ProductEntitlement ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ProductEntitlement ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ProductEntitlement MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ProductEntitlement prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ProductEntitlement, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ProductEntitlement cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ProductEntitlement result;
      
      private ProductEntitlement PrepareBuilder() {
        if (resultIsReadOnly) {
          ProductEntitlement original = result;
          result = new ProductEntitlement();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ProductEntitlement MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.ProductEntitlement.Descriptor; }
      }
      
      public override ProductEntitlement DefaultInstanceForType {
        get { return global::D3.Store.ProductEntitlement.DefaultInstance; }
      }
      
      public override ProductEntitlement BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ProductEntitlement) {
          return MergeFrom((ProductEntitlement) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ProductEntitlement other) {
        if (other == global::D3.Store.ProductEntitlement.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasGbid) {
          Gbid = other.Gbid;
        }
        if (other.HasContentLicenseId) {
          ContentLicenseId = other.ContentLicenseId;
        }
        if (other.HasPlatinumAmount) {
          PlatinumAmount = other.PlatinumAmount;
        }
        if (other.HasMaxStackCount) {
          MaxStackCount = other.MaxStackCount;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_productEntitlementFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _productEntitlementFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasGbid = input.ReadInt32(ref result.gbid_);
              break;
            }
            case 16: {
              result.hasContentLicenseId = input.ReadUInt32(ref result.contentLicenseId_);
              break;
            }
            case 24: {
              result.hasPlatinumAmount = input.ReadUInt64(ref result.platinumAmount_);
              break;
            }
            case 40: {
              result.hasMaxStackCount = input.ReadUInt32(ref result.maxStackCount_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasGbid {
        get { return result.hasGbid; }
      }
      public int Gbid {
        get { return result.Gbid; }
        set { SetGbid(value); }
      }
      public Builder SetGbid(int value) {
        PrepareBuilder();
        result.hasGbid = true;
        result.gbid_ = value;
        return this;
      }
      public Builder ClearGbid() {
        PrepareBuilder();
        result.hasGbid = false;
        result.gbid_ = 0;
        return this;
      }
      
      public bool HasContentLicenseId {
        get { return result.hasContentLicenseId; }
      }
      public uint ContentLicenseId {
        get { return result.ContentLicenseId; }
        set { SetContentLicenseId(value); }
      }
      public Builder SetContentLicenseId(uint value) {
        PrepareBuilder();
        result.hasContentLicenseId = true;
        result.contentLicenseId_ = value;
        return this;
      }
      public Builder ClearContentLicenseId() {
        PrepareBuilder();
        result.hasContentLicenseId = false;
        result.contentLicenseId_ = 0;
        return this;
      }
      
      public bool HasPlatinumAmount {
        get { return result.hasPlatinumAmount; }
      }
      public ulong PlatinumAmount {
        get { return result.PlatinumAmount; }
        set { SetPlatinumAmount(value); }
      }
      public Builder SetPlatinumAmount(ulong value) {
        PrepareBuilder();
        result.hasPlatinumAmount = true;
        result.platinumAmount_ = value;
        return this;
      }
      public Builder ClearPlatinumAmount() {
        PrepareBuilder();
        result.hasPlatinumAmount = false;
        result.platinumAmount_ = 0UL;
        return this;
      }
      
      public bool HasMaxStackCount {
        get { return result.hasMaxStackCount; }
      }
      public uint MaxStackCount {
        get { return result.MaxStackCount; }
        set { SetMaxStackCount(value); }
      }
      public Builder SetMaxStackCount(uint value) {
        PrepareBuilder();
        result.hasMaxStackCount = true;
        result.maxStackCount_ = value;
        return this;
      }
      public Builder ClearMaxStackCount() {
        PrepareBuilder();
        result.hasMaxStackCount = false;
        result.maxStackCount_ = 0;
        return this;
      }
    }
    static ProductEntitlement() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ContentLicenseRestriction : pb::GeneratedMessage<ContentLicenseRestriction, ContentLicenseRestriction.Builder> {
    private ContentLicenseRestriction() { }
    private static readonly ContentLicenseRestriction defaultInstance = new ContentLicenseRestriction().MakeReadOnly();
    private static readonly string[] _contentLicenseRestrictionFieldNames = new string[] { "content_license_id", "count" };
    private static readonly uint[] _contentLicenseRestrictionFieldTags = new uint[] { 8, 16 };
    public static ContentLicenseRestriction DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ContentLicenseRestriction DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ContentLicenseRestriction ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_ContentLicenseRestriction__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ContentLicenseRestriction, ContentLicenseRestriction.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_ContentLicenseRestriction__FieldAccessorTable; }
    }
    
    public const int ContentLicenseIdFieldNumber = 1;
    private bool hasContentLicenseId;
    private uint contentLicenseId_;
    public bool HasContentLicenseId {
      get { return hasContentLicenseId; }
    }
    public uint ContentLicenseId {
      get { return contentLicenseId_; }
    }
    
    public const int CountFieldNumber = 2;
    private bool hasCount;
    private uint count_;
    public bool HasCount {
      get { return hasCount; }
    }
    public uint Count {
      get { return count_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _contentLicenseRestrictionFieldNames;
      if (hasContentLicenseId) {
        output.WriteUInt32(1, field_names[0], ContentLicenseId);
      }
      if (hasCount) {
        output.WriteUInt32(2, field_names[1], Count);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasContentLicenseId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, ContentLicenseId);
        }
        if (hasCount) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, Count);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ContentLicenseRestriction ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ContentLicenseRestriction ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ContentLicenseRestriction ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ContentLicenseRestriction ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ContentLicenseRestriction ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ContentLicenseRestriction ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ContentLicenseRestriction ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ContentLicenseRestriction ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ContentLicenseRestriction ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ContentLicenseRestriction ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ContentLicenseRestriction MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ContentLicenseRestriction prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ContentLicenseRestriction, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ContentLicenseRestriction cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ContentLicenseRestriction result;
      
      private ContentLicenseRestriction PrepareBuilder() {
        if (resultIsReadOnly) {
          ContentLicenseRestriction original = result;
          result = new ContentLicenseRestriction();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ContentLicenseRestriction MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.ContentLicenseRestriction.Descriptor; }
      }
      
      public override ContentLicenseRestriction DefaultInstanceForType {
        get { return global::D3.Store.ContentLicenseRestriction.DefaultInstance; }
      }
      
      public override ContentLicenseRestriction BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ContentLicenseRestriction) {
          return MergeFrom((ContentLicenseRestriction) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ContentLicenseRestriction other) {
        if (other == global::D3.Store.ContentLicenseRestriction.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasContentLicenseId) {
          ContentLicenseId = other.ContentLicenseId;
        }
        if (other.HasCount) {
          Count = other.Count;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_contentLicenseRestrictionFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _contentLicenseRestrictionFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasContentLicenseId = input.ReadUInt32(ref result.contentLicenseId_);
              break;
            }
            case 16: {
              result.hasCount = input.ReadUInt32(ref result.count_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasContentLicenseId {
        get { return result.hasContentLicenseId; }
      }
      public uint ContentLicenseId {
        get { return result.ContentLicenseId; }
        set { SetContentLicenseId(value); }
      }
      public Builder SetContentLicenseId(uint value) {
        PrepareBuilder();
        result.hasContentLicenseId = true;
        result.contentLicenseId_ = value;
        return this;
      }
      public Builder ClearContentLicenseId() {
        PrepareBuilder();
        result.hasContentLicenseId = false;
        result.contentLicenseId_ = 0;
        return this;
      }
      
      public bool HasCount {
        get { return result.hasCount; }
      }
      public uint Count {
        get { return result.Count; }
        set { SetCount(value); }
      }
      public Builder SetCount(uint value) {
        PrepareBuilder();
        result.hasCount = true;
        result.count_ = value;
        return this;
      }
      public Builder ClearCount() {
        PrepareBuilder();
        result.hasCount = false;
        result.count_ = 0;
        return this;
      }
    }
    static ContentLicenseRestriction() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Currency : pb::GeneratedMessage<Currency, Currency.Builder> {
    private Currency() { }
    private static readonly Currency defaultInstance = new Currency().MakeReadOnly();
    private static readonly string[] _currencyFieldNames = new string[] { "code", "id", "name", "symbol" };
    private static readonly uint[] _currencyFieldTags = new uint[] { 18, 8, 34, 26 };
    public static Currency DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Currency DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Currency ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_Currency__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Currency, Currency.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_Currency__FieldAccessorTable; }
    }
    
    public const int IdFieldNumber = 1;
    private bool hasId;
    private int id_;
    public bool HasId {
      get { return hasId; }
    }
    public int Id {
      get { return id_; }
    }
    
    public const int CodeFieldNumber = 2;
    private bool hasCode;
    private string code_ = "";
    public bool HasCode {
      get { return hasCode; }
    }
    public string Code {
      get { return code_; }
    }
    
    public const int SymbolFieldNumber = 3;
    private bool hasSymbol;
    private string symbol_ = "";
    public bool HasSymbol {
      get { return hasSymbol; }
    }
    public string Symbol {
      get { return symbol_; }
    }
    
    public const int NameFieldNumber = 4;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _currencyFieldNames;
      if (hasId) {
        output.WriteInt32(1, field_names[1], Id);
      }
      if (hasCode) {
        output.WriteString(2, field_names[0], Code);
      }
      if (hasSymbol) {
        output.WriteString(3, field_names[3], Symbol);
      }
      if (hasName) {
        output.WriteString(4, field_names[2], Name);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasId) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, Id);
        }
        if (hasCode) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Code);
        }
        if (hasSymbol) {
          size += pb::CodedOutputStream.ComputeStringSize(3, Symbol);
        }
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(4, Name);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Currency ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Currency ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Currency ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Currency ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Currency ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Currency ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Currency ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Currency ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Currency ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Currency ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Currency MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Currency prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Currency, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Currency cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Currency result;
      
      private Currency PrepareBuilder() {
        if (resultIsReadOnly) {
          Currency original = result;
          result = new Currency();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Currency MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.Currency.Descriptor; }
      }
      
      public override Currency DefaultInstanceForType {
        get { return global::D3.Store.Currency.DefaultInstance; }
      }
      
      public override Currency BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Currency) {
          return MergeFrom((Currency) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Currency other) {
        if (other == global::D3.Store.Currency.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasId) {
          Id = other.Id;
        }
        if (other.HasCode) {
          Code = other.Code;
        }
        if (other.HasSymbol) {
          Symbol = other.Symbol;
        }
        if (other.HasName) {
          Name = other.Name;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_currencyFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _currencyFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasId = input.ReadInt32(ref result.id_);
              break;
            }
            case 18: {
              result.hasCode = input.ReadString(ref result.code_);
              break;
            }
            case 26: {
              result.hasSymbol = input.ReadString(ref result.symbol_);
              break;
            }
            case 34: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasId {
        get { return result.hasId; }
      }
      public int Id {
        get { return result.Id; }
        set { SetId(value); }
      }
      public Builder SetId(int value) {
        PrepareBuilder();
        result.hasId = true;
        result.id_ = value;
        return this;
      }
      public Builder ClearId() {
        PrepareBuilder();
        result.hasId = false;
        result.id_ = 0;
        return this;
      }
      
      public bool HasCode {
        get { return result.hasCode; }
      }
      public string Code {
        get { return result.Code; }
        set { SetCode(value); }
      }
      public Builder SetCode(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCode = true;
        result.code_ = value;
        return this;
      }
      public Builder ClearCode() {
        PrepareBuilder();
        result.hasCode = false;
        result.code_ = "";
        return this;
      }
      
      public bool HasSymbol {
        get { return result.hasSymbol; }
      }
      public string Symbol {
        get { return result.Symbol; }
        set { SetSymbol(value); }
      }
      public Builder SetSymbol(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSymbol = true;
        result.symbol_ = value;
        return this;
      }
      public Builder ClearSymbol() {
        PrepareBuilder();
        result.hasSymbol = false;
        result.symbol_ = "";
        return this;
      }
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
    }
    static Currency() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Product : pb::GeneratedMessage<Product, Product.Builder> {
    private Product() { }
    private static readonly Product defaultInstance = new Product().MakeReadOnly();
    private static readonly string[] _productFieldNames = new string[] { "available_from", "bundle_label", "category", "duration_secs", "entitlements", "featured", "max_contentlicenses_allowed", "min_contentlicenses_required", "not_for_sale", "prices", "product_id" };
    private static readonly uint[] _productFieldTags = new uint[] { 40, 82, 32, 56, 18, 48, 74, 66, 88, 26, 96 };
    public static Product DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Product DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Product ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_Product__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Product, Product.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_Product__FieldAccessorTable; }
    }
    
    public const int EntitlementsFieldNumber = 2;
    private pbc::PopsicleList<global::D3.Store.ProductEntitlement> entitlements_ = new pbc::PopsicleList<global::D3.Store.ProductEntitlement>();
    public scg::IList<global::D3.Store.ProductEntitlement> EntitlementsList {
      get { return entitlements_; }
    }
    public int EntitlementsCount {
      get { return entitlements_.Count; }
    }
    public global::D3.Store.ProductEntitlement GetEntitlements(int index) {
      return entitlements_[index];
    }
    
    public const int PricesFieldNumber = 3;
    private pbc::PopsicleList<global::D3.Store.ProductPrice> prices_ = new pbc::PopsicleList<global::D3.Store.ProductPrice>();
    public scg::IList<global::D3.Store.ProductPrice> PricesList {
      get { return prices_; }
    }
    public int PricesCount {
      get { return prices_.Count; }
    }
    public global::D3.Store.ProductPrice GetPrices(int index) {
      return prices_[index];
    }
    
    public const int CategoryFieldNumber = 4;
    private bool hasCategory;
    private int category_;
    public bool HasCategory {
      get { return hasCategory; }
    }
    public int Category {
      get { return category_; }
    }
    
    public const int AvailableFromFieldNumber = 5;
    private bool hasAvailableFrom;
    private long availableFrom_;
    public bool HasAvailableFrom {
      get { return hasAvailableFrom; }
    }
    public long AvailableFrom {
      get { return availableFrom_; }
    }
    
    public const int FeaturedFieldNumber = 6;
    private bool hasFeatured;
    private uint featured_;
    public bool HasFeatured {
      get { return hasFeatured; }
    }
    public uint Featured {
      get { return featured_; }
    }
    
    public const int DurationSecsFieldNumber = 7;
    private bool hasDurationSecs;
    private ulong durationSecs_;
    public bool HasDurationSecs {
      get { return hasDurationSecs; }
    }
    public ulong DurationSecs {
      get { return durationSecs_; }
    }
    
    public const int MinContentlicensesRequiredFieldNumber = 8;
    private pbc::PopsicleList<global::D3.Store.ContentLicenseRestriction> minContentlicensesRequired_ = new pbc::PopsicleList<global::D3.Store.ContentLicenseRestriction>();
    public scg::IList<global::D3.Store.ContentLicenseRestriction> MinContentlicensesRequiredList {
      get { return minContentlicensesRequired_; }
    }
    public int MinContentlicensesRequiredCount {
      get { return minContentlicensesRequired_.Count; }
    }
    public global::D3.Store.ContentLicenseRestriction GetMinContentlicensesRequired(int index) {
      return minContentlicensesRequired_[index];
    }
    
    public const int MaxContentlicensesAllowedFieldNumber = 9;
    private pbc::PopsicleList<global::D3.Store.ContentLicenseRestriction> maxContentlicensesAllowed_ = new pbc::PopsicleList<global::D3.Store.ContentLicenseRestriction>();
    public scg::IList<global::D3.Store.ContentLicenseRestriction> MaxContentlicensesAllowedList {
      get { return maxContentlicensesAllowed_; }
    }
    public int MaxContentlicensesAllowedCount {
      get { return maxContentlicensesAllowed_.Count; }
    }
    public global::D3.Store.ContentLicenseRestriction GetMaxContentlicensesAllowed(int index) {
      return maxContentlicensesAllowed_[index];
    }
    
    public const int BundleLabelFieldNumber = 10;
    private bool hasBundleLabel;
    private string bundleLabel_ = "";
    public bool HasBundleLabel {
      get { return hasBundleLabel; }
    }
    public string BundleLabel {
      get { return bundleLabel_; }
    }
    
    public const int NotForSaleFieldNumber = 11;
    private bool hasNotForSale;
    private bool notForSale_;
    public bool HasNotForSale {
      get { return hasNotForSale; }
    }
    public bool NotForSale {
      get { return notForSale_; }
    }
    
    public const int ProductIdFieldNumber = 12;
    private bool hasProductId;
    private uint productId_;
    public bool HasProductId {
      get { return hasProductId; }
    }
    public uint ProductId {
      get { return productId_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _productFieldNames;
      if (entitlements_.Count > 0) {
        output.WriteMessageArray(2, field_names[4], entitlements_);
      }
      if (prices_.Count > 0) {
        output.WriteMessageArray(3, field_names[9], prices_);
      }
      if (hasCategory) {
        output.WriteInt32(4, field_names[2], Category);
      }
      if (hasAvailableFrom) {
        output.WriteInt64(5, field_names[0], AvailableFrom);
      }
      if (hasFeatured) {
        output.WriteUInt32(6, field_names[5], Featured);
      }
      if (hasDurationSecs) {
        output.WriteUInt64(7, field_names[3], DurationSecs);
      }
      if (minContentlicensesRequired_.Count > 0) {
        output.WriteMessageArray(8, field_names[7], minContentlicensesRequired_);
      }
      if (maxContentlicensesAllowed_.Count > 0) {
        output.WriteMessageArray(9, field_names[6], maxContentlicensesAllowed_);
      }
      if (hasBundleLabel) {
        output.WriteString(10, field_names[1], BundleLabel);
      }
      if (hasNotForSale) {
        output.WriteBool(11, field_names[8], NotForSale);
      }
      if (hasProductId) {
        output.WriteUInt32(12, field_names[10], ProductId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::D3.Store.ProductEntitlement element in EntitlementsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, element);
        }
        foreach (global::D3.Store.ProductPrice element in PricesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, element);
        }
        if (hasCategory) {
          size += pb::CodedOutputStream.ComputeInt32Size(4, Category);
        }
        if (hasAvailableFrom) {
          size += pb::CodedOutputStream.ComputeInt64Size(5, AvailableFrom);
        }
        if (hasFeatured) {
          size += pb::CodedOutputStream.ComputeUInt32Size(6, Featured);
        }
        if (hasDurationSecs) {
          size += pb::CodedOutputStream.ComputeUInt64Size(7, DurationSecs);
        }
        foreach (global::D3.Store.ContentLicenseRestriction element in MinContentlicensesRequiredList) {
          size += pb::CodedOutputStream.ComputeMessageSize(8, element);
        }
        foreach (global::D3.Store.ContentLicenseRestriction element in MaxContentlicensesAllowedList) {
          size += pb::CodedOutputStream.ComputeMessageSize(9, element);
        }
        if (hasBundleLabel) {
          size += pb::CodedOutputStream.ComputeStringSize(10, BundleLabel);
        }
        if (hasNotForSale) {
          size += pb::CodedOutputStream.ComputeBoolSize(11, NotForSale);
        }
        if (hasProductId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(12, ProductId);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Product ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Product ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Product ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Product ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Product ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Product ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Product ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Product ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Product ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Product ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Product MakeReadOnly() {
      entitlements_.MakeReadOnly();
      prices_.MakeReadOnly();
      minContentlicensesRequired_.MakeReadOnly();
      maxContentlicensesAllowed_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Product prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Product, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Product cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Product result;
      
      private Product PrepareBuilder() {
        if (resultIsReadOnly) {
          Product original = result;
          result = new Product();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Product MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.Product.Descriptor; }
      }
      
      public override Product DefaultInstanceForType {
        get { return global::D3.Store.Product.DefaultInstance; }
      }
      
      public override Product BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Product) {
          return MergeFrom((Product) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Product other) {
        if (other == global::D3.Store.Product.DefaultInstance) return this;
        PrepareBuilder();
        if (other.entitlements_.Count != 0) {
          result.entitlements_.Add(other.entitlements_);
        }
        if (other.prices_.Count != 0) {
          result.prices_.Add(other.prices_);
        }
        if (other.HasCategory) {
          Category = other.Category;
        }
        if (other.HasAvailableFrom) {
          AvailableFrom = other.AvailableFrom;
        }
        if (other.HasFeatured) {
          Featured = other.Featured;
        }
        if (other.HasDurationSecs) {
          DurationSecs = other.DurationSecs;
        }
        if (other.minContentlicensesRequired_.Count != 0) {
          result.minContentlicensesRequired_.Add(other.minContentlicensesRequired_);
        }
        if (other.maxContentlicensesAllowed_.Count != 0) {
          result.maxContentlicensesAllowed_.Add(other.maxContentlicensesAllowed_);
        }
        if (other.HasBundleLabel) {
          BundleLabel = other.BundleLabel;
        }
        if (other.HasNotForSale) {
          NotForSale = other.NotForSale;
        }
        if (other.HasProductId) {
          ProductId = other.ProductId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_productFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _productFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.entitlements_, global::D3.Store.ProductEntitlement.DefaultInstance, extensionRegistry);
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.prices_, global::D3.Store.ProductPrice.DefaultInstance, extensionRegistry);
              break;
            }
            case 32: {
              result.hasCategory = input.ReadInt32(ref result.category_);
              break;
            }
            case 40: {
              result.hasAvailableFrom = input.ReadInt64(ref result.availableFrom_);
              break;
            }
            case 48: {
              result.hasFeatured = input.ReadUInt32(ref result.featured_);
              break;
            }
            case 56: {
              result.hasDurationSecs = input.ReadUInt64(ref result.durationSecs_);
              break;
            }
            case 66: {
              input.ReadMessageArray(tag, field_name, result.minContentlicensesRequired_, global::D3.Store.ContentLicenseRestriction.DefaultInstance, extensionRegistry);
              break;
            }
            case 74: {
              input.ReadMessageArray(tag, field_name, result.maxContentlicensesAllowed_, global::D3.Store.ContentLicenseRestriction.DefaultInstance, extensionRegistry);
              break;
            }
            case 82: {
              result.hasBundleLabel = input.ReadString(ref result.bundleLabel_);
              break;
            }
            case 88: {
              result.hasNotForSale = input.ReadBool(ref result.notForSale_);
              break;
            }
            case 96: {
              result.hasProductId = input.ReadUInt32(ref result.productId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::D3.Store.ProductEntitlement> EntitlementsList {
        get { return PrepareBuilder().entitlements_; }
      }
      public int EntitlementsCount {
        get { return result.EntitlementsCount; }
      }
      public global::D3.Store.ProductEntitlement GetEntitlements(int index) {
        return result.GetEntitlements(index);
      }
      public Builder SetEntitlements(int index, global::D3.Store.ProductEntitlement value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.entitlements_[index] = value;
        return this;
      }
      public Builder SetEntitlements(int index, global::D3.Store.ProductEntitlement.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.entitlements_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddEntitlements(global::D3.Store.ProductEntitlement value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.entitlements_.Add(value);
        return this;
      }
      public Builder AddEntitlements(global::D3.Store.ProductEntitlement.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.entitlements_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeEntitlements(scg::IEnumerable<global::D3.Store.ProductEntitlement> values) {
        PrepareBuilder();
        result.entitlements_.Add(values);
        return this;
      }
      public Builder ClearEntitlements() {
        PrepareBuilder();
        result.entitlements_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Store.ProductPrice> PricesList {
        get { return PrepareBuilder().prices_; }
      }
      public int PricesCount {
        get { return result.PricesCount; }
      }
      public global::D3.Store.ProductPrice GetPrices(int index) {
        return result.GetPrices(index);
      }
      public Builder SetPrices(int index, global::D3.Store.ProductPrice value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.prices_[index] = value;
        return this;
      }
      public Builder SetPrices(int index, global::D3.Store.ProductPrice.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.prices_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddPrices(global::D3.Store.ProductPrice value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.prices_.Add(value);
        return this;
      }
      public Builder AddPrices(global::D3.Store.ProductPrice.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.prices_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangePrices(scg::IEnumerable<global::D3.Store.ProductPrice> values) {
        PrepareBuilder();
        result.prices_.Add(values);
        return this;
      }
      public Builder ClearPrices() {
        PrepareBuilder();
        result.prices_.Clear();
        return this;
      }
      
      public bool HasCategory {
        get { return result.hasCategory; }
      }
      public int Category {
        get { return result.Category; }
        set { SetCategory(value); }
      }
      public Builder SetCategory(int value) {
        PrepareBuilder();
        result.hasCategory = true;
        result.category_ = value;
        return this;
      }
      public Builder ClearCategory() {
        PrepareBuilder();
        result.hasCategory = false;
        result.category_ = 0;
        return this;
      }
      
      public bool HasAvailableFrom {
        get { return result.hasAvailableFrom; }
      }
      public long AvailableFrom {
        get { return result.AvailableFrom; }
        set { SetAvailableFrom(value); }
      }
      public Builder SetAvailableFrom(long value) {
        PrepareBuilder();
        result.hasAvailableFrom = true;
        result.availableFrom_ = value;
        return this;
      }
      public Builder ClearAvailableFrom() {
        PrepareBuilder();
        result.hasAvailableFrom = false;
        result.availableFrom_ = 0L;
        return this;
      }
      
      public bool HasFeatured {
        get { return result.hasFeatured; }
      }
      public uint Featured {
        get { return result.Featured; }
        set { SetFeatured(value); }
      }
      public Builder SetFeatured(uint value) {
        PrepareBuilder();
        result.hasFeatured = true;
        result.featured_ = value;
        return this;
      }
      public Builder ClearFeatured() {
        PrepareBuilder();
        result.hasFeatured = false;
        result.featured_ = 0;
        return this;
      }
      
      public bool HasDurationSecs {
        get { return result.hasDurationSecs; }
      }
      public ulong DurationSecs {
        get { return result.DurationSecs; }
        set { SetDurationSecs(value); }
      }
      public Builder SetDurationSecs(ulong value) {
        PrepareBuilder();
        result.hasDurationSecs = true;
        result.durationSecs_ = value;
        return this;
      }
      public Builder ClearDurationSecs() {
        PrepareBuilder();
        result.hasDurationSecs = false;
        result.durationSecs_ = 0UL;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Store.ContentLicenseRestriction> MinContentlicensesRequiredList {
        get { return PrepareBuilder().minContentlicensesRequired_; }
      }
      public int MinContentlicensesRequiredCount {
        get { return result.MinContentlicensesRequiredCount; }
      }
      public global::D3.Store.ContentLicenseRestriction GetMinContentlicensesRequired(int index) {
        return result.GetMinContentlicensesRequired(index);
      }
      public Builder SetMinContentlicensesRequired(int index, global::D3.Store.ContentLicenseRestriction value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.minContentlicensesRequired_[index] = value;
        return this;
      }
      public Builder SetMinContentlicensesRequired(int index, global::D3.Store.ContentLicenseRestriction.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.minContentlicensesRequired_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddMinContentlicensesRequired(global::D3.Store.ContentLicenseRestriction value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.minContentlicensesRequired_.Add(value);
        return this;
      }
      public Builder AddMinContentlicensesRequired(global::D3.Store.ContentLicenseRestriction.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.minContentlicensesRequired_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeMinContentlicensesRequired(scg::IEnumerable<global::D3.Store.ContentLicenseRestriction> values) {
        PrepareBuilder();
        result.minContentlicensesRequired_.Add(values);
        return this;
      }
      public Builder ClearMinContentlicensesRequired() {
        PrepareBuilder();
        result.minContentlicensesRequired_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Store.ContentLicenseRestriction> MaxContentlicensesAllowedList {
        get { return PrepareBuilder().maxContentlicensesAllowed_; }
      }
      public int MaxContentlicensesAllowedCount {
        get { return result.MaxContentlicensesAllowedCount; }
      }
      public global::D3.Store.ContentLicenseRestriction GetMaxContentlicensesAllowed(int index) {
        return result.GetMaxContentlicensesAllowed(index);
      }
      public Builder SetMaxContentlicensesAllowed(int index, global::D3.Store.ContentLicenseRestriction value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.maxContentlicensesAllowed_[index] = value;
        return this;
      }
      public Builder SetMaxContentlicensesAllowed(int index, global::D3.Store.ContentLicenseRestriction.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.maxContentlicensesAllowed_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddMaxContentlicensesAllowed(global::D3.Store.ContentLicenseRestriction value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.maxContentlicensesAllowed_.Add(value);
        return this;
      }
      public Builder AddMaxContentlicensesAllowed(global::D3.Store.ContentLicenseRestriction.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.maxContentlicensesAllowed_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeMaxContentlicensesAllowed(scg::IEnumerable<global::D3.Store.ContentLicenseRestriction> values) {
        PrepareBuilder();
        result.maxContentlicensesAllowed_.Add(values);
        return this;
      }
      public Builder ClearMaxContentlicensesAllowed() {
        PrepareBuilder();
        result.maxContentlicensesAllowed_.Clear();
        return this;
      }
      
      public bool HasBundleLabel {
        get { return result.hasBundleLabel; }
      }
      public string BundleLabel {
        get { return result.BundleLabel; }
        set { SetBundleLabel(value); }
      }
      public Builder SetBundleLabel(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBundleLabel = true;
        result.bundleLabel_ = value;
        return this;
      }
      public Builder ClearBundleLabel() {
        PrepareBuilder();
        result.hasBundleLabel = false;
        result.bundleLabel_ = "";
        return this;
      }
      
      public bool HasNotForSale {
        get { return result.hasNotForSale; }
      }
      public bool NotForSale {
        get { return result.NotForSale; }
        set { SetNotForSale(value); }
      }
      public Builder SetNotForSale(bool value) {
        PrepareBuilder();
        result.hasNotForSale = true;
        result.notForSale_ = value;
        return this;
      }
      public Builder ClearNotForSale() {
        PrepareBuilder();
        result.hasNotForSale = false;
        result.notForSale_ = false;
        return this;
      }
      
      public bool HasProductId {
        get { return result.hasProductId; }
      }
      public uint ProductId {
        get { return result.ProductId; }
        set { SetProductId(value); }
      }
      public Builder SetProductId(uint value) {
        PrepareBuilder();
        result.hasProductId = true;
        result.productId_ = value;
        return this;
      }
      public Builder ClearProductId() {
        PrepareBuilder();
        result.hasProductId = false;
        result.productId_ = 0;
        return this;
      }
    }
    static Product() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ProductCategory : pb::GeneratedMessage<ProductCategory, ProductCategory.Builder> {
    private ProductCategory() { }
    private static readonly ProductCategory defaultInstance = new ProductCategory().MakeReadOnly();
    private static readonly string[] _productCategoryFieldNames = new string[] { "category", "newest_product_time" };
    private static readonly uint[] _productCategoryFieldTags = new uint[] { 8, 16 };
    public static ProductCategory DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ProductCategory DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ProductCategory ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_ProductCategory__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ProductCategory, ProductCategory.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_ProductCategory__FieldAccessorTable; }
    }
    
    public const int CategoryFieldNumber = 1;
    private bool hasCategory;
    private int category_;
    public bool HasCategory {
      get { return hasCategory; }
    }
    public int Category {
      get { return category_; }
    }
    
    public const int NewestProductTimeFieldNumber = 2;
    private bool hasNewestProductTime;
    private long newestProductTime_;
    public bool HasNewestProductTime {
      get { return hasNewestProductTime; }
    }
    public long NewestProductTime {
      get { return newestProductTime_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _productCategoryFieldNames;
      if (hasCategory) {
        output.WriteInt32(1, field_names[0], Category);
      }
      if (hasNewestProductTime) {
        output.WriteInt64(2, field_names[1], NewestProductTime);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCategory) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, Category);
        }
        if (hasNewestProductTime) {
          size += pb::CodedOutputStream.ComputeInt64Size(2, NewestProductTime);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ProductCategory ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ProductCategory ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ProductCategory ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ProductCategory ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ProductCategory ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ProductCategory ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ProductCategory ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ProductCategory ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ProductCategory ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ProductCategory ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ProductCategory MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ProductCategory prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ProductCategory, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ProductCategory cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ProductCategory result;
      
      private ProductCategory PrepareBuilder() {
        if (resultIsReadOnly) {
          ProductCategory original = result;
          result = new ProductCategory();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ProductCategory MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.ProductCategory.Descriptor; }
      }
      
      public override ProductCategory DefaultInstanceForType {
        get { return global::D3.Store.ProductCategory.DefaultInstance; }
      }
      
      public override ProductCategory BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ProductCategory) {
          return MergeFrom((ProductCategory) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ProductCategory other) {
        if (other == global::D3.Store.ProductCategory.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCategory) {
          Category = other.Category;
        }
        if (other.HasNewestProductTime) {
          NewestProductTime = other.NewestProductTime;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_productCategoryFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _productCategoryFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasCategory = input.ReadInt32(ref result.category_);
              break;
            }
            case 16: {
              result.hasNewestProductTime = input.ReadInt64(ref result.newestProductTime_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCategory {
        get { return result.hasCategory; }
      }
      public int Category {
        get { return result.Category; }
        set { SetCategory(value); }
      }
      public Builder SetCategory(int value) {
        PrepareBuilder();
        result.hasCategory = true;
        result.category_ = value;
        return this;
      }
      public Builder ClearCategory() {
        PrepareBuilder();
        result.hasCategory = false;
        result.category_ = 0;
        return this;
      }
      
      public bool HasNewestProductTime {
        get { return result.hasNewestProductTime; }
      }
      public long NewestProductTime {
        get { return result.NewestProductTime; }
        set { SetNewestProductTime(value); }
      }
      public Builder SetNewestProductTime(long value) {
        PrepareBuilder();
        result.hasNewestProductTime = true;
        result.newestProductTime_ = value;
        return this;
      }
      public Builder ClearNewestProductTime() {
        PrepareBuilder();
        result.hasNewestProductTime = false;
        result.newestProductTime_ = 0L;
        return this;
      }
    }
    static ProductCategory() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Risk : pb::GeneratedMessage<Risk, Risk.Builder> {
    private Risk() { }
    private static readonly Risk defaultInstance = new Risk().MakeReadOnly();
    private static readonly string[] _riskFieldNames = new string[] { "challenge_id", "challenge_url", "risk_type", "transaction_id" };
    private static readonly uint[] _riskFieldTags = new uint[] { 26, 34, 8, 18 };
    public static Risk DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Risk DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Risk ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_Risk__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Risk, Risk.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_Risk__FieldAccessorTable; }
    }
    
    public const int RiskTypeFieldNumber = 1;
    private bool hasRiskType;
    private int riskType_;
    public bool HasRiskType {
      get { return hasRiskType; }
    }
    public int RiskType {
      get { return riskType_; }
    }
    
    public const int TransactionIdFieldNumber = 2;
    private bool hasTransactionId;
    private string transactionId_ = "";
    public bool HasTransactionId {
      get { return hasTransactionId; }
    }
    public string TransactionId {
      get { return transactionId_; }
    }
    
    public const int ChallengeIdFieldNumber = 3;
    private bool hasChallengeId;
    private string challengeId_ = "";
    public bool HasChallengeId {
      get { return hasChallengeId; }
    }
    public string ChallengeId {
      get { return challengeId_; }
    }
    
    public const int ChallengeUrlFieldNumber = 4;
    private bool hasChallengeUrl;
    private string challengeUrl_ = "";
    public bool HasChallengeUrl {
      get { return hasChallengeUrl; }
    }
    public string ChallengeUrl {
      get { return challengeUrl_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _riskFieldNames;
      if (hasRiskType) {
        output.WriteInt32(1, field_names[2], RiskType);
      }
      if (hasTransactionId) {
        output.WriteString(2, field_names[3], TransactionId);
      }
      if (hasChallengeId) {
        output.WriteString(3, field_names[0], ChallengeId);
      }
      if (hasChallengeUrl) {
        output.WriteString(4, field_names[1], ChallengeUrl);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasRiskType) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, RiskType);
        }
        if (hasTransactionId) {
          size += pb::CodedOutputStream.ComputeStringSize(2, TransactionId);
        }
        if (hasChallengeId) {
          size += pb::CodedOutputStream.ComputeStringSize(3, ChallengeId);
        }
        if (hasChallengeUrl) {
          size += pb::CodedOutputStream.ComputeStringSize(4, ChallengeUrl);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Risk ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Risk ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Risk ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Risk ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Risk ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Risk ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Risk ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Risk ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Risk ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Risk ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Risk MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Risk prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Risk, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Risk cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Risk result;
      
      private Risk PrepareBuilder() {
        if (resultIsReadOnly) {
          Risk original = result;
          result = new Risk();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Risk MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.Risk.Descriptor; }
      }
      
      public override Risk DefaultInstanceForType {
        get { return global::D3.Store.Risk.DefaultInstance; }
      }
      
      public override Risk BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Risk) {
          return MergeFrom((Risk) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Risk other) {
        if (other == global::D3.Store.Risk.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRiskType) {
          RiskType = other.RiskType;
        }
        if (other.HasTransactionId) {
          TransactionId = other.TransactionId;
        }
        if (other.HasChallengeId) {
          ChallengeId = other.ChallengeId;
        }
        if (other.HasChallengeUrl) {
          ChallengeUrl = other.ChallengeUrl;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_riskFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _riskFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasRiskType = input.ReadInt32(ref result.riskType_);
              break;
            }
            case 18: {
              result.hasTransactionId = input.ReadString(ref result.transactionId_);
              break;
            }
            case 26: {
              result.hasChallengeId = input.ReadString(ref result.challengeId_);
              break;
            }
            case 34: {
              result.hasChallengeUrl = input.ReadString(ref result.challengeUrl_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasRiskType {
        get { return result.hasRiskType; }
      }
      public int RiskType {
        get { return result.RiskType; }
        set { SetRiskType(value); }
      }
      public Builder SetRiskType(int value) {
        PrepareBuilder();
        result.hasRiskType = true;
        result.riskType_ = value;
        return this;
      }
      public Builder ClearRiskType() {
        PrepareBuilder();
        result.hasRiskType = false;
        result.riskType_ = 0;
        return this;
      }
      
      public bool HasTransactionId {
        get { return result.hasTransactionId; }
      }
      public string TransactionId {
        get { return result.TransactionId; }
        set { SetTransactionId(value); }
      }
      public Builder SetTransactionId(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTransactionId = true;
        result.transactionId_ = value;
        return this;
      }
      public Builder ClearTransactionId() {
        PrepareBuilder();
        result.hasTransactionId = false;
        result.transactionId_ = "";
        return this;
      }
      
      public bool HasChallengeId {
        get { return result.hasChallengeId; }
      }
      public string ChallengeId {
        get { return result.ChallengeId; }
        set { SetChallengeId(value); }
      }
      public Builder SetChallengeId(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasChallengeId = true;
        result.challengeId_ = value;
        return this;
      }
      public Builder ClearChallengeId() {
        PrepareBuilder();
        result.hasChallengeId = false;
        result.challengeId_ = "";
        return this;
      }
      
      public bool HasChallengeUrl {
        get { return result.hasChallengeUrl; }
      }
      public string ChallengeUrl {
        get { return result.ChallengeUrl; }
        set { SetChallengeUrl(value); }
      }
      public Builder SetChallengeUrl(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasChallengeUrl = true;
        result.challengeUrl_ = value;
        return this;
      }
      public Builder ClearChallengeUrl() {
        PrepareBuilder();
        result.hasChallengeUrl = false;
        result.challengeUrl_ = "";
        return this;
      }
    }
    static Risk() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Wallet : pb::GeneratedMessage<Wallet, Wallet.Builder> {
    private Wallet() { }
    private static readonly Wallet defaultInstance = new Wallet().MakeReadOnly();
    private static readonly string[] _walletFieldNames = new string[] { "fixed_point_balance", "primary", "risk", "wallet_expiration_date", "wallet_id", "wallet_name", "wallet_type" };
    private static readonly uint[] _walletFieldTags = new uint[] { 72, 32, 58, 50, 8, 18, 40 };
    public static Wallet DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Wallet DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Wallet ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_Wallet__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Wallet, Wallet.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_Wallet__FieldAccessorTable; }
    }
    
    public const int WalletIdFieldNumber = 1;
    private bool hasWalletId;
    private long walletId_;
    public bool HasWalletId {
      get { return hasWalletId; }
    }
    public long WalletId {
      get { return walletId_; }
    }
    
    public const int WalletNameFieldNumber = 2;
    private bool hasWalletName;
    private string walletName_ = "";
    public bool HasWalletName {
      get { return hasWalletName; }
    }
    public string WalletName {
      get { return walletName_; }
    }
    
    public const int PrimaryFieldNumber = 4;
    private bool hasPrimary;
    private bool primary_;
    public bool HasPrimary {
      get { return hasPrimary; }
    }
    public bool Primary {
      get { return primary_; }
    }
    
    public const int WalletTypeFieldNumber = 5;
    private bool hasWalletType;
    private int walletType_;
    public bool HasWalletType {
      get { return hasWalletType; }
    }
    public int WalletType {
      get { return walletType_; }
    }
    
    public const int WalletExpirationDateFieldNumber = 6;
    private bool hasWalletExpirationDate;
    private string walletExpirationDate_ = "";
    public bool HasWalletExpirationDate {
      get { return hasWalletExpirationDate; }
    }
    public string WalletExpirationDate {
      get { return walletExpirationDate_; }
    }
    
    public const int RiskFieldNumber = 7;
    private bool hasRisk;
    private global::D3.Store.Risk risk_;
    public bool HasRisk {
      get { return hasRisk; }
    }
    public global::D3.Store.Risk Risk {
      get { return risk_ ?? global::D3.Store.Risk.DefaultInstance; }
    }
    
    public const int FixedPointBalanceFieldNumber = 9;
    private bool hasFixedPointBalance;
    private long fixedPointBalance_;
    public bool HasFixedPointBalance {
      get { return hasFixedPointBalance; }
    }
    public long FixedPointBalance {
      get { return fixedPointBalance_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _walletFieldNames;
      if (hasWalletId) {
        output.WriteSInt64(1, field_names[4], WalletId);
      }
      if (hasWalletName) {
        output.WriteString(2, field_names[5], WalletName);
      }
      if (hasPrimary) {
        output.WriteBool(4, field_names[1], Primary);
      }
      if (hasWalletType) {
        output.WriteInt32(5, field_names[6], WalletType);
      }
      if (hasWalletExpirationDate) {
        output.WriteString(6, field_names[3], WalletExpirationDate);
      }
      if (hasRisk) {
        output.WriteMessage(7, field_names[2], Risk);
      }
      if (hasFixedPointBalance) {
        output.WriteInt64(9, field_names[0], FixedPointBalance);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasWalletId) {
          size += pb::CodedOutputStream.ComputeSInt64Size(1, WalletId);
        }
        if (hasWalletName) {
          size += pb::CodedOutputStream.ComputeStringSize(2, WalletName);
        }
        if (hasPrimary) {
          size += pb::CodedOutputStream.ComputeBoolSize(4, Primary);
        }
        if (hasWalletType) {
          size += pb::CodedOutputStream.ComputeInt32Size(5, WalletType);
        }
        if (hasWalletExpirationDate) {
          size += pb::CodedOutputStream.ComputeStringSize(6, WalletExpirationDate);
        }
        if (hasRisk) {
          size += pb::CodedOutputStream.ComputeMessageSize(7, Risk);
        }
        if (hasFixedPointBalance) {
          size += pb::CodedOutputStream.ComputeInt64Size(9, FixedPointBalance);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Wallet ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Wallet ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Wallet ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Wallet ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Wallet ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Wallet ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Wallet ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Wallet ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Wallet ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Wallet ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Wallet MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Wallet prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Wallet, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Wallet cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Wallet result;
      
      private Wallet PrepareBuilder() {
        if (resultIsReadOnly) {
          Wallet original = result;
          result = new Wallet();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Wallet MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.Wallet.Descriptor; }
      }
      
      public override Wallet DefaultInstanceForType {
        get { return global::D3.Store.Wallet.DefaultInstance; }
      }
      
      public override Wallet BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Wallet) {
          return MergeFrom((Wallet) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Wallet other) {
        if (other == global::D3.Store.Wallet.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasWalletId) {
          WalletId = other.WalletId;
        }
        if (other.HasWalletName) {
          WalletName = other.WalletName;
        }
        if (other.HasPrimary) {
          Primary = other.Primary;
        }
        if (other.HasWalletType) {
          WalletType = other.WalletType;
        }
        if (other.HasWalletExpirationDate) {
          WalletExpirationDate = other.WalletExpirationDate;
        }
        if (other.HasRisk) {
          MergeRisk(other.Risk);
        }
        if (other.HasFixedPointBalance) {
          FixedPointBalance = other.FixedPointBalance;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_walletFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _walletFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasWalletId = input.ReadSInt64(ref result.walletId_);
              break;
            }
            case 18: {
              result.hasWalletName = input.ReadString(ref result.walletName_);
              break;
            }
            case 32: {
              result.hasPrimary = input.ReadBool(ref result.primary_);
              break;
            }
            case 40: {
              result.hasWalletType = input.ReadInt32(ref result.walletType_);
              break;
            }
            case 50: {
              result.hasWalletExpirationDate = input.ReadString(ref result.walletExpirationDate_);
              break;
            }
            case 58: {
              global::D3.Store.Risk.Builder subBuilder = global::D3.Store.Risk.CreateBuilder();
              if (result.hasRisk) {
                subBuilder.MergeFrom(Risk);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Risk = subBuilder.BuildPartial();
              break;
            }
            case 72: {
              result.hasFixedPointBalance = input.ReadInt64(ref result.fixedPointBalance_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasWalletId {
        get { return result.hasWalletId; }
      }
      public long WalletId {
        get { return result.WalletId; }
        set { SetWalletId(value); }
      }
      public Builder SetWalletId(long value) {
        PrepareBuilder();
        result.hasWalletId = true;
        result.walletId_ = value;
        return this;
      }
      public Builder ClearWalletId() {
        PrepareBuilder();
        result.hasWalletId = false;
        result.walletId_ = 0;
        return this;
      }
      
      public bool HasWalletName {
        get { return result.hasWalletName; }
      }
      public string WalletName {
        get { return result.WalletName; }
        set { SetWalletName(value); }
      }
      public Builder SetWalletName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasWalletName = true;
        result.walletName_ = value;
        return this;
      }
      public Builder ClearWalletName() {
        PrepareBuilder();
        result.hasWalletName = false;
        result.walletName_ = "";
        return this;
      }
      
      public bool HasPrimary {
        get { return result.hasPrimary; }
      }
      public bool Primary {
        get { return result.Primary; }
        set { SetPrimary(value); }
      }
      public Builder SetPrimary(bool value) {
        PrepareBuilder();
        result.hasPrimary = true;
        result.primary_ = value;
        return this;
      }
      public Builder ClearPrimary() {
        PrepareBuilder();
        result.hasPrimary = false;
        result.primary_ = false;
        return this;
      }
      
      public bool HasWalletType {
        get { return result.hasWalletType; }
      }
      public int WalletType {
        get { return result.WalletType; }
        set { SetWalletType(value); }
      }
      public Builder SetWalletType(int value) {
        PrepareBuilder();
        result.hasWalletType = true;
        result.walletType_ = value;
        return this;
      }
      public Builder ClearWalletType() {
        PrepareBuilder();
        result.hasWalletType = false;
        result.walletType_ = 0;
        return this;
      }
      
      public bool HasWalletExpirationDate {
        get { return result.hasWalletExpirationDate; }
      }
      public string WalletExpirationDate {
        get { return result.WalletExpirationDate; }
        set { SetWalletExpirationDate(value); }
      }
      public Builder SetWalletExpirationDate(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasWalletExpirationDate = true;
        result.walletExpirationDate_ = value;
        return this;
      }
      public Builder ClearWalletExpirationDate() {
        PrepareBuilder();
        result.hasWalletExpirationDate = false;
        result.walletExpirationDate_ = "";
        return this;
      }
      
      public bool HasRisk {
       get { return result.hasRisk; }
      }
      public global::D3.Store.Risk Risk {
        get { return result.Risk; }
        set { SetRisk(value); }
      }
      public Builder SetRisk(global::D3.Store.Risk value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRisk = true;
        result.risk_ = value;
        return this;
      }
      public Builder SetRisk(global::D3.Store.Risk.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRisk = true;
        result.risk_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRisk(global::D3.Store.Risk value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRisk &&
            result.risk_ != global::D3.Store.Risk.DefaultInstance) {
            result.risk_ = global::D3.Store.Risk.CreateBuilder(result.risk_).MergeFrom(value).BuildPartial();
        } else {
          result.risk_ = value;
        }
        result.hasRisk = true;
        return this;
      }
      public Builder ClearRisk() {
        PrepareBuilder();
        result.hasRisk = false;
        result.risk_ = null;
        return this;
      }
      
      public bool HasFixedPointBalance {
        get { return result.hasFixedPointBalance; }
      }
      public long FixedPointBalance {
        get { return result.FixedPointBalance; }
        set { SetFixedPointBalance(value); }
      }
      public Builder SetFixedPointBalance(long value) {
        PrepareBuilder();
        result.hasFixedPointBalance = true;
        result.fixedPointBalance_ = value;
        return this;
      }
      public Builder ClearFixedPointBalance() {
        PrepareBuilder();
        result.hasFixedPointBalance = false;
        result.fixedPointBalance_ = 0L;
        return this;
      }
    }
    static Wallet() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Order : pb::GeneratedMessage<Order, Order.Builder> {
    private Order() { }
    private static readonly Order defaultInstance = new Order().MakeReadOnly();
    private static readonly string[] _orderFieldNames = new string[] { "acknowledged", "error_code", "status", "transaction_id" };
    private static readonly uint[] _orderFieldTags = new uint[] { 32, 24, 8, 16 };
    public static Order DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Order DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Order ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_Order__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Order, Order.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_Order__FieldAccessorTable; }
    }
    
    public const int StatusFieldNumber = 1;
    private bool hasStatus;
    private uint status_;
    public bool HasStatus {
      get { return hasStatus; }
    }
    public uint Status {
      get { return status_; }
    }
    
    public const int TransactionIdFieldNumber = 2;
    private bool hasTransactionId;
    private ulong transactionId_;
    public bool HasTransactionId {
      get { return hasTransactionId; }
    }
    public ulong TransactionId {
      get { return transactionId_; }
    }
    
    public const int ErrorCodeFieldNumber = 3;
    private bool hasErrorCode;
    private uint errorCode_;
    public bool HasErrorCode {
      get { return hasErrorCode; }
    }
    public uint ErrorCode {
      get { return errorCode_; }
    }
    
    public const int AcknowledgedFieldNumber = 4;
    private bool hasAcknowledged;
    private bool acknowledged_;
    public bool HasAcknowledged {
      get { return hasAcknowledged; }
    }
    public bool Acknowledged {
      get { return acknowledged_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _orderFieldNames;
      if (hasStatus) {
        output.WriteUInt32(1, field_names[2], Status);
      }
      if (hasTransactionId) {
        output.WriteUInt64(2, field_names[3], TransactionId);
      }
      if (hasErrorCode) {
        output.WriteUInt32(3, field_names[1], ErrorCode);
      }
      if (hasAcknowledged) {
        output.WriteBool(4, field_names[0], Acknowledged);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasStatus) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, Status);
        }
        if (hasTransactionId) {
          size += pb::CodedOutputStream.ComputeUInt64Size(2, TransactionId);
        }
        if (hasErrorCode) {
          size += pb::CodedOutputStream.ComputeUInt32Size(3, ErrorCode);
        }
        if (hasAcknowledged) {
          size += pb::CodedOutputStream.ComputeBoolSize(4, Acknowledged);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Order ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Order ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Order ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Order ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Order ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Order ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Order ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Order ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Order ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Order ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Order MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Order prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Order, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Order cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Order result;
      
      private Order PrepareBuilder() {
        if (resultIsReadOnly) {
          Order original = result;
          result = new Order();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Order MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.Order.Descriptor; }
      }
      
      public override Order DefaultInstanceForType {
        get { return global::D3.Store.Order.DefaultInstance; }
      }
      
      public override Order BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Order) {
          return MergeFrom((Order) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Order other) {
        if (other == global::D3.Store.Order.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasStatus) {
          Status = other.Status;
        }
        if (other.HasTransactionId) {
          TransactionId = other.TransactionId;
        }
        if (other.HasErrorCode) {
          ErrorCode = other.ErrorCode;
        }
        if (other.HasAcknowledged) {
          Acknowledged = other.Acknowledged;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_orderFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _orderFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasStatus = input.ReadUInt32(ref result.status_);
              break;
            }
            case 16: {
              result.hasTransactionId = input.ReadUInt64(ref result.transactionId_);
              break;
            }
            case 24: {
              result.hasErrorCode = input.ReadUInt32(ref result.errorCode_);
              break;
            }
            case 32: {
              result.hasAcknowledged = input.ReadBool(ref result.acknowledged_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasStatus {
        get { return result.hasStatus; }
      }
      public uint Status {
        get { return result.Status; }
        set { SetStatus(value); }
      }
      public Builder SetStatus(uint value) {
        PrepareBuilder();
        result.hasStatus = true;
        result.status_ = value;
        return this;
      }
      public Builder ClearStatus() {
        PrepareBuilder();
        result.hasStatus = false;
        result.status_ = 0;
        return this;
      }
      
      public bool HasTransactionId {
        get { return result.hasTransactionId; }
      }
      public ulong TransactionId {
        get { return result.TransactionId; }
        set { SetTransactionId(value); }
      }
      public Builder SetTransactionId(ulong value) {
        PrepareBuilder();
        result.hasTransactionId = true;
        result.transactionId_ = value;
        return this;
      }
      public Builder ClearTransactionId() {
        PrepareBuilder();
        result.hasTransactionId = false;
        result.transactionId_ = 0UL;
        return this;
      }
      
      public bool HasErrorCode {
        get { return result.hasErrorCode; }
      }
      public uint ErrorCode {
        get { return result.ErrorCode; }
        set { SetErrorCode(value); }
      }
      public Builder SetErrorCode(uint value) {
        PrepareBuilder();
        result.hasErrorCode = true;
        result.errorCode_ = value;
        return this;
      }
      public Builder ClearErrorCode() {
        PrepareBuilder();
        result.hasErrorCode = false;
        result.errorCode_ = 0;
        return this;
      }
      
      public bool HasAcknowledged {
        get { return result.hasAcknowledged; }
      }
      public bool Acknowledged {
        get { return result.Acknowledged; }
        set { SetAcknowledged(value); }
      }
      public Builder SetAcknowledged(bool value) {
        PrepareBuilder();
        result.hasAcknowledged = true;
        result.acknowledged_ = value;
        return this;
      }
      public Builder ClearAcknowledged() {
        PrepareBuilder();
        result.hasAcknowledged = false;
        result.acknowledged_ = false;
        return this;
      }
    }
    static Order() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetProductList : pb::GeneratedMessage<GetProductList, GetProductList.Builder> {
    private GetProductList() { }
    private static readonly GetProductList defaultInstance = new GetProductList().MakeReadOnly();
    private static readonly string[] _getProductListFieldNames = new string[] { "catalog_version", "category" };
    private static readonly uint[] _getProductListFieldTags = new uint[] { 16, 8 };
    public static GetProductList DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetProductList DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetProductList ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetProductList__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetProductList, GetProductList.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetProductList__FieldAccessorTable; }
    }
    
    public const int CategoryFieldNumber = 1;
    private bool hasCategory;
    private int category_;
    public bool HasCategory {
      get { return hasCategory; }
    }
    public int Category {
      get { return category_; }
    }
    
    public const int CatalogVersionFieldNumber = 2;
    private bool hasCatalogVersion;
    private ulong catalogVersion_;
    public bool HasCatalogVersion {
      get { return hasCatalogVersion; }
    }
    public ulong CatalogVersion {
      get { return catalogVersion_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getProductListFieldNames;
      if (hasCategory) {
        output.WriteInt32(1, field_names[1], Category);
      }
      if (hasCatalogVersion) {
        output.WriteUInt64(2, field_names[0], CatalogVersion);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCategory) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, Category);
        }
        if (hasCatalogVersion) {
          size += pb::CodedOutputStream.ComputeUInt64Size(2, CatalogVersion);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetProductList ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetProductList ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetProductList ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetProductList ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetProductList ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetProductList ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetProductList ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetProductList ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetProductList ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetProductList ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetProductList MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetProductList prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetProductList, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetProductList cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetProductList result;
      
      private GetProductList PrepareBuilder() {
        if (resultIsReadOnly) {
          GetProductList original = result;
          result = new GetProductList();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetProductList MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetProductList.Descriptor; }
      }
      
      public override GetProductList DefaultInstanceForType {
        get { return global::D3.Store.GetProductList.DefaultInstance; }
      }
      
      public override GetProductList BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetProductList) {
          return MergeFrom((GetProductList) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetProductList other) {
        if (other == global::D3.Store.GetProductList.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCategory) {
          Category = other.Category;
        }
        if (other.HasCatalogVersion) {
          CatalogVersion = other.CatalogVersion;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getProductListFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getProductListFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasCategory = input.ReadInt32(ref result.category_);
              break;
            }
            case 16: {
              result.hasCatalogVersion = input.ReadUInt64(ref result.catalogVersion_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCategory {
        get { return result.hasCategory; }
      }
      public int Category {
        get { return result.Category; }
        set { SetCategory(value); }
      }
      public Builder SetCategory(int value) {
        PrepareBuilder();
        result.hasCategory = true;
        result.category_ = value;
        return this;
      }
      public Builder ClearCategory() {
        PrepareBuilder();
        result.hasCategory = false;
        result.category_ = 0;
        return this;
      }
      
      public bool HasCatalogVersion {
        get { return result.hasCatalogVersion; }
      }
      public ulong CatalogVersion {
        get { return result.CatalogVersion; }
        set { SetCatalogVersion(value); }
      }
      public Builder SetCatalogVersion(ulong value) {
        PrepareBuilder();
        result.hasCatalogVersion = true;
        result.catalogVersion_ = value;
        return this;
      }
      public Builder ClearCatalogVersion() {
        PrepareBuilder();
        result.hasCatalogVersion = false;
        result.catalogVersion_ = 0UL;
        return this;
      }
    }
    static GetProductList() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetProductListResponse : pb::GeneratedMessage<GetProductListResponse, GetProductListResponse.Builder> {
    private GetProductListResponse() { }
    private static readonly GetProductListResponse defaultInstance = new GetProductListResponse().MakeReadOnly();
    private static readonly string[] _getProductListResponseFieldNames = new string[] { "currencies", "products", "valid_for_secs" };
    private static readonly uint[] _getProductListResponseFieldTags = new uint[] { 26, 10, 16 };
    public static GetProductListResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetProductListResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetProductListResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetProductListResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetProductListResponse, GetProductListResponse.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetProductListResponse__FieldAccessorTable; }
    }
    
    public const int ProductsFieldNumber = 1;
    private pbc::PopsicleList<global::D3.Store.Product> products_ = new pbc::PopsicleList<global::D3.Store.Product>();
    public scg::IList<global::D3.Store.Product> ProductsList {
      get { return products_; }
    }
    public int ProductsCount {
      get { return products_.Count; }
    }
    public global::D3.Store.Product GetProducts(int index) {
      return products_[index];
    }
    
    public const int ValidForSecsFieldNumber = 2;
    private bool hasValidForSecs;
    private uint validForSecs_;
    public bool HasValidForSecs {
      get { return hasValidForSecs; }
    }
    public uint ValidForSecs {
      get { return validForSecs_; }
    }
    
    public const int CurrenciesFieldNumber = 3;
    private pbc::PopsicleList<global::D3.Store.Currency> currencies_ = new pbc::PopsicleList<global::D3.Store.Currency>();
    public scg::IList<global::D3.Store.Currency> CurrenciesList {
      get { return currencies_; }
    }
    public int CurrenciesCount {
      get { return currencies_.Count; }
    }
    public global::D3.Store.Currency GetCurrencies(int index) {
      return currencies_[index];
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getProductListResponseFieldNames;
      if (products_.Count > 0) {
        output.WriteMessageArray(1, field_names[1], products_);
      }
      if (hasValidForSecs) {
        output.WriteUInt32(2, field_names[2], ValidForSecs);
      }
      if (currencies_.Count > 0) {
        output.WriteMessageArray(3, field_names[0], currencies_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::D3.Store.Product element in ProductsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        if (hasValidForSecs) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, ValidForSecs);
        }
        foreach (global::D3.Store.Currency element in CurrenciesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetProductListResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetProductListResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetProductListResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetProductListResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetProductListResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetProductListResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetProductListResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetProductListResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetProductListResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetProductListResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetProductListResponse MakeReadOnly() {
      products_.MakeReadOnly();
      currencies_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetProductListResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetProductListResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetProductListResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetProductListResponse result;
      
      private GetProductListResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          GetProductListResponse original = result;
          result = new GetProductListResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetProductListResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetProductListResponse.Descriptor; }
      }
      
      public override GetProductListResponse DefaultInstanceForType {
        get { return global::D3.Store.GetProductListResponse.DefaultInstance; }
      }
      
      public override GetProductListResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetProductListResponse) {
          return MergeFrom((GetProductListResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetProductListResponse other) {
        if (other == global::D3.Store.GetProductListResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.products_.Count != 0) {
          result.products_.Add(other.products_);
        }
        if (other.HasValidForSecs) {
          ValidForSecs = other.ValidForSecs;
        }
        if (other.currencies_.Count != 0) {
          result.currencies_.Add(other.currencies_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getProductListResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getProductListResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.products_, global::D3.Store.Product.DefaultInstance, extensionRegistry);
              break;
            }
            case 16: {
              result.hasValidForSecs = input.ReadUInt32(ref result.validForSecs_);
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.currencies_, global::D3.Store.Currency.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::D3.Store.Product> ProductsList {
        get { return PrepareBuilder().products_; }
      }
      public int ProductsCount {
        get { return result.ProductsCount; }
      }
      public global::D3.Store.Product GetProducts(int index) {
        return result.GetProducts(index);
      }
      public Builder SetProducts(int index, global::D3.Store.Product value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.products_[index] = value;
        return this;
      }
      public Builder SetProducts(int index, global::D3.Store.Product.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.products_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddProducts(global::D3.Store.Product value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.products_.Add(value);
        return this;
      }
      public Builder AddProducts(global::D3.Store.Product.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.products_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeProducts(scg::IEnumerable<global::D3.Store.Product> values) {
        PrepareBuilder();
        result.products_.Add(values);
        return this;
      }
      public Builder ClearProducts() {
        PrepareBuilder();
        result.products_.Clear();
        return this;
      }
      
      public bool HasValidForSecs {
        get { return result.hasValidForSecs; }
      }
      public uint ValidForSecs {
        get { return result.ValidForSecs; }
        set { SetValidForSecs(value); }
      }
      public Builder SetValidForSecs(uint value) {
        PrepareBuilder();
        result.hasValidForSecs = true;
        result.validForSecs_ = value;
        return this;
      }
      public Builder ClearValidForSecs() {
        PrepareBuilder();
        result.hasValidForSecs = false;
        result.validForSecs_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Store.Currency> CurrenciesList {
        get { return PrepareBuilder().currencies_; }
      }
      public int CurrenciesCount {
        get { return result.CurrenciesCount; }
      }
      public global::D3.Store.Currency GetCurrencies(int index) {
        return result.GetCurrencies(index);
      }
      public Builder SetCurrencies(int index, global::D3.Store.Currency value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.currencies_[index] = value;
        return this;
      }
      public Builder SetCurrencies(int index, global::D3.Store.Currency.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.currencies_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddCurrencies(global::D3.Store.Currency value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.currencies_.Add(value);
        return this;
      }
      public Builder AddCurrencies(global::D3.Store.Currency.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.currencies_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeCurrencies(scg::IEnumerable<global::D3.Store.Currency> values) {
        PrepareBuilder();
        result.currencies_.Add(values);
        return this;
      }
      public Builder ClearCurrencies() {
        PrepareBuilder();
        result.currencies_.Clear();
        return this;
      }
    }
    static GetProductListResponse() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetProduct : pb::GeneratedMessage<GetProduct, GetProduct.Builder> {
    private GetProduct() { }
    private static readonly GetProduct defaultInstance = new GetProduct().MakeReadOnly();
    private static readonly string[] _getProductFieldNames = new string[] { "product_id" };
    private static readonly uint[] _getProductFieldTags = new uint[] { 16 };
    public static GetProduct DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetProduct DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetProduct ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetProduct__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetProduct, GetProduct.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetProduct__FieldAccessorTable; }
    }
    
    public const int ProductIdFieldNumber = 2;
    private bool hasProductId;
    private uint productId_;
    public bool HasProductId {
      get { return hasProductId; }
    }
    public uint ProductId {
      get { return productId_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getProductFieldNames;
      if (hasProductId) {
        output.WriteUInt32(2, field_names[0], ProductId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasProductId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, ProductId);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetProduct ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetProduct ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetProduct ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetProduct ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetProduct ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetProduct ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetProduct ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetProduct ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetProduct ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetProduct ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetProduct MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetProduct prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetProduct, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetProduct cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetProduct result;
      
      private GetProduct PrepareBuilder() {
        if (resultIsReadOnly) {
          GetProduct original = result;
          result = new GetProduct();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetProduct MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetProduct.Descriptor; }
      }
      
      public override GetProduct DefaultInstanceForType {
        get { return global::D3.Store.GetProduct.DefaultInstance; }
      }
      
      public override GetProduct BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetProduct) {
          return MergeFrom((GetProduct) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetProduct other) {
        if (other == global::D3.Store.GetProduct.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasProductId) {
          ProductId = other.ProductId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getProductFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getProductFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 16: {
              result.hasProductId = input.ReadUInt32(ref result.productId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasProductId {
        get { return result.hasProductId; }
      }
      public uint ProductId {
        get { return result.ProductId; }
        set { SetProductId(value); }
      }
      public Builder SetProductId(uint value) {
        PrepareBuilder();
        result.hasProductId = true;
        result.productId_ = value;
        return this;
      }
      public Builder ClearProductId() {
        PrepareBuilder();
        result.hasProductId = false;
        result.productId_ = 0;
        return this;
      }
    }
    static GetProduct() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetProductResponse : pb::GeneratedMessage<GetProductResponse, GetProductResponse.Builder> {
    private GetProductResponse() { }
    private static readonly GetProductResponse defaultInstance = new GetProductResponse().MakeReadOnly();
    private static readonly string[] _getProductResponseFieldNames = new string[] { "currencies", "product" };
    private static readonly uint[] _getProductResponseFieldTags = new uint[] { 18, 10 };
    public static GetProductResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetProductResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetProductResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetProductResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetProductResponse, GetProductResponse.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetProductResponse__FieldAccessorTable; }
    }
    
    public const int ProductFieldNumber = 1;
    private bool hasProduct;
    private global::D3.Store.Product product_;
    public bool HasProduct {
      get { return hasProduct; }
    }
    public global::D3.Store.Product Product {
      get { return product_ ?? global::D3.Store.Product.DefaultInstance; }
    }
    
    public const int CurrenciesFieldNumber = 2;
    private pbc::PopsicleList<global::D3.Store.Currency> currencies_ = new pbc::PopsicleList<global::D3.Store.Currency>();
    public scg::IList<global::D3.Store.Currency> CurrenciesList {
      get { return currencies_; }
    }
    public int CurrenciesCount {
      get { return currencies_.Count; }
    }
    public global::D3.Store.Currency GetCurrencies(int index) {
      return currencies_[index];
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getProductResponseFieldNames;
      if (hasProduct) {
        output.WriteMessage(1, field_names[1], Product);
      }
      if (currencies_.Count > 0) {
        output.WriteMessageArray(2, field_names[0], currencies_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasProduct) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Product);
        }
        foreach (global::D3.Store.Currency element in CurrenciesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetProductResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetProductResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetProductResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetProductResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetProductResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetProductResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetProductResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetProductResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetProductResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetProductResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetProductResponse MakeReadOnly() {
      currencies_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetProductResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetProductResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetProductResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetProductResponse result;
      
      private GetProductResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          GetProductResponse original = result;
          result = new GetProductResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetProductResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetProductResponse.Descriptor; }
      }
      
      public override GetProductResponse DefaultInstanceForType {
        get { return global::D3.Store.GetProductResponse.DefaultInstance; }
      }
      
      public override GetProductResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetProductResponse) {
          return MergeFrom((GetProductResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetProductResponse other) {
        if (other == global::D3.Store.GetProductResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasProduct) {
          MergeProduct(other.Product);
        }
        if (other.currencies_.Count != 0) {
          result.currencies_.Add(other.currencies_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getProductResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getProductResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.Store.Product.Builder subBuilder = global::D3.Store.Product.CreateBuilder();
              if (result.hasProduct) {
                subBuilder.MergeFrom(Product);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Product = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.currencies_, global::D3.Store.Currency.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasProduct {
       get { return result.hasProduct; }
      }
      public global::D3.Store.Product Product {
        get { return result.Product; }
        set { SetProduct(value); }
      }
      public Builder SetProduct(global::D3.Store.Product value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasProduct = true;
        result.product_ = value;
        return this;
      }
      public Builder SetProduct(global::D3.Store.Product.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasProduct = true;
        result.product_ = builderForValue.Build();
        return this;
      }
      public Builder MergeProduct(global::D3.Store.Product value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasProduct &&
            result.product_ != global::D3.Store.Product.DefaultInstance) {
            result.product_ = global::D3.Store.Product.CreateBuilder(result.product_).MergeFrom(value).BuildPartial();
        } else {
          result.product_ = value;
        }
        result.hasProduct = true;
        return this;
      }
      public Builder ClearProduct() {
        PrepareBuilder();
        result.hasProduct = false;
        result.product_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Store.Currency> CurrenciesList {
        get { return PrepareBuilder().currencies_; }
      }
      public int CurrenciesCount {
        get { return result.CurrenciesCount; }
      }
      public global::D3.Store.Currency GetCurrencies(int index) {
        return result.GetCurrencies(index);
      }
      public Builder SetCurrencies(int index, global::D3.Store.Currency value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.currencies_[index] = value;
        return this;
      }
      public Builder SetCurrencies(int index, global::D3.Store.Currency.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.currencies_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddCurrencies(global::D3.Store.Currency value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.currencies_.Add(value);
        return this;
      }
      public Builder AddCurrencies(global::D3.Store.Currency.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.currencies_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeCurrencies(scg::IEnumerable<global::D3.Store.Currency> values) {
        PrepareBuilder();
        result.currencies_.Add(values);
        return this;
      }
      public Builder ClearCurrencies() {
        PrepareBuilder();
        result.currencies_.Clear();
        return this;
      }
    }
    static GetProductResponse() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetProductCategories : pb::GeneratedMessage<GetProductCategories, GetProductCategories.Builder> {
    private GetProductCategories() { }
    private static readonly GetProductCategories defaultInstance = new GetProductCategories().MakeReadOnly();
    private static readonly string[] _getProductCategoriesFieldNames = new string[] { "catalog_version" };
    private static readonly uint[] _getProductCategoriesFieldTags = new uint[] { 8 };
    public static GetProductCategories DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetProductCategories DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetProductCategories ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetProductCategories__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetProductCategories, GetProductCategories.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetProductCategories__FieldAccessorTable; }
    }
    
    public const int CatalogVersionFieldNumber = 1;
    private bool hasCatalogVersion;
    private ulong catalogVersion_;
    public bool HasCatalogVersion {
      get { return hasCatalogVersion; }
    }
    public ulong CatalogVersion {
      get { return catalogVersion_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getProductCategoriesFieldNames;
      if (hasCatalogVersion) {
        output.WriteUInt64(1, field_names[0], CatalogVersion);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCatalogVersion) {
          size += pb::CodedOutputStream.ComputeUInt64Size(1, CatalogVersion);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetProductCategories ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetProductCategories ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetProductCategories ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetProductCategories ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetProductCategories ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetProductCategories ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetProductCategories ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetProductCategories ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetProductCategories ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetProductCategories ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetProductCategories MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetProductCategories prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetProductCategories, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetProductCategories cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetProductCategories result;
      
      private GetProductCategories PrepareBuilder() {
        if (resultIsReadOnly) {
          GetProductCategories original = result;
          result = new GetProductCategories();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetProductCategories MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetProductCategories.Descriptor; }
      }
      
      public override GetProductCategories DefaultInstanceForType {
        get { return global::D3.Store.GetProductCategories.DefaultInstance; }
      }
      
      public override GetProductCategories BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetProductCategories) {
          return MergeFrom((GetProductCategories) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetProductCategories other) {
        if (other == global::D3.Store.GetProductCategories.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCatalogVersion) {
          CatalogVersion = other.CatalogVersion;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getProductCategoriesFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getProductCategoriesFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasCatalogVersion = input.ReadUInt64(ref result.catalogVersion_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCatalogVersion {
        get { return result.hasCatalogVersion; }
      }
      public ulong CatalogVersion {
        get { return result.CatalogVersion; }
        set { SetCatalogVersion(value); }
      }
      public Builder SetCatalogVersion(ulong value) {
        PrepareBuilder();
        result.hasCatalogVersion = true;
        result.catalogVersion_ = value;
        return this;
      }
      public Builder ClearCatalogVersion() {
        PrepareBuilder();
        result.hasCatalogVersion = false;
        result.catalogVersion_ = 0UL;
        return this;
      }
    }
    static GetProductCategories() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetProductCategoriesResponse : pb::GeneratedMessage<GetProductCategoriesResponse, GetProductCategoriesResponse.Builder> {
    private GetProductCategoriesResponse() { }
    private static readonly GetProductCategoriesResponse defaultInstance = new GetProductCategoriesResponse().MakeReadOnly();
    private static readonly string[] _getProductCategoriesResponseFieldNames = new string[] { "categories" };
    private static readonly uint[] _getProductCategoriesResponseFieldTags = new uint[] { 10 };
    public static GetProductCategoriesResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetProductCategoriesResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetProductCategoriesResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetProductCategoriesResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetProductCategoriesResponse, GetProductCategoriesResponse.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetProductCategoriesResponse__FieldAccessorTable; }
    }
    
    public const int CategoriesFieldNumber = 1;
    private pbc::PopsicleList<global::D3.Store.ProductCategory> categories_ = new pbc::PopsicleList<global::D3.Store.ProductCategory>();
    public scg::IList<global::D3.Store.ProductCategory> CategoriesList {
      get { return categories_; }
    }
    public int CategoriesCount {
      get { return categories_.Count; }
    }
    public global::D3.Store.ProductCategory GetCategories(int index) {
      return categories_[index];
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getProductCategoriesResponseFieldNames;
      if (categories_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], categories_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::D3.Store.ProductCategory element in CategoriesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetProductCategoriesResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetProductCategoriesResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetProductCategoriesResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetProductCategoriesResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetProductCategoriesResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetProductCategoriesResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetProductCategoriesResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetProductCategoriesResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetProductCategoriesResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetProductCategoriesResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetProductCategoriesResponse MakeReadOnly() {
      categories_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetProductCategoriesResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetProductCategoriesResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetProductCategoriesResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetProductCategoriesResponse result;
      
      private GetProductCategoriesResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          GetProductCategoriesResponse original = result;
          result = new GetProductCategoriesResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetProductCategoriesResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetProductCategoriesResponse.Descriptor; }
      }
      
      public override GetProductCategoriesResponse DefaultInstanceForType {
        get { return global::D3.Store.GetProductCategoriesResponse.DefaultInstance; }
      }
      
      public override GetProductCategoriesResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetProductCategoriesResponse) {
          return MergeFrom((GetProductCategoriesResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetProductCategoriesResponse other) {
        if (other == global::D3.Store.GetProductCategoriesResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.categories_.Count != 0) {
          result.categories_.Add(other.categories_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getProductCategoriesResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getProductCategoriesResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.categories_, global::D3.Store.ProductCategory.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::D3.Store.ProductCategory> CategoriesList {
        get { return PrepareBuilder().categories_; }
      }
      public int CategoriesCount {
        get { return result.CategoriesCount; }
      }
      public global::D3.Store.ProductCategory GetCategories(int index) {
        return result.GetCategories(index);
      }
      public Builder SetCategories(int index, global::D3.Store.ProductCategory value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.categories_[index] = value;
        return this;
      }
      public Builder SetCategories(int index, global::D3.Store.ProductCategory.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.categories_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddCategories(global::D3.Store.ProductCategory value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.categories_.Add(value);
        return this;
      }
      public Builder AddCategories(global::D3.Store.ProductCategory.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.categories_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeCategories(scg::IEnumerable<global::D3.Store.ProductCategory> values) {
        PrepareBuilder();
        result.categories_.Add(values);
        return this;
      }
      public Builder ClearCategories() {
        PrepareBuilder();
        result.categories_.Clear();
        return this;
      }
    }
    static GetProductCategoriesResponse() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetPrimaryCurrency : pb::GeneratedMessage<GetPrimaryCurrency, GetPrimaryCurrency.Builder> {
    private GetPrimaryCurrency() { }
    private static readonly GetPrimaryCurrency defaultInstance = new GetPrimaryCurrency().MakeReadOnly();
    private static readonly string[] _getPrimaryCurrencyFieldNames = new string[] {  };
    private static readonly uint[] _getPrimaryCurrencyFieldTags = new uint[] {  };
    public static GetPrimaryCurrency DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetPrimaryCurrency DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetPrimaryCurrency ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetPrimaryCurrency__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetPrimaryCurrency, GetPrimaryCurrency.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetPrimaryCurrency__FieldAccessorTable; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getPrimaryCurrencyFieldNames;
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetPrimaryCurrency ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetPrimaryCurrency ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetPrimaryCurrency ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetPrimaryCurrency ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetPrimaryCurrency ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetPrimaryCurrency ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetPrimaryCurrency ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetPrimaryCurrency ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetPrimaryCurrency ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetPrimaryCurrency ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetPrimaryCurrency MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetPrimaryCurrency prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetPrimaryCurrency, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetPrimaryCurrency cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetPrimaryCurrency result;
      
      private GetPrimaryCurrency PrepareBuilder() {
        if (resultIsReadOnly) {
          GetPrimaryCurrency original = result;
          result = new GetPrimaryCurrency();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetPrimaryCurrency MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetPrimaryCurrency.Descriptor; }
      }
      
      public override GetPrimaryCurrency DefaultInstanceForType {
        get { return global::D3.Store.GetPrimaryCurrency.DefaultInstance; }
      }
      
      public override GetPrimaryCurrency BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetPrimaryCurrency) {
          return MergeFrom((GetPrimaryCurrency) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetPrimaryCurrency other) {
        if (other == global::D3.Store.GetPrimaryCurrency.DefaultInstance) return this;
        PrepareBuilder();
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getPrimaryCurrencyFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getPrimaryCurrencyFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
    }
    static GetPrimaryCurrency() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetPrimaryCurrencyResponse : pb::GeneratedMessage<GetPrimaryCurrencyResponse, GetPrimaryCurrencyResponse.Builder> {
    private GetPrimaryCurrencyResponse() { }
    private static readonly GetPrimaryCurrencyResponse defaultInstance = new GetPrimaryCurrencyResponse().MakeReadOnly();
    private static readonly string[] _getPrimaryCurrencyResponseFieldNames = new string[] { "currency" };
    private static readonly uint[] _getPrimaryCurrencyResponseFieldTags = new uint[] { 8 };
    public static GetPrimaryCurrencyResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetPrimaryCurrencyResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetPrimaryCurrencyResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetPrimaryCurrencyResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetPrimaryCurrencyResponse, GetPrimaryCurrencyResponse.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetPrimaryCurrencyResponse__FieldAccessorTable; }
    }
    
    public const int CurrencyFieldNumber = 1;
    private bool hasCurrency;
    private int currency_;
    public bool HasCurrency {
      get { return hasCurrency; }
    }
    public int Currency {
      get { return currency_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getPrimaryCurrencyResponseFieldNames;
      if (hasCurrency) {
        output.WriteInt32(1, field_names[0], Currency);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCurrency) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, Currency);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetPrimaryCurrencyResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetPrimaryCurrencyResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetPrimaryCurrencyResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetPrimaryCurrencyResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetPrimaryCurrencyResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetPrimaryCurrencyResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetPrimaryCurrencyResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetPrimaryCurrencyResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetPrimaryCurrencyResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetPrimaryCurrencyResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetPrimaryCurrencyResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetPrimaryCurrencyResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetPrimaryCurrencyResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetPrimaryCurrencyResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetPrimaryCurrencyResponse result;
      
      private GetPrimaryCurrencyResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          GetPrimaryCurrencyResponse original = result;
          result = new GetPrimaryCurrencyResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetPrimaryCurrencyResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetPrimaryCurrencyResponse.Descriptor; }
      }
      
      public override GetPrimaryCurrencyResponse DefaultInstanceForType {
        get { return global::D3.Store.GetPrimaryCurrencyResponse.DefaultInstance; }
      }
      
      public override GetPrimaryCurrencyResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetPrimaryCurrencyResponse) {
          return MergeFrom((GetPrimaryCurrencyResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetPrimaryCurrencyResponse other) {
        if (other == global::D3.Store.GetPrimaryCurrencyResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCurrency) {
          Currency = other.Currency;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getPrimaryCurrencyResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getPrimaryCurrencyResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasCurrency = input.ReadInt32(ref result.currency_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCurrency {
        get { return result.hasCurrency; }
      }
      public int Currency {
        get { return result.Currency; }
        set { SetCurrency(value); }
      }
      public Builder SetCurrency(int value) {
        PrepareBuilder();
        result.hasCurrency = true;
        result.currency_ = value;
        return this;
      }
      public Builder ClearCurrency() {
        PrepareBuilder();
        result.hasCurrency = false;
        result.currency_ = 0;
        return this;
      }
    }
    static GetPrimaryCurrencyResponse() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetPaymentMethods : pb::GeneratedMessage<GetPaymentMethods, GetPaymentMethods.Builder> {
    private GetPaymentMethods() { }
    private static readonly GetPaymentMethods defaultInstance = new GetPaymentMethods().MakeReadOnly();
    private static readonly string[] _getPaymentMethodsFieldNames = new string[] { "currency" };
    private static readonly uint[] _getPaymentMethodsFieldTags = new uint[] { 8 };
    public static GetPaymentMethods DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetPaymentMethods DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetPaymentMethods ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetPaymentMethods__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetPaymentMethods, GetPaymentMethods.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetPaymentMethods__FieldAccessorTable; }
    }
    
    public const int CurrencyFieldNumber = 1;
    private bool hasCurrency;
    private int currency_;
    public bool HasCurrency {
      get { return hasCurrency; }
    }
    public int Currency {
      get { return currency_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getPaymentMethodsFieldNames;
      if (hasCurrency) {
        output.WriteInt32(1, field_names[0], Currency);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCurrency) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, Currency);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetPaymentMethods ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetPaymentMethods ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetPaymentMethods ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetPaymentMethods ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetPaymentMethods ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetPaymentMethods ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetPaymentMethods ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetPaymentMethods ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetPaymentMethods ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetPaymentMethods ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetPaymentMethods MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetPaymentMethods prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetPaymentMethods, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetPaymentMethods cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetPaymentMethods result;
      
      private GetPaymentMethods PrepareBuilder() {
        if (resultIsReadOnly) {
          GetPaymentMethods original = result;
          result = new GetPaymentMethods();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetPaymentMethods MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetPaymentMethods.Descriptor; }
      }
      
      public override GetPaymentMethods DefaultInstanceForType {
        get { return global::D3.Store.GetPaymentMethods.DefaultInstance; }
      }
      
      public override GetPaymentMethods BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetPaymentMethods) {
          return MergeFrom((GetPaymentMethods) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetPaymentMethods other) {
        if (other == global::D3.Store.GetPaymentMethods.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCurrency) {
          Currency = other.Currency;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getPaymentMethodsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getPaymentMethodsFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasCurrency = input.ReadInt32(ref result.currency_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCurrency {
        get { return result.hasCurrency; }
      }
      public int Currency {
        get { return result.Currency; }
        set { SetCurrency(value); }
      }
      public Builder SetCurrency(int value) {
        PrepareBuilder();
        result.hasCurrency = true;
        result.currency_ = value;
        return this;
      }
      public Builder ClearCurrency() {
        PrepareBuilder();
        result.hasCurrency = false;
        result.currency_ = 0;
        return this;
      }
    }
    static GetPaymentMethods() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetPaymentMethodsResponse : pb::GeneratedMessage<GetPaymentMethodsResponse, GetPaymentMethodsResponse.Builder> {
    private GetPaymentMethodsResponse() { }
    private static readonly GetPaymentMethodsResponse defaultInstance = new GetPaymentMethodsResponse().MakeReadOnly();
    private static readonly string[] _getPaymentMethodsResponseFieldNames = new string[] { "wallets" };
    private static readonly uint[] _getPaymentMethodsResponseFieldTags = new uint[] { 10 };
    public static GetPaymentMethodsResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetPaymentMethodsResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetPaymentMethodsResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetPaymentMethodsResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetPaymentMethodsResponse, GetPaymentMethodsResponse.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetPaymentMethodsResponse__FieldAccessorTable; }
    }
    
    public const int WalletsFieldNumber = 1;
    private pbc::PopsicleList<global::D3.Store.Wallet> wallets_ = new pbc::PopsicleList<global::D3.Store.Wallet>();
    public scg::IList<global::D3.Store.Wallet> WalletsList {
      get { return wallets_; }
    }
    public int WalletsCount {
      get { return wallets_.Count; }
    }
    public global::D3.Store.Wallet GetWallets(int index) {
      return wallets_[index];
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getPaymentMethodsResponseFieldNames;
      if (wallets_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], wallets_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::D3.Store.Wallet element in WalletsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetPaymentMethodsResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetPaymentMethodsResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetPaymentMethodsResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetPaymentMethodsResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetPaymentMethodsResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetPaymentMethodsResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetPaymentMethodsResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetPaymentMethodsResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetPaymentMethodsResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetPaymentMethodsResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetPaymentMethodsResponse MakeReadOnly() {
      wallets_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetPaymentMethodsResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetPaymentMethodsResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetPaymentMethodsResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetPaymentMethodsResponse result;
      
      private GetPaymentMethodsResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          GetPaymentMethodsResponse original = result;
          result = new GetPaymentMethodsResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetPaymentMethodsResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetPaymentMethodsResponse.Descriptor; }
      }
      
      public override GetPaymentMethodsResponse DefaultInstanceForType {
        get { return global::D3.Store.GetPaymentMethodsResponse.DefaultInstance; }
      }
      
      public override GetPaymentMethodsResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetPaymentMethodsResponse) {
          return MergeFrom((GetPaymentMethodsResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetPaymentMethodsResponse other) {
        if (other == global::D3.Store.GetPaymentMethodsResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.wallets_.Count != 0) {
          result.wallets_.Add(other.wallets_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getPaymentMethodsResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getPaymentMethodsResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.wallets_, global::D3.Store.Wallet.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::D3.Store.Wallet> WalletsList {
        get { return PrepareBuilder().wallets_; }
      }
      public int WalletsCount {
        get { return result.WalletsCount; }
      }
      public global::D3.Store.Wallet GetWallets(int index) {
        return result.GetWallets(index);
      }
      public Builder SetWallets(int index, global::D3.Store.Wallet value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.wallets_[index] = value;
        return this;
      }
      public Builder SetWallets(int index, global::D3.Store.Wallet.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.wallets_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddWallets(global::D3.Store.Wallet value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.wallets_.Add(value);
        return this;
      }
      public Builder AddWallets(global::D3.Store.Wallet.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.wallets_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeWallets(scg::IEnumerable<global::D3.Store.Wallet> values) {
        PrepareBuilder();
        result.wallets_.Add(values);
        return this;
      }
      public Builder ClearWallets() {
        PrepareBuilder();
        result.wallets_.Clear();
        return this;
      }
    }
    static GetPaymentMethodsResponse() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class DetermineRisk : pb::GeneratedMessage<DetermineRisk, DetermineRisk.Builder> {
    private DetermineRisk() { }
    private static readonly DetermineRisk defaultInstance = new DetermineRisk().MakeReadOnly();
    private static readonly string[] _determineRiskFieldNames = new string[] { "currency", "device_id", "product_id", "wallet_id" };
    private static readonly uint[] _determineRiskFieldTags = new uint[] { 24, 34, 40, 16 };
    public static DetermineRisk DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override DetermineRisk DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override DetermineRisk ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_DetermineRisk__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<DetermineRisk, DetermineRisk.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_DetermineRisk__FieldAccessorTable; }
    }
    
    public const int WalletIdFieldNumber = 2;
    private bool hasWalletId;
    private long walletId_;
    public bool HasWalletId {
      get { return hasWalletId; }
    }
    public long WalletId {
      get { return walletId_; }
    }
    
    public const int CurrencyFieldNumber = 3;
    private bool hasCurrency;
    private int currency_;
    public bool HasCurrency {
      get { return hasCurrency; }
    }
    public int Currency {
      get { return currency_; }
    }
    
    public const int DeviceIdFieldNumber = 4;
    private bool hasDeviceId;
    private string deviceId_ = "";
    public bool HasDeviceId {
      get { return hasDeviceId; }
    }
    public string DeviceId {
      get { return deviceId_; }
    }
    
    public const int ProductIdFieldNumber = 5;
    private bool hasProductId;
    private uint productId_;
    public bool HasProductId {
      get { return hasProductId; }
    }
    public uint ProductId {
      get { return productId_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _determineRiskFieldNames;
      if (hasWalletId) {
        output.WriteSInt64(2, field_names[3], WalletId);
      }
      if (hasCurrency) {
        output.WriteInt32(3, field_names[0], Currency);
      }
      if (hasDeviceId) {
        output.WriteString(4, field_names[1], DeviceId);
      }
      if (hasProductId) {
        output.WriteUInt32(5, field_names[2], ProductId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasWalletId) {
          size += pb::CodedOutputStream.ComputeSInt64Size(2, WalletId);
        }
        if (hasCurrency) {
          size += pb::CodedOutputStream.ComputeInt32Size(3, Currency);
        }
        if (hasDeviceId) {
          size += pb::CodedOutputStream.ComputeStringSize(4, DeviceId);
        }
        if (hasProductId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(5, ProductId);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static DetermineRisk ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static DetermineRisk ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static DetermineRisk ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static DetermineRisk ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static DetermineRisk ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static DetermineRisk ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static DetermineRisk ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static DetermineRisk ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static DetermineRisk ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static DetermineRisk ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private DetermineRisk MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(DetermineRisk prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<DetermineRisk, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(DetermineRisk cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private DetermineRisk result;
      
      private DetermineRisk PrepareBuilder() {
        if (resultIsReadOnly) {
          DetermineRisk original = result;
          result = new DetermineRisk();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override DetermineRisk MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.DetermineRisk.Descriptor; }
      }
      
      public override DetermineRisk DefaultInstanceForType {
        get { return global::D3.Store.DetermineRisk.DefaultInstance; }
      }
      
      public override DetermineRisk BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is DetermineRisk) {
          return MergeFrom((DetermineRisk) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(DetermineRisk other) {
        if (other == global::D3.Store.DetermineRisk.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasWalletId) {
          WalletId = other.WalletId;
        }
        if (other.HasCurrency) {
          Currency = other.Currency;
        }
        if (other.HasDeviceId) {
          DeviceId = other.DeviceId;
        }
        if (other.HasProductId) {
          ProductId = other.ProductId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_determineRiskFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _determineRiskFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 16: {
              result.hasWalletId = input.ReadSInt64(ref result.walletId_);
              break;
            }
            case 24: {
              result.hasCurrency = input.ReadInt32(ref result.currency_);
              break;
            }
            case 34: {
              result.hasDeviceId = input.ReadString(ref result.deviceId_);
              break;
            }
            case 40: {
              result.hasProductId = input.ReadUInt32(ref result.productId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasWalletId {
        get { return result.hasWalletId; }
      }
      public long WalletId {
        get { return result.WalletId; }
        set { SetWalletId(value); }
      }
      public Builder SetWalletId(long value) {
        PrepareBuilder();
        result.hasWalletId = true;
        result.walletId_ = value;
        return this;
      }
      public Builder ClearWalletId() {
        PrepareBuilder();
        result.hasWalletId = false;
        result.walletId_ = 0;
        return this;
      }
      
      public bool HasCurrency {
        get { return result.hasCurrency; }
      }
      public int Currency {
        get { return result.Currency; }
        set { SetCurrency(value); }
      }
      public Builder SetCurrency(int value) {
        PrepareBuilder();
        result.hasCurrency = true;
        result.currency_ = value;
        return this;
      }
      public Builder ClearCurrency() {
        PrepareBuilder();
        result.hasCurrency = false;
        result.currency_ = 0;
        return this;
      }
      
      public bool HasDeviceId {
        get { return result.hasDeviceId; }
      }
      public string DeviceId {
        get { return result.DeviceId; }
        set { SetDeviceId(value); }
      }
      public Builder SetDeviceId(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDeviceId = true;
        result.deviceId_ = value;
        return this;
      }
      public Builder ClearDeviceId() {
        PrepareBuilder();
        result.hasDeviceId = false;
        result.deviceId_ = "";
        return this;
      }
      
      public bool HasProductId {
        get { return result.hasProductId; }
      }
      public uint ProductId {
        get { return result.ProductId; }
        set { SetProductId(value); }
      }
      public Builder SetProductId(uint value) {
        PrepareBuilder();
        result.hasProductId = true;
        result.productId_ = value;
        return this;
      }
      public Builder ClearProductId() {
        PrepareBuilder();
        result.hasProductId = false;
        result.productId_ = 0;
        return this;
      }
    }
    static DetermineRisk() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class DetermineRiskResponse : pb::GeneratedMessage<DetermineRiskResponse, DetermineRiskResponse.Builder> {
    private DetermineRiskResponse() { }
    private static readonly DetermineRiskResponse defaultInstance = new DetermineRiskResponse().MakeReadOnly();
    private static readonly string[] _determineRiskResponseFieldNames = new string[] { "risk", "wallet_id" };
    private static readonly uint[] _determineRiskResponseFieldTags = new uint[] { 10, 16 };
    public static DetermineRiskResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override DetermineRiskResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override DetermineRiskResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_DetermineRiskResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<DetermineRiskResponse, DetermineRiskResponse.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_DetermineRiskResponse__FieldAccessorTable; }
    }
    
    public const int RiskFieldNumber = 1;
    private bool hasRisk;
    private global::D3.Store.Risk risk_;
    public bool HasRisk {
      get { return hasRisk; }
    }
    public global::D3.Store.Risk Risk {
      get { return risk_ ?? global::D3.Store.Risk.DefaultInstance; }
    }
    
    public const int WalletIdFieldNumber = 2;
    private bool hasWalletId;
    private long walletId_;
    public bool HasWalletId {
      get { return hasWalletId; }
    }
    public long WalletId {
      get { return walletId_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _determineRiskResponseFieldNames;
      if (hasRisk) {
        output.WriteMessage(1, field_names[0], Risk);
      }
      if (hasWalletId) {
        output.WriteSInt64(2, field_names[1], WalletId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasRisk) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Risk);
        }
        if (hasWalletId) {
          size += pb::CodedOutputStream.ComputeSInt64Size(2, WalletId);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static DetermineRiskResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static DetermineRiskResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static DetermineRiskResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static DetermineRiskResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static DetermineRiskResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static DetermineRiskResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static DetermineRiskResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static DetermineRiskResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static DetermineRiskResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static DetermineRiskResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private DetermineRiskResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(DetermineRiskResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<DetermineRiskResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(DetermineRiskResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private DetermineRiskResponse result;
      
      private DetermineRiskResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          DetermineRiskResponse original = result;
          result = new DetermineRiskResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override DetermineRiskResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.DetermineRiskResponse.Descriptor; }
      }
      
      public override DetermineRiskResponse DefaultInstanceForType {
        get { return global::D3.Store.DetermineRiskResponse.DefaultInstance; }
      }
      
      public override DetermineRiskResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is DetermineRiskResponse) {
          return MergeFrom((DetermineRiskResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(DetermineRiskResponse other) {
        if (other == global::D3.Store.DetermineRiskResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRisk) {
          MergeRisk(other.Risk);
        }
        if (other.HasWalletId) {
          WalletId = other.WalletId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_determineRiskResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _determineRiskResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.Store.Risk.Builder subBuilder = global::D3.Store.Risk.CreateBuilder();
              if (result.hasRisk) {
                subBuilder.MergeFrom(Risk);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Risk = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              result.hasWalletId = input.ReadSInt64(ref result.walletId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasRisk {
       get { return result.hasRisk; }
      }
      public global::D3.Store.Risk Risk {
        get { return result.Risk; }
        set { SetRisk(value); }
      }
      public Builder SetRisk(global::D3.Store.Risk value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRisk = true;
        result.risk_ = value;
        return this;
      }
      public Builder SetRisk(global::D3.Store.Risk.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRisk = true;
        result.risk_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRisk(global::D3.Store.Risk value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRisk &&
            result.risk_ != global::D3.Store.Risk.DefaultInstance) {
            result.risk_ = global::D3.Store.Risk.CreateBuilder(result.risk_).MergeFrom(value).BuildPartial();
        } else {
          result.risk_ = value;
        }
        result.hasRisk = true;
        return this;
      }
      public Builder ClearRisk() {
        PrepareBuilder();
        result.hasRisk = false;
        result.risk_ = null;
        return this;
      }
      
      public bool HasWalletId {
        get { return result.hasWalletId; }
      }
      public long WalletId {
        get { return result.WalletId; }
        set { SetWalletId(value); }
      }
      public Builder SetWalletId(long value) {
        PrepareBuilder();
        result.hasWalletId = true;
        result.walletId_ = value;
        return this;
      }
      public Builder ClearWalletId() {
        PrepareBuilder();
        result.hasWalletId = false;
        result.walletId_ = 0;
        return this;
      }
    }
    static DetermineRiskResponse() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class PlaceOrder : pb::GeneratedMessage<PlaceOrder, PlaceOrder.Builder> {
    private PlaceOrder() { }
    private static readonly PlaceOrder defaultInstance = new PlaceOrder().MakeReadOnly();
    private static readonly string[] _placeOrderFieldNames = new string[] { "challenge_id", "currency", "device_id", "fixed_point_expected_price", "product_id", "risk_transaction_id", "wallet_id" };
    private static readonly uint[] _placeOrderFieldTags = new uint[] { 50, 24, 58, 72, 64, 42, 16 };
    public static PlaceOrder DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PlaceOrder DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PlaceOrder ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_PlaceOrder__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PlaceOrder, PlaceOrder.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_PlaceOrder__FieldAccessorTable; }
    }
    
    public const int WalletIdFieldNumber = 2;
    private bool hasWalletId;
    private long walletId_;
    public bool HasWalletId {
      get { return hasWalletId; }
    }
    public long WalletId {
      get { return walletId_; }
    }
    
    public const int CurrencyFieldNumber = 3;
    private bool hasCurrency;
    private int currency_;
    public bool HasCurrency {
      get { return hasCurrency; }
    }
    public int Currency {
      get { return currency_; }
    }
    
    public const int RiskTransactionIdFieldNumber = 5;
    private bool hasRiskTransactionId;
    private string riskTransactionId_ = "";
    public bool HasRiskTransactionId {
      get { return hasRiskTransactionId; }
    }
    public string RiskTransactionId {
      get { return riskTransactionId_; }
    }
    
    public const int ChallengeIdFieldNumber = 6;
    private bool hasChallengeId;
    private string challengeId_ = "";
    public bool HasChallengeId {
      get { return hasChallengeId; }
    }
    public string ChallengeId {
      get { return challengeId_; }
    }
    
    public const int DeviceIdFieldNumber = 7;
    private bool hasDeviceId;
    private string deviceId_ = "";
    public bool HasDeviceId {
      get { return hasDeviceId; }
    }
    public string DeviceId {
      get { return deviceId_; }
    }
    
    public const int ProductIdFieldNumber = 8;
    private bool hasProductId;
    private uint productId_;
    public bool HasProductId {
      get { return hasProductId; }
    }
    public uint ProductId {
      get { return productId_; }
    }
    
    public const int FixedPointExpectedPriceFieldNumber = 9;
    private bool hasFixedPointExpectedPrice;
    private long fixedPointExpectedPrice_;
    public bool HasFixedPointExpectedPrice {
      get { return hasFixedPointExpectedPrice; }
    }
    public long FixedPointExpectedPrice {
      get { return fixedPointExpectedPrice_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _placeOrderFieldNames;
      if (hasWalletId) {
        output.WriteSInt64(2, field_names[6], WalletId);
      }
      if (hasCurrency) {
        output.WriteInt32(3, field_names[1], Currency);
      }
      if (hasRiskTransactionId) {
        output.WriteString(5, field_names[5], RiskTransactionId);
      }
      if (hasChallengeId) {
        output.WriteString(6, field_names[0], ChallengeId);
      }
      if (hasDeviceId) {
        output.WriteString(7, field_names[2], DeviceId);
      }
      if (hasProductId) {
        output.WriteUInt32(8, field_names[4], ProductId);
      }
      if (hasFixedPointExpectedPrice) {
        output.WriteInt64(9, field_names[3], FixedPointExpectedPrice);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasWalletId) {
          size += pb::CodedOutputStream.ComputeSInt64Size(2, WalletId);
        }
        if (hasCurrency) {
          size += pb::CodedOutputStream.ComputeInt32Size(3, Currency);
        }
        if (hasRiskTransactionId) {
          size += pb::CodedOutputStream.ComputeStringSize(5, RiskTransactionId);
        }
        if (hasChallengeId) {
          size += pb::CodedOutputStream.ComputeStringSize(6, ChallengeId);
        }
        if (hasDeviceId) {
          size += pb::CodedOutputStream.ComputeStringSize(7, DeviceId);
        }
        if (hasProductId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(8, ProductId);
        }
        if (hasFixedPointExpectedPrice) {
          size += pb::CodedOutputStream.ComputeInt64Size(9, FixedPointExpectedPrice);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PlaceOrder ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PlaceOrder ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PlaceOrder ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PlaceOrder ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PlaceOrder ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PlaceOrder ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PlaceOrder ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PlaceOrder ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PlaceOrder ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PlaceOrder ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PlaceOrder MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PlaceOrder prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<PlaceOrder, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PlaceOrder cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PlaceOrder result;
      
      private PlaceOrder PrepareBuilder() {
        if (resultIsReadOnly) {
          PlaceOrder original = result;
          result = new PlaceOrder();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PlaceOrder MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.PlaceOrder.Descriptor; }
      }
      
      public override PlaceOrder DefaultInstanceForType {
        get { return global::D3.Store.PlaceOrder.DefaultInstance; }
      }
      
      public override PlaceOrder BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PlaceOrder) {
          return MergeFrom((PlaceOrder) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PlaceOrder other) {
        if (other == global::D3.Store.PlaceOrder.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasWalletId) {
          WalletId = other.WalletId;
        }
        if (other.HasCurrency) {
          Currency = other.Currency;
        }
        if (other.HasRiskTransactionId) {
          RiskTransactionId = other.RiskTransactionId;
        }
        if (other.HasChallengeId) {
          ChallengeId = other.ChallengeId;
        }
        if (other.HasDeviceId) {
          DeviceId = other.DeviceId;
        }
        if (other.HasProductId) {
          ProductId = other.ProductId;
        }
        if (other.HasFixedPointExpectedPrice) {
          FixedPointExpectedPrice = other.FixedPointExpectedPrice;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_placeOrderFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _placeOrderFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 16: {
              result.hasWalletId = input.ReadSInt64(ref result.walletId_);
              break;
            }
            case 24: {
              result.hasCurrency = input.ReadInt32(ref result.currency_);
              break;
            }
            case 42: {
              result.hasRiskTransactionId = input.ReadString(ref result.riskTransactionId_);
              break;
            }
            case 50: {
              result.hasChallengeId = input.ReadString(ref result.challengeId_);
              break;
            }
            case 58: {
              result.hasDeviceId = input.ReadString(ref result.deviceId_);
              break;
            }
            case 64: {
              result.hasProductId = input.ReadUInt32(ref result.productId_);
              break;
            }
            case 72: {
              result.hasFixedPointExpectedPrice = input.ReadInt64(ref result.fixedPointExpectedPrice_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasWalletId {
        get { return result.hasWalletId; }
      }
      public long WalletId {
        get { return result.WalletId; }
        set { SetWalletId(value); }
      }
      public Builder SetWalletId(long value) {
        PrepareBuilder();
        result.hasWalletId = true;
        result.walletId_ = value;
        return this;
      }
      public Builder ClearWalletId() {
        PrepareBuilder();
        result.hasWalletId = false;
        result.walletId_ = 0;
        return this;
      }
      
      public bool HasCurrency {
        get { return result.hasCurrency; }
      }
      public int Currency {
        get { return result.Currency; }
        set { SetCurrency(value); }
      }
      public Builder SetCurrency(int value) {
        PrepareBuilder();
        result.hasCurrency = true;
        result.currency_ = value;
        return this;
      }
      public Builder ClearCurrency() {
        PrepareBuilder();
        result.hasCurrency = false;
        result.currency_ = 0;
        return this;
      }
      
      public bool HasRiskTransactionId {
        get { return result.hasRiskTransactionId; }
      }
      public string RiskTransactionId {
        get { return result.RiskTransactionId; }
        set { SetRiskTransactionId(value); }
      }
      public Builder SetRiskTransactionId(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRiskTransactionId = true;
        result.riskTransactionId_ = value;
        return this;
      }
      public Builder ClearRiskTransactionId() {
        PrepareBuilder();
        result.hasRiskTransactionId = false;
        result.riskTransactionId_ = "";
        return this;
      }
      
      public bool HasChallengeId {
        get { return result.hasChallengeId; }
      }
      public string ChallengeId {
        get { return result.ChallengeId; }
        set { SetChallengeId(value); }
      }
      public Builder SetChallengeId(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasChallengeId = true;
        result.challengeId_ = value;
        return this;
      }
      public Builder ClearChallengeId() {
        PrepareBuilder();
        result.hasChallengeId = false;
        result.challengeId_ = "";
        return this;
      }
      
      public bool HasDeviceId {
        get { return result.hasDeviceId; }
      }
      public string DeviceId {
        get { return result.DeviceId; }
        set { SetDeviceId(value); }
      }
      public Builder SetDeviceId(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDeviceId = true;
        result.deviceId_ = value;
        return this;
      }
      public Builder ClearDeviceId() {
        PrepareBuilder();
        result.hasDeviceId = false;
        result.deviceId_ = "";
        return this;
      }
      
      public bool HasProductId {
        get { return result.hasProductId; }
      }
      public uint ProductId {
        get { return result.ProductId; }
        set { SetProductId(value); }
      }
      public Builder SetProductId(uint value) {
        PrepareBuilder();
        result.hasProductId = true;
        result.productId_ = value;
        return this;
      }
      public Builder ClearProductId() {
        PrepareBuilder();
        result.hasProductId = false;
        result.productId_ = 0;
        return this;
      }
      
      public bool HasFixedPointExpectedPrice {
        get { return result.hasFixedPointExpectedPrice; }
      }
      public long FixedPointExpectedPrice {
        get { return result.FixedPointExpectedPrice; }
        set { SetFixedPointExpectedPrice(value); }
      }
      public Builder SetFixedPointExpectedPrice(long value) {
        PrepareBuilder();
        result.hasFixedPointExpectedPrice = true;
        result.fixedPointExpectedPrice_ = value;
        return this;
      }
      public Builder ClearFixedPointExpectedPrice() {
        PrepareBuilder();
        result.hasFixedPointExpectedPrice = false;
        result.fixedPointExpectedPrice_ = 0L;
        return this;
      }
    }
    static PlaceOrder() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class PlaceOrderResponse : pb::GeneratedMessage<PlaceOrderResponse, PlaceOrderResponse.Builder> {
    private PlaceOrderResponse() { }
    private static readonly PlaceOrderResponse defaultInstance = new PlaceOrderResponse().MakeReadOnly();
    private static readonly string[] _placeOrderResponseFieldNames = new string[] { "transaction_id" };
    private static readonly uint[] _placeOrderResponseFieldTags = new uint[] { 8 };
    public static PlaceOrderResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PlaceOrderResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PlaceOrderResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_PlaceOrderResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PlaceOrderResponse, PlaceOrderResponse.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_PlaceOrderResponse__FieldAccessorTable; }
    }
    
    public const int TransactionIdFieldNumber = 1;
    private bool hasTransactionId;
    private ulong transactionId_;
    public bool HasTransactionId {
      get { return hasTransactionId; }
    }
    public ulong TransactionId {
      get { return transactionId_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _placeOrderResponseFieldNames;
      if (hasTransactionId) {
        output.WriteUInt64(1, field_names[0], TransactionId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasTransactionId) {
          size += pb::CodedOutputStream.ComputeUInt64Size(1, TransactionId);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PlaceOrderResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PlaceOrderResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PlaceOrderResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PlaceOrderResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PlaceOrderResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PlaceOrderResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PlaceOrderResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PlaceOrderResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PlaceOrderResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PlaceOrderResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PlaceOrderResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PlaceOrderResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<PlaceOrderResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PlaceOrderResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PlaceOrderResponse result;
      
      private PlaceOrderResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          PlaceOrderResponse original = result;
          result = new PlaceOrderResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PlaceOrderResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.PlaceOrderResponse.Descriptor; }
      }
      
      public override PlaceOrderResponse DefaultInstanceForType {
        get { return global::D3.Store.PlaceOrderResponse.DefaultInstance; }
      }
      
      public override PlaceOrderResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PlaceOrderResponse) {
          return MergeFrom((PlaceOrderResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PlaceOrderResponse other) {
        if (other == global::D3.Store.PlaceOrderResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasTransactionId) {
          TransactionId = other.TransactionId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_placeOrderResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _placeOrderResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasTransactionId = input.ReadUInt64(ref result.transactionId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasTransactionId {
        get { return result.hasTransactionId; }
      }
      public ulong TransactionId {
        get { return result.TransactionId; }
        set { SetTransactionId(value); }
      }
      public Builder SetTransactionId(ulong value) {
        PrepareBuilder();
        result.hasTransactionId = true;
        result.transactionId_ = value;
        return this;
      }
      public Builder ClearTransactionId() {
        PrepareBuilder();
        result.hasTransactionId = false;
        result.transactionId_ = 0UL;
        return this;
      }
    }
    static PlaceOrderResponse() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class EntitlementUpdate : pb::GeneratedMessage<EntitlementUpdate, EntitlementUpdate.Builder> {
    private EntitlementUpdate() { }
    private static readonly EntitlementUpdate defaultInstance = new EntitlementUpdate().MakeReadOnly();
    private static readonly string[] _entitlementUpdateFieldNames = new string[] { "entitlement", "expire_time" };
    private static readonly uint[] _entitlementUpdateFieldTags = new uint[] { 10, 16 };
    public static EntitlementUpdate DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EntitlementUpdate DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EntitlementUpdate ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_EntitlementUpdate__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EntitlementUpdate, EntitlementUpdate.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_EntitlementUpdate__FieldAccessorTable; }
    }
    
    public const int EntitlementFieldNumber = 1;
    private bool hasEntitlement;
    private global::D3.Store.ProductEntitlement entitlement_;
    public bool HasEntitlement {
      get { return hasEntitlement; }
    }
    public global::D3.Store.ProductEntitlement Entitlement {
      get { return entitlement_ ?? global::D3.Store.ProductEntitlement.DefaultInstance; }
    }
    
    public const int ExpireTimeFieldNumber = 2;
    private bool hasExpireTime;
    private long expireTime_;
    public bool HasExpireTime {
      get { return hasExpireTime; }
    }
    public long ExpireTime {
      get { return expireTime_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _entitlementUpdateFieldNames;
      if (hasEntitlement) {
        output.WriteMessage(1, field_names[0], Entitlement);
      }
      if (hasExpireTime) {
        output.WriteInt64(2, field_names[1], ExpireTime);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasEntitlement) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Entitlement);
        }
        if (hasExpireTime) {
          size += pb::CodedOutputStream.ComputeInt64Size(2, ExpireTime);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static EntitlementUpdate ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EntitlementUpdate ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EntitlementUpdate ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EntitlementUpdate ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EntitlementUpdate ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EntitlementUpdate ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EntitlementUpdate ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EntitlementUpdate ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EntitlementUpdate ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EntitlementUpdate ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EntitlementUpdate MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EntitlementUpdate prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<EntitlementUpdate, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EntitlementUpdate cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EntitlementUpdate result;
      
      private EntitlementUpdate PrepareBuilder() {
        if (resultIsReadOnly) {
          EntitlementUpdate original = result;
          result = new EntitlementUpdate();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EntitlementUpdate MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.EntitlementUpdate.Descriptor; }
      }
      
      public override EntitlementUpdate DefaultInstanceForType {
        get { return global::D3.Store.EntitlementUpdate.DefaultInstance; }
      }
      
      public override EntitlementUpdate BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EntitlementUpdate) {
          return MergeFrom((EntitlementUpdate) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EntitlementUpdate other) {
        if (other == global::D3.Store.EntitlementUpdate.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasEntitlement) {
          MergeEntitlement(other.Entitlement);
        }
        if (other.HasExpireTime) {
          ExpireTime = other.ExpireTime;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_entitlementUpdateFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _entitlementUpdateFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.Store.ProductEntitlement.Builder subBuilder = global::D3.Store.ProductEntitlement.CreateBuilder();
              if (result.hasEntitlement) {
                subBuilder.MergeFrom(Entitlement);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Entitlement = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              result.hasExpireTime = input.ReadInt64(ref result.expireTime_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasEntitlement {
       get { return result.hasEntitlement; }
      }
      public global::D3.Store.ProductEntitlement Entitlement {
        get { return result.Entitlement; }
        set { SetEntitlement(value); }
      }
      public Builder SetEntitlement(global::D3.Store.ProductEntitlement value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasEntitlement = true;
        result.entitlement_ = value;
        return this;
      }
      public Builder SetEntitlement(global::D3.Store.ProductEntitlement.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasEntitlement = true;
        result.entitlement_ = builderForValue.Build();
        return this;
      }
      public Builder MergeEntitlement(global::D3.Store.ProductEntitlement value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasEntitlement &&
            result.entitlement_ != global::D3.Store.ProductEntitlement.DefaultInstance) {
            result.entitlement_ = global::D3.Store.ProductEntitlement.CreateBuilder(result.entitlement_).MergeFrom(value).BuildPartial();
        } else {
          result.entitlement_ = value;
        }
        result.hasEntitlement = true;
        return this;
      }
      public Builder ClearEntitlement() {
        PrepareBuilder();
        result.hasEntitlement = false;
        result.entitlement_ = null;
        return this;
      }
      
      public bool HasExpireTime {
        get { return result.hasExpireTime; }
      }
      public long ExpireTime {
        get { return result.ExpireTime; }
        set { SetExpireTime(value); }
      }
      public Builder SetExpireTime(long value) {
        PrepareBuilder();
        result.hasExpireTime = true;
        result.expireTime_ = value;
        return this;
      }
      public Builder ClearExpireTime() {
        PrepareBuilder();
        result.hasExpireTime = false;
        result.expireTime_ = 0L;
        return this;
      }
    }
    static EntitlementUpdate() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class OrderStatus : pb::GeneratedMessage<OrderStatus, OrderStatus.Builder> {
    private OrderStatus() { }
    private static readonly OrderStatus defaultInstance = new OrderStatus().MakeReadOnly();
    private static readonly string[] _orderStatusFieldNames = new string[] { "creation_time", "limited_entitlements", "order", "product_id" };
    private static readonly uint[] _orderStatusFieldTags = new uint[] { 32, 26, 10, 40 };
    public static OrderStatus DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override OrderStatus DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override OrderStatus ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_OrderStatus__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<OrderStatus, OrderStatus.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_OrderStatus__FieldAccessorTable; }
    }
    
    public const int OrderFieldNumber = 1;
    private bool hasOrder;
    private global::D3.Store.Order order_;
    public bool HasOrder {
      get { return hasOrder; }
    }
    public global::D3.Store.Order Order {
      get { return order_ ?? global::D3.Store.Order.DefaultInstance; }
    }
    
    public const int LimitedEntitlementsFieldNumber = 3;
    private pbc::PopsicleList<global::D3.Store.EntitlementUpdate> limitedEntitlements_ = new pbc::PopsicleList<global::D3.Store.EntitlementUpdate>();
    public scg::IList<global::D3.Store.EntitlementUpdate> LimitedEntitlementsList {
      get { return limitedEntitlements_; }
    }
    public int LimitedEntitlementsCount {
      get { return limitedEntitlements_.Count; }
    }
    public global::D3.Store.EntitlementUpdate GetLimitedEntitlements(int index) {
      return limitedEntitlements_[index];
    }
    
    public const int CreationTimeFieldNumber = 4;
    private bool hasCreationTime;
    private long creationTime_;
    public bool HasCreationTime {
      get { return hasCreationTime; }
    }
    public long CreationTime {
      get { return creationTime_; }
    }
    
    public const int ProductIdFieldNumber = 5;
    private bool hasProductId;
    private uint productId_;
    public bool HasProductId {
      get { return hasProductId; }
    }
    public uint ProductId {
      get { return productId_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _orderStatusFieldNames;
      if (hasOrder) {
        output.WriteMessage(1, field_names[2], Order);
      }
      if (limitedEntitlements_.Count > 0) {
        output.WriteMessageArray(3, field_names[1], limitedEntitlements_);
      }
      if (hasCreationTime) {
        output.WriteSInt64(4, field_names[0], CreationTime);
      }
      if (hasProductId) {
        output.WriteUInt32(5, field_names[3], ProductId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasOrder) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Order);
        }
        foreach (global::D3.Store.EntitlementUpdate element in LimitedEntitlementsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, element);
        }
        if (hasCreationTime) {
          size += pb::CodedOutputStream.ComputeSInt64Size(4, CreationTime);
        }
        if (hasProductId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(5, ProductId);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static OrderStatus ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OrderStatus ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OrderStatus ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OrderStatus ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OrderStatus ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OrderStatus ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static OrderStatus ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static OrderStatus ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static OrderStatus ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OrderStatus ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private OrderStatus MakeReadOnly() {
      limitedEntitlements_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(OrderStatus prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<OrderStatus, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(OrderStatus cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private OrderStatus result;
      
      private OrderStatus PrepareBuilder() {
        if (resultIsReadOnly) {
          OrderStatus original = result;
          result = new OrderStatus();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override OrderStatus MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.OrderStatus.Descriptor; }
      }
      
      public override OrderStatus DefaultInstanceForType {
        get { return global::D3.Store.OrderStatus.DefaultInstance; }
      }
      
      public override OrderStatus BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is OrderStatus) {
          return MergeFrom((OrderStatus) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(OrderStatus other) {
        if (other == global::D3.Store.OrderStatus.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasOrder) {
          MergeOrder(other.Order);
        }
        if (other.limitedEntitlements_.Count != 0) {
          result.limitedEntitlements_.Add(other.limitedEntitlements_);
        }
        if (other.HasCreationTime) {
          CreationTime = other.CreationTime;
        }
        if (other.HasProductId) {
          ProductId = other.ProductId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_orderStatusFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _orderStatusFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.Store.Order.Builder subBuilder = global::D3.Store.Order.CreateBuilder();
              if (result.hasOrder) {
                subBuilder.MergeFrom(Order);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Order = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.limitedEntitlements_, global::D3.Store.EntitlementUpdate.DefaultInstance, extensionRegistry);
              break;
            }
            case 32: {
              result.hasCreationTime = input.ReadSInt64(ref result.creationTime_);
              break;
            }
            case 40: {
              result.hasProductId = input.ReadUInt32(ref result.productId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasOrder {
       get { return result.hasOrder; }
      }
      public global::D3.Store.Order Order {
        get { return result.Order; }
        set { SetOrder(value); }
      }
      public Builder SetOrder(global::D3.Store.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOrder = true;
        result.order_ = value;
        return this;
      }
      public Builder SetOrder(global::D3.Store.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasOrder = true;
        result.order_ = builderForValue.Build();
        return this;
      }
      public Builder MergeOrder(global::D3.Store.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasOrder &&
            result.order_ != global::D3.Store.Order.DefaultInstance) {
            result.order_ = global::D3.Store.Order.CreateBuilder(result.order_).MergeFrom(value).BuildPartial();
        } else {
          result.order_ = value;
        }
        result.hasOrder = true;
        return this;
      }
      public Builder ClearOrder() {
        PrepareBuilder();
        result.hasOrder = false;
        result.order_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Store.EntitlementUpdate> LimitedEntitlementsList {
        get { return PrepareBuilder().limitedEntitlements_; }
      }
      public int LimitedEntitlementsCount {
        get { return result.LimitedEntitlementsCount; }
      }
      public global::D3.Store.EntitlementUpdate GetLimitedEntitlements(int index) {
        return result.GetLimitedEntitlements(index);
      }
      public Builder SetLimitedEntitlements(int index, global::D3.Store.EntitlementUpdate value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.limitedEntitlements_[index] = value;
        return this;
      }
      public Builder SetLimitedEntitlements(int index, global::D3.Store.EntitlementUpdate.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.limitedEntitlements_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddLimitedEntitlements(global::D3.Store.EntitlementUpdate value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.limitedEntitlements_.Add(value);
        return this;
      }
      public Builder AddLimitedEntitlements(global::D3.Store.EntitlementUpdate.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.limitedEntitlements_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeLimitedEntitlements(scg::IEnumerable<global::D3.Store.EntitlementUpdate> values) {
        PrepareBuilder();
        result.limitedEntitlements_.Add(values);
        return this;
      }
      public Builder ClearLimitedEntitlements() {
        PrepareBuilder();
        result.limitedEntitlements_.Clear();
        return this;
      }
      
      public bool HasCreationTime {
        get { return result.hasCreationTime; }
      }
      public long CreationTime {
        get { return result.CreationTime; }
        set { SetCreationTime(value); }
      }
      public Builder SetCreationTime(long value) {
        PrepareBuilder();
        result.hasCreationTime = true;
        result.creationTime_ = value;
        return this;
      }
      public Builder ClearCreationTime() {
        PrepareBuilder();
        result.hasCreationTime = false;
        result.creationTime_ = 0;
        return this;
      }
      
      public bool HasProductId {
        get { return result.hasProductId; }
      }
      public uint ProductId {
        get { return result.ProductId; }
        set { SetProductId(value); }
      }
      public Builder SetProductId(uint value) {
        PrepareBuilder();
        result.hasProductId = true;
        result.productId_ = value;
        return this;
      }
      public Builder ClearProductId() {
        PrepareBuilder();
        result.hasProductId = false;
        result.productId_ = 0;
        return this;
      }
    }
    static OrderStatus() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class MissingEntitlement : pb::GeneratedMessage<MissingEntitlement, MissingEntitlement.Builder> {
    private MissingEntitlement() { }
    private static readonly MissingEntitlement defaultInstance = new MissingEntitlement().MakeReadOnly();
    private static readonly string[] _missingEntitlementFieldNames = new string[] { "acknowledge_id", "definition", "expired" };
    private static readonly uint[] _missingEntitlementFieldTags = new uint[] { 16, 10, 24 };
    public static MissingEntitlement DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override MissingEntitlement DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override MissingEntitlement ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_MissingEntitlement__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<MissingEntitlement, MissingEntitlement.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_MissingEntitlement__FieldAccessorTable; }
    }
    
    public const int DefinitionFieldNumber = 1;
    private bool hasDefinition;
    private global::D3.Store.ProductEntitlement definition_;
    public bool HasDefinition {
      get { return hasDefinition; }
    }
    public global::D3.Store.ProductEntitlement Definition {
      get { return definition_ ?? global::D3.Store.ProductEntitlement.DefaultInstance; }
    }
    
    public const int AcknowledgeIdFieldNumber = 2;
    private bool hasAcknowledgeId;
    private ulong acknowledgeId_;
    public bool HasAcknowledgeId {
      get { return hasAcknowledgeId; }
    }
    public ulong AcknowledgeId {
      get { return acknowledgeId_; }
    }
    
    public const int ExpiredFieldNumber = 3;
    private bool hasExpired;
    private bool expired_;
    public bool HasExpired {
      get { return hasExpired; }
    }
    public bool Expired {
      get { return expired_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _missingEntitlementFieldNames;
      if (hasDefinition) {
        output.WriteMessage(1, field_names[1], Definition);
      }
      if (hasAcknowledgeId) {
        output.WriteUInt64(2, field_names[0], AcknowledgeId);
      }
      if (hasExpired) {
        output.WriteBool(3, field_names[2], Expired);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasDefinition) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Definition);
        }
        if (hasAcknowledgeId) {
          size += pb::CodedOutputStream.ComputeUInt64Size(2, AcknowledgeId);
        }
        if (hasExpired) {
          size += pb::CodedOutputStream.ComputeBoolSize(3, Expired);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static MissingEntitlement ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MissingEntitlement ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MissingEntitlement ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MissingEntitlement ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MissingEntitlement ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MissingEntitlement ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static MissingEntitlement ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static MissingEntitlement ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static MissingEntitlement ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MissingEntitlement ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private MissingEntitlement MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(MissingEntitlement prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<MissingEntitlement, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(MissingEntitlement cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MissingEntitlement result;
      
      private MissingEntitlement PrepareBuilder() {
        if (resultIsReadOnly) {
          MissingEntitlement original = result;
          result = new MissingEntitlement();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override MissingEntitlement MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.MissingEntitlement.Descriptor; }
      }
      
      public override MissingEntitlement DefaultInstanceForType {
        get { return global::D3.Store.MissingEntitlement.DefaultInstance; }
      }
      
      public override MissingEntitlement BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is MissingEntitlement) {
          return MergeFrom((MissingEntitlement) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(MissingEntitlement other) {
        if (other == global::D3.Store.MissingEntitlement.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasDefinition) {
          MergeDefinition(other.Definition);
        }
        if (other.HasAcknowledgeId) {
          AcknowledgeId = other.AcknowledgeId;
        }
        if (other.HasExpired) {
          Expired = other.Expired;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_missingEntitlementFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _missingEntitlementFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.Store.ProductEntitlement.Builder subBuilder = global::D3.Store.ProductEntitlement.CreateBuilder();
              if (result.hasDefinition) {
                subBuilder.MergeFrom(Definition);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Definition = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              result.hasAcknowledgeId = input.ReadUInt64(ref result.acknowledgeId_);
              break;
            }
            case 24: {
              result.hasExpired = input.ReadBool(ref result.expired_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasDefinition {
       get { return result.hasDefinition; }
      }
      public global::D3.Store.ProductEntitlement Definition {
        get { return result.Definition; }
        set { SetDefinition(value); }
      }
      public Builder SetDefinition(global::D3.Store.ProductEntitlement value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDefinition = true;
        result.definition_ = value;
        return this;
      }
      public Builder SetDefinition(global::D3.Store.ProductEntitlement.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasDefinition = true;
        result.definition_ = builderForValue.Build();
        return this;
      }
      public Builder MergeDefinition(global::D3.Store.ProductEntitlement value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasDefinition &&
            result.definition_ != global::D3.Store.ProductEntitlement.DefaultInstance) {
            result.definition_ = global::D3.Store.ProductEntitlement.CreateBuilder(result.definition_).MergeFrom(value).BuildPartial();
        } else {
          result.definition_ = value;
        }
        result.hasDefinition = true;
        return this;
      }
      public Builder ClearDefinition() {
        PrepareBuilder();
        result.hasDefinition = false;
        result.definition_ = null;
        return this;
      }
      
      public bool HasAcknowledgeId {
        get { return result.hasAcknowledgeId; }
      }
      public ulong AcknowledgeId {
        get { return result.AcknowledgeId; }
        set { SetAcknowledgeId(value); }
      }
      public Builder SetAcknowledgeId(ulong value) {
        PrepareBuilder();
        result.hasAcknowledgeId = true;
        result.acknowledgeId_ = value;
        return this;
      }
      public Builder ClearAcknowledgeId() {
        PrepareBuilder();
        result.hasAcknowledgeId = false;
        result.acknowledgeId_ = 0UL;
        return this;
      }
      
      public bool HasExpired {
        get { return result.hasExpired; }
      }
      public bool Expired {
        get { return result.Expired; }
        set { SetExpired(value); }
      }
      public Builder SetExpired(bool value) {
        PrepareBuilder();
        result.hasExpired = true;
        result.expired_ = value;
        return this;
      }
      public Builder ClearExpired() {
        PrepareBuilder();
        result.hasExpired = false;
        result.expired_ = false;
        return this;
      }
    }
    static MissingEntitlement() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class MissingEntitlements : pb::GeneratedMessage<MissingEntitlements, MissingEntitlements.Builder> {
    private MissingEntitlements() { }
    private static readonly MissingEntitlements defaultInstance = new MissingEntitlements().MakeReadOnly();
    private static readonly string[] _missingEntitlementsFieldNames = new string[] { "entitlement" };
    private static readonly uint[] _missingEntitlementsFieldTags = new uint[] { 10 };
    public static MissingEntitlements DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override MissingEntitlements DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override MissingEntitlements ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_MissingEntitlements__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<MissingEntitlements, MissingEntitlements.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_MissingEntitlements__FieldAccessorTable; }
    }
    
    public const int EntitlementFieldNumber = 1;
    private pbc::PopsicleList<global::D3.Store.MissingEntitlement> entitlement_ = new pbc::PopsicleList<global::D3.Store.MissingEntitlement>();
    public scg::IList<global::D3.Store.MissingEntitlement> EntitlementList {
      get { return entitlement_; }
    }
    public int EntitlementCount {
      get { return entitlement_.Count; }
    }
    public global::D3.Store.MissingEntitlement GetEntitlement(int index) {
      return entitlement_[index];
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _missingEntitlementsFieldNames;
      if (entitlement_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], entitlement_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::D3.Store.MissingEntitlement element in EntitlementList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static MissingEntitlements ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MissingEntitlements ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MissingEntitlements ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MissingEntitlements ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MissingEntitlements ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MissingEntitlements ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static MissingEntitlements ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static MissingEntitlements ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static MissingEntitlements ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MissingEntitlements ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private MissingEntitlements MakeReadOnly() {
      entitlement_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(MissingEntitlements prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<MissingEntitlements, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(MissingEntitlements cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MissingEntitlements result;
      
      private MissingEntitlements PrepareBuilder() {
        if (resultIsReadOnly) {
          MissingEntitlements original = result;
          result = new MissingEntitlements();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override MissingEntitlements MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.MissingEntitlements.Descriptor; }
      }
      
      public override MissingEntitlements DefaultInstanceForType {
        get { return global::D3.Store.MissingEntitlements.DefaultInstance; }
      }
      
      public override MissingEntitlements BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is MissingEntitlements) {
          return MergeFrom((MissingEntitlements) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(MissingEntitlements other) {
        if (other == global::D3.Store.MissingEntitlements.DefaultInstance) return this;
        PrepareBuilder();
        if (other.entitlement_.Count != 0) {
          result.entitlement_.Add(other.entitlement_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_missingEntitlementsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _missingEntitlementsFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.entitlement_, global::D3.Store.MissingEntitlement.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::D3.Store.MissingEntitlement> EntitlementList {
        get { return PrepareBuilder().entitlement_; }
      }
      public int EntitlementCount {
        get { return result.EntitlementCount; }
      }
      public global::D3.Store.MissingEntitlement GetEntitlement(int index) {
        return result.GetEntitlement(index);
      }
      public Builder SetEntitlement(int index, global::D3.Store.MissingEntitlement value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.entitlement_[index] = value;
        return this;
      }
      public Builder SetEntitlement(int index, global::D3.Store.MissingEntitlement.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.entitlement_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddEntitlement(global::D3.Store.MissingEntitlement value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.entitlement_.Add(value);
        return this;
      }
      public Builder AddEntitlement(global::D3.Store.MissingEntitlement.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.entitlement_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeEntitlement(scg::IEnumerable<global::D3.Store.MissingEntitlement> values) {
        PrepareBuilder();
        result.entitlement_.Add(values);
        return this;
      }
      public Builder ClearEntitlement() {
        PrepareBuilder();
        result.entitlement_.Clear();
        return this;
      }
    }
    static MissingEntitlements() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class AcknowledgeOrder : pb::GeneratedMessage<AcknowledgeOrder, AcknowledgeOrder.Builder> {
    private AcknowledgeOrder() { }
    private static readonly AcknowledgeOrder defaultInstance = new AcknowledgeOrder().MakeReadOnly();
    private static readonly string[] _acknowledgeOrderFieldNames = new string[] { "error_code", "transaction_id" };
    private static readonly uint[] _acknowledgeOrderFieldTags = new uint[] { 16, 8 };
    public static AcknowledgeOrder DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AcknowledgeOrder DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AcknowledgeOrder ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_AcknowledgeOrder__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<AcknowledgeOrder, AcknowledgeOrder.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_AcknowledgeOrder__FieldAccessorTable; }
    }
    
    public const int TransactionIdFieldNumber = 1;
    private bool hasTransactionId;
    private ulong transactionId_;
    public bool HasTransactionId {
      get { return hasTransactionId; }
    }
    public ulong TransactionId {
      get { return transactionId_; }
    }
    
    public const int ErrorCodeFieldNumber = 2;
    private bool hasErrorCode;
    private uint errorCode_;
    public bool HasErrorCode {
      get { return hasErrorCode; }
    }
    public uint ErrorCode {
      get { return errorCode_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _acknowledgeOrderFieldNames;
      if (hasTransactionId) {
        output.WriteUInt64(1, field_names[1], TransactionId);
      }
      if (hasErrorCode) {
        output.WriteUInt32(2, field_names[0], ErrorCode);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasTransactionId) {
          size += pb::CodedOutputStream.ComputeUInt64Size(1, TransactionId);
        }
        if (hasErrorCode) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, ErrorCode);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static AcknowledgeOrder ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AcknowledgeOrder ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AcknowledgeOrder ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AcknowledgeOrder ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AcknowledgeOrder ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AcknowledgeOrder ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AcknowledgeOrder ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AcknowledgeOrder ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AcknowledgeOrder ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AcknowledgeOrder ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AcknowledgeOrder MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AcknowledgeOrder prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<AcknowledgeOrder, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AcknowledgeOrder cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AcknowledgeOrder result;
      
      private AcknowledgeOrder PrepareBuilder() {
        if (resultIsReadOnly) {
          AcknowledgeOrder original = result;
          result = new AcknowledgeOrder();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AcknowledgeOrder MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.AcknowledgeOrder.Descriptor; }
      }
      
      public override AcknowledgeOrder DefaultInstanceForType {
        get { return global::D3.Store.AcknowledgeOrder.DefaultInstance; }
      }
      
      public override AcknowledgeOrder BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is AcknowledgeOrder) {
          return MergeFrom((AcknowledgeOrder) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AcknowledgeOrder other) {
        if (other == global::D3.Store.AcknowledgeOrder.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasTransactionId) {
          TransactionId = other.TransactionId;
        }
        if (other.HasErrorCode) {
          ErrorCode = other.ErrorCode;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_acknowledgeOrderFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _acknowledgeOrderFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasTransactionId = input.ReadUInt64(ref result.transactionId_);
              break;
            }
            case 16: {
              result.hasErrorCode = input.ReadUInt32(ref result.errorCode_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasTransactionId {
        get { return result.hasTransactionId; }
      }
      public ulong TransactionId {
        get { return result.TransactionId; }
        set { SetTransactionId(value); }
      }
      public Builder SetTransactionId(ulong value) {
        PrepareBuilder();
        result.hasTransactionId = true;
        result.transactionId_ = value;
        return this;
      }
      public Builder ClearTransactionId() {
        PrepareBuilder();
        result.hasTransactionId = false;
        result.transactionId_ = 0UL;
        return this;
      }
      
      public bool HasErrorCode {
        get { return result.hasErrorCode; }
      }
      public uint ErrorCode {
        get { return result.ErrorCode; }
        set { SetErrorCode(value); }
      }
      public Builder SetErrorCode(uint value) {
        PrepareBuilder();
        result.hasErrorCode = true;
        result.errorCode_ = value;
        return this;
      }
      public Builder ClearErrorCode() {
        PrepareBuilder();
        result.hasErrorCode = false;
        result.errorCode_ = 0;
        return this;
      }
    }
    static AcknowledgeOrder() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class AcknowledgeMissingLicenses : pb::GeneratedMessage<AcknowledgeMissingLicenses, AcknowledgeMissingLicenses.Builder> {
    private AcknowledgeMissingLicenses() { }
    private static readonly AcknowledgeMissingLicenses defaultInstance = new AcknowledgeMissingLicenses().MakeReadOnly();
    private static readonly string[] _acknowledgeMissingLicensesFieldNames = new string[] { "acknowledge_id" };
    private static readonly uint[] _acknowledgeMissingLicensesFieldTags = new uint[] { 8 };
    public static AcknowledgeMissingLicenses DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AcknowledgeMissingLicenses DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AcknowledgeMissingLicenses ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_AcknowledgeMissingLicenses__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<AcknowledgeMissingLicenses, AcknowledgeMissingLicenses.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_AcknowledgeMissingLicenses__FieldAccessorTable; }
    }
    
    public const int AcknowledgeIdFieldNumber = 1;
    private pbc::PopsicleList<ulong> acknowledgeId_ = new pbc::PopsicleList<ulong>();
    public scg::IList<ulong> AcknowledgeIdList {
      get { return pbc::Lists.AsReadOnly(acknowledgeId_); }
    }
    public int AcknowledgeIdCount {
      get { return acknowledgeId_.Count; }
    }
    public ulong GetAcknowledgeId(int index) {
      return acknowledgeId_[index];
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _acknowledgeMissingLicensesFieldNames;
      if (acknowledgeId_.Count > 0) {
        output.WriteUInt64Array(1, field_names[0], acknowledgeId_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        {
          int dataSize = 0;
          foreach (ulong element in AcknowledgeIdList) {
            dataSize += pb::CodedOutputStream.ComputeUInt64SizeNoTag(element);
          }
          size += dataSize;
          size += 1 * acknowledgeId_.Count;
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static AcknowledgeMissingLicenses ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AcknowledgeMissingLicenses ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AcknowledgeMissingLicenses ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AcknowledgeMissingLicenses ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AcknowledgeMissingLicenses ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AcknowledgeMissingLicenses ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AcknowledgeMissingLicenses ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AcknowledgeMissingLicenses ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AcknowledgeMissingLicenses ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AcknowledgeMissingLicenses ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AcknowledgeMissingLicenses MakeReadOnly() {
      acknowledgeId_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AcknowledgeMissingLicenses prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<AcknowledgeMissingLicenses, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AcknowledgeMissingLicenses cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AcknowledgeMissingLicenses result;
      
      private AcknowledgeMissingLicenses PrepareBuilder() {
        if (resultIsReadOnly) {
          AcknowledgeMissingLicenses original = result;
          result = new AcknowledgeMissingLicenses();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AcknowledgeMissingLicenses MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.AcknowledgeMissingLicenses.Descriptor; }
      }
      
      public override AcknowledgeMissingLicenses DefaultInstanceForType {
        get { return global::D3.Store.AcknowledgeMissingLicenses.DefaultInstance; }
      }
      
      public override AcknowledgeMissingLicenses BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is AcknowledgeMissingLicenses) {
          return MergeFrom((AcknowledgeMissingLicenses) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AcknowledgeMissingLicenses other) {
        if (other == global::D3.Store.AcknowledgeMissingLicenses.DefaultInstance) return this;
        PrepareBuilder();
        if (other.acknowledgeId_.Count != 0) {
          result.acknowledgeId_.Add(other.acknowledgeId_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_acknowledgeMissingLicensesFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _acknowledgeMissingLicensesFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10:
            case 8: {
              input.ReadUInt64Array(tag, field_name, result.acknowledgeId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<ulong> AcknowledgeIdList {
        get { return PrepareBuilder().acknowledgeId_; }
      }
      public int AcknowledgeIdCount {
        get { return result.AcknowledgeIdCount; }
      }
      public ulong GetAcknowledgeId(int index) {
        return result.GetAcknowledgeId(index);
      }
      public Builder SetAcknowledgeId(int index, ulong value) {
        PrepareBuilder();
        result.acknowledgeId_[index] = value;
        return this;
      }
      public Builder AddAcknowledgeId(ulong value) {
        PrepareBuilder();
        result.acknowledgeId_.Add(value);
        return this;
      }
      public Builder AddRangeAcknowledgeId(scg::IEnumerable<ulong> values) {
        PrepareBuilder();
        result.acknowledgeId_.Add(values);
        return this;
      }
      public Builder ClearAcknowledgeId() {
        PrepareBuilder();
        result.acknowledgeId_.Clear();
        return this;
      }
    }
    static AcknowledgeMissingLicenses() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class AcknowledgeOrderResponse : pb::GeneratedMessage<AcknowledgeOrderResponse, AcknowledgeOrderResponse.Builder> {
    private AcknowledgeOrderResponse() { }
    private static readonly AcknowledgeOrderResponse defaultInstance = new AcknowledgeOrderResponse().MakeReadOnly();
    private static readonly string[] _acknowledgeOrderResponseFieldNames = new string[] {  };
    private static readonly uint[] _acknowledgeOrderResponseFieldTags = new uint[] {  };
    public static AcknowledgeOrderResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AcknowledgeOrderResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AcknowledgeOrderResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_AcknowledgeOrderResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<AcknowledgeOrderResponse, AcknowledgeOrderResponse.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_AcknowledgeOrderResponse__FieldAccessorTable; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _acknowledgeOrderResponseFieldNames;
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static AcknowledgeOrderResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AcknowledgeOrderResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AcknowledgeOrderResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AcknowledgeOrderResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AcknowledgeOrderResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AcknowledgeOrderResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AcknowledgeOrderResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AcknowledgeOrderResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AcknowledgeOrderResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AcknowledgeOrderResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AcknowledgeOrderResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AcknowledgeOrderResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<AcknowledgeOrderResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AcknowledgeOrderResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AcknowledgeOrderResponse result;
      
      private AcknowledgeOrderResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          AcknowledgeOrderResponse original = result;
          result = new AcknowledgeOrderResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AcknowledgeOrderResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.AcknowledgeOrderResponse.Descriptor; }
      }
      
      public override AcknowledgeOrderResponse DefaultInstanceForType {
        get { return global::D3.Store.AcknowledgeOrderResponse.DefaultInstance; }
      }
      
      public override AcknowledgeOrderResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is AcknowledgeOrderResponse) {
          return MergeFrom((AcknowledgeOrderResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AcknowledgeOrderResponse other) {
        if (other == global::D3.Store.AcknowledgeOrderResponse.DefaultInstance) return this;
        PrepareBuilder();
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_acknowledgeOrderResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _acknowledgeOrderResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
    }
    static AcknowledgeOrderResponse() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class CheckOrderStatus : pb::GeneratedMessage<CheckOrderStatus, CheckOrderStatus.Builder> {
    private CheckOrderStatus() { }
    private static readonly CheckOrderStatus defaultInstance = new CheckOrderStatus().MakeReadOnly();
    private static readonly string[] _checkOrderStatusFieldNames = new string[] { "transaction_id" };
    private static readonly uint[] _checkOrderStatusFieldTags = new uint[] { 8 };
    public static CheckOrderStatus DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override CheckOrderStatus DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override CheckOrderStatus ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_CheckOrderStatus__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<CheckOrderStatus, CheckOrderStatus.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_CheckOrderStatus__FieldAccessorTable; }
    }
    
    public const int TransactionIdFieldNumber = 1;
    private bool hasTransactionId;
    private ulong transactionId_;
    public bool HasTransactionId {
      get { return hasTransactionId; }
    }
    public ulong TransactionId {
      get { return transactionId_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _checkOrderStatusFieldNames;
      if (hasTransactionId) {
        output.WriteUInt64(1, field_names[0], TransactionId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasTransactionId) {
          size += pb::CodedOutputStream.ComputeUInt64Size(1, TransactionId);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static CheckOrderStatus ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CheckOrderStatus ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CheckOrderStatus ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CheckOrderStatus ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CheckOrderStatus ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CheckOrderStatus ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static CheckOrderStatus ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static CheckOrderStatus ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static CheckOrderStatus ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CheckOrderStatus ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private CheckOrderStatus MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(CheckOrderStatus prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<CheckOrderStatus, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(CheckOrderStatus cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private CheckOrderStatus result;
      
      private CheckOrderStatus PrepareBuilder() {
        if (resultIsReadOnly) {
          CheckOrderStatus original = result;
          result = new CheckOrderStatus();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override CheckOrderStatus MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.CheckOrderStatus.Descriptor; }
      }
      
      public override CheckOrderStatus DefaultInstanceForType {
        get { return global::D3.Store.CheckOrderStatus.DefaultInstance; }
      }
      
      public override CheckOrderStatus BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is CheckOrderStatus) {
          return MergeFrom((CheckOrderStatus) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(CheckOrderStatus other) {
        if (other == global::D3.Store.CheckOrderStatus.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasTransactionId) {
          TransactionId = other.TransactionId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_checkOrderStatusFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _checkOrderStatusFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasTransactionId = input.ReadUInt64(ref result.transactionId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasTransactionId {
        get { return result.hasTransactionId; }
      }
      public ulong TransactionId {
        get { return result.TransactionId; }
        set { SetTransactionId(value); }
      }
      public Builder SetTransactionId(ulong value) {
        PrepareBuilder();
        result.hasTransactionId = true;
        result.transactionId_ = value;
        return this;
      }
      public Builder ClearTransactionId() {
        PrepareBuilder();
        result.hasTransactionId = false;
        result.transactionId_ = 0UL;
        return this;
      }
    }
    static CheckOrderStatus() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class CheckOrderStatusResponse : pb::GeneratedMessage<CheckOrderStatusResponse, CheckOrderStatusResponse.Builder> {
    private CheckOrderStatusResponse() { }
    private static readonly CheckOrderStatusResponse defaultInstance = new CheckOrderStatusResponse().MakeReadOnly();
    private static readonly string[] _checkOrderStatusResponseFieldNames = new string[] { "transaction_id" };
    private static readonly uint[] _checkOrderStatusResponseFieldTags = new uint[] { 8 };
    public static CheckOrderStatusResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override CheckOrderStatusResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override CheckOrderStatusResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_CheckOrderStatusResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<CheckOrderStatusResponse, CheckOrderStatusResponse.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_CheckOrderStatusResponse__FieldAccessorTable; }
    }
    
    public const int TransactionIdFieldNumber = 1;
    private bool hasTransactionId;
    private ulong transactionId_;
    public bool HasTransactionId {
      get { return hasTransactionId; }
    }
    public ulong TransactionId {
      get { return transactionId_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _checkOrderStatusResponseFieldNames;
      if (hasTransactionId) {
        output.WriteUInt64(1, field_names[0], TransactionId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasTransactionId) {
          size += pb::CodedOutputStream.ComputeUInt64Size(1, TransactionId);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static CheckOrderStatusResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CheckOrderStatusResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CheckOrderStatusResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CheckOrderStatusResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CheckOrderStatusResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CheckOrderStatusResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static CheckOrderStatusResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static CheckOrderStatusResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static CheckOrderStatusResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CheckOrderStatusResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private CheckOrderStatusResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(CheckOrderStatusResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<CheckOrderStatusResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(CheckOrderStatusResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private CheckOrderStatusResponse result;
      
      private CheckOrderStatusResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          CheckOrderStatusResponse original = result;
          result = new CheckOrderStatusResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override CheckOrderStatusResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.CheckOrderStatusResponse.Descriptor; }
      }
      
      public override CheckOrderStatusResponse DefaultInstanceForType {
        get { return global::D3.Store.CheckOrderStatusResponse.DefaultInstance; }
      }
      
      public override CheckOrderStatusResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is CheckOrderStatusResponse) {
          return MergeFrom((CheckOrderStatusResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(CheckOrderStatusResponse other) {
        if (other == global::D3.Store.CheckOrderStatusResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasTransactionId) {
          TransactionId = other.TransactionId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_checkOrderStatusResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _checkOrderStatusResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasTransactionId = input.ReadUInt64(ref result.transactionId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasTransactionId {
        get { return result.hasTransactionId; }
      }
      public ulong TransactionId {
        get { return result.TransactionId; }
        set { SetTransactionId(value); }
      }
      public Builder SetTransactionId(ulong value) {
        PrepareBuilder();
        result.hasTransactionId = true;
        result.transactionId_ = value;
        return this;
      }
      public Builder ClearTransactionId() {
        PrepareBuilder();
        result.hasTransactionId = false;
        result.transactionId_ = 0UL;
        return this;
      }
    }
    static CheckOrderStatusResponse() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class StoreStatus : pb::GeneratedMessage<StoreStatus, StoreStatus.Builder> {
    private StoreStatus() { }
    private static readonly StoreStatus defaultInstance = new StoreStatus().MakeReadOnly();
    private static readonly string[] _storeStatusFieldNames = new string[] { "store_status", "store_status_changed_time" };
    private static readonly uint[] _storeStatusFieldTags = new uint[] { 8, 16 };
    public static StoreStatus DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override StoreStatus DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override StoreStatus ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_StoreStatus__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<StoreStatus, StoreStatus.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_StoreStatus__FieldAccessorTable; }
    }
    
    public const int StoreStatus_FieldNumber = 1;
    private bool hasStoreStatus_;
    private int storeStatus_;
    public bool HasStoreStatus_ {
      get { return hasStoreStatus_; }
    }
    public int StoreStatus_ {
      get { return storeStatus_; }
    }
    
    public const int StoreStatusChangedTimeFieldNumber = 2;
    private bool hasStoreStatusChangedTime;
    private ulong storeStatusChangedTime_;
    public bool HasStoreStatusChangedTime {
      get { return hasStoreStatusChangedTime; }
    }
    public ulong StoreStatusChangedTime {
      get { return storeStatusChangedTime_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _storeStatusFieldNames;
      if (hasStoreStatus_) {
        output.WriteInt32(1, field_names[0], StoreStatus_);
      }
      if (hasStoreStatusChangedTime) {
        output.WriteUInt64(2, field_names[1], StoreStatusChangedTime);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasStoreStatus_) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, StoreStatus_);
        }
        if (hasStoreStatusChangedTime) {
          size += pb::CodedOutputStream.ComputeUInt64Size(2, StoreStatusChangedTime);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static StoreStatus ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static StoreStatus ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static StoreStatus ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static StoreStatus ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static StoreStatus ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static StoreStatus ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static StoreStatus ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static StoreStatus ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static StoreStatus ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static StoreStatus ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private StoreStatus MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(StoreStatus prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<StoreStatus, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(StoreStatus cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private StoreStatus result;
      
      private StoreStatus PrepareBuilder() {
        if (resultIsReadOnly) {
          StoreStatus original = result;
          result = new StoreStatus();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override StoreStatus MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.StoreStatus.Descriptor; }
      }
      
      public override StoreStatus DefaultInstanceForType {
        get { return global::D3.Store.StoreStatus.DefaultInstance; }
      }
      
      public override StoreStatus BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is StoreStatus) {
          return MergeFrom((StoreStatus) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(StoreStatus other) {
        if (other == global::D3.Store.StoreStatus.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasStoreStatus_) {
          StoreStatus_ = other.StoreStatus_;
        }
        if (other.HasStoreStatusChangedTime) {
          StoreStatusChangedTime = other.StoreStatusChangedTime;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_storeStatusFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _storeStatusFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasStoreStatus_ = input.ReadInt32(ref result.storeStatus_);
              break;
            }
            case 16: {
              result.hasStoreStatusChangedTime = input.ReadUInt64(ref result.storeStatusChangedTime_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasStoreStatus_ {
        get { return result.hasStoreStatus_; }
      }
      public int StoreStatus_ {
        get { return result.StoreStatus_; }
        set { SetStoreStatus_(value); }
      }
      public Builder SetStoreStatus_(int value) {
        PrepareBuilder();
        result.hasStoreStatus_ = true;
        result.storeStatus_ = value;
        return this;
      }
      public Builder ClearStoreStatus_() {
        PrepareBuilder();
        result.hasStoreStatus_ = false;
        result.storeStatus_ = 0;
        return this;
      }
      
      public bool HasStoreStatusChangedTime {
        get { return result.hasStoreStatusChangedTime; }
      }
      public ulong StoreStatusChangedTime {
        get { return result.StoreStatusChangedTime; }
        set { SetStoreStatusChangedTime(value); }
      }
      public Builder SetStoreStatusChangedTime(ulong value) {
        PrepareBuilder();
        result.hasStoreStatusChangedTime = true;
        result.storeStatusChangedTime_ = value;
        return this;
      }
      public Builder ClearStoreStatusChangedTime() {
        PrepareBuilder();
        result.hasStoreStatusChangedTime = false;
        result.storeStatusChangedTime_ = 0UL;
        return this;
      }
    }
    static StoreStatus() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetBalance : pb::GeneratedMessage<GetBalance, GetBalance.Builder> {
    private GetBalance() { }
    private static readonly GetBalance defaultInstance = new GetBalance().MakeReadOnly();
    private static readonly string[] _getBalanceFieldNames = new string[] { "currency" };
    private static readonly uint[] _getBalanceFieldTags = new uint[] { 8 };
    public static GetBalance DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetBalance DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetBalance ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetBalance__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetBalance, GetBalance.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetBalance__FieldAccessorTable; }
    }
    
    public const int CurrencyFieldNumber = 1;
    private bool hasCurrency;
    private int currency_;
    public bool HasCurrency {
      get { return hasCurrency; }
    }
    public int Currency {
      get { return currency_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getBalanceFieldNames;
      if (hasCurrency) {
        output.WriteInt32(1, field_names[0], Currency);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCurrency) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, Currency);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetBalance ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetBalance ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetBalance ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetBalance ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetBalance ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetBalance ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetBalance ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetBalance ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetBalance ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetBalance ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetBalance MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetBalance prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetBalance, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetBalance cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetBalance result;
      
      private GetBalance PrepareBuilder() {
        if (resultIsReadOnly) {
          GetBalance original = result;
          result = new GetBalance();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetBalance MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetBalance.Descriptor; }
      }
      
      public override GetBalance DefaultInstanceForType {
        get { return global::D3.Store.GetBalance.DefaultInstance; }
      }
      
      public override GetBalance BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetBalance) {
          return MergeFrom((GetBalance) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetBalance other) {
        if (other == global::D3.Store.GetBalance.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCurrency) {
          Currency = other.Currency;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getBalanceFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getBalanceFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasCurrency = input.ReadInt32(ref result.currency_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCurrency {
        get { return result.hasCurrency; }
      }
      public int Currency {
        get { return result.Currency; }
        set { SetCurrency(value); }
      }
      public Builder SetCurrency(int value) {
        PrepareBuilder();
        result.hasCurrency = true;
        result.currency_ = value;
        return this;
      }
      public Builder ClearCurrency() {
        PrepareBuilder();
        result.hasCurrency = false;
        result.currency_ = 0;
        return this;
      }
    }
    static GetBalance() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetBalanceResponse : pb::GeneratedMessage<GetBalanceResponse, GetBalanceResponse.Builder> {
    private GetBalanceResponse() { }
    private static readonly GetBalanceResponse defaultInstance = new GetBalanceResponse().MakeReadOnly();
    private static readonly string[] _getBalanceResponseFieldNames = new string[] { "fixed_point_balance" };
    private static readonly uint[] _getBalanceResponseFieldTags = new uint[] { 16 };
    public static GetBalanceResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetBalanceResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetBalanceResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetBalanceResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetBalanceResponse, GetBalanceResponse.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetBalanceResponse__FieldAccessorTable; }
    }
    
    public const int FixedPointBalanceFieldNumber = 2;
    private bool hasFixedPointBalance;
    private long fixedPointBalance_;
    public bool HasFixedPointBalance {
      get { return hasFixedPointBalance; }
    }
    public long FixedPointBalance {
      get { return fixedPointBalance_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getBalanceResponseFieldNames;
      if (hasFixedPointBalance) {
        output.WriteInt64(2, field_names[0], FixedPointBalance);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasFixedPointBalance) {
          size += pb::CodedOutputStream.ComputeInt64Size(2, FixedPointBalance);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetBalanceResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetBalanceResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetBalanceResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetBalanceResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetBalanceResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetBalanceResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetBalanceResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetBalanceResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetBalanceResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetBalanceResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetBalanceResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetBalanceResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetBalanceResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetBalanceResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetBalanceResponse result;
      
      private GetBalanceResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          GetBalanceResponse original = result;
          result = new GetBalanceResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetBalanceResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetBalanceResponse.Descriptor; }
      }
      
      public override GetBalanceResponse DefaultInstanceForType {
        get { return global::D3.Store.GetBalanceResponse.DefaultInstance; }
      }
      
      public override GetBalanceResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetBalanceResponse) {
          return MergeFrom((GetBalanceResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetBalanceResponse other) {
        if (other == global::D3.Store.GetBalanceResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasFixedPointBalance) {
          FixedPointBalance = other.FixedPointBalance;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getBalanceResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getBalanceResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 16: {
              result.hasFixedPointBalance = input.ReadInt64(ref result.fixedPointBalance_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasFixedPointBalance {
        get { return result.hasFixedPointBalance; }
      }
      public long FixedPointBalance {
        get { return result.FixedPointBalance; }
        set { SetFixedPointBalance(value); }
      }
      public Builder SetFixedPointBalance(long value) {
        PrepareBuilder();
        result.hasFixedPointBalance = true;
        result.fixedPointBalance_ = value;
        return this;
      }
      public Builder ClearFixedPointBalance() {
        PrepareBuilder();
        result.hasFixedPointBalance = false;
        result.fixedPointBalance_ = 0L;
        return this;
      }
    }
    static GetBalanceResponse() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class InternalOrder : pb::GeneratedMessage<InternalOrder, InternalOrder.Builder> {
    private InternalOrder() { }
    private static readonly InternalOrder defaultInstance = new InternalOrder().MakeReadOnly();
    private static readonly string[] _internalOrderFieldNames = new string[] { "account_id", "bootstrap_time", "creation_time", "game_account_id", "order", "order_id", "product_id", "under_manual_review" };
    private static readonly uint[] _internalOrderFieldTags = new uint[] { 24, 72, 48, 32, 10, 18, 80, 64 };
    public static InternalOrder DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override InternalOrder DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override InternalOrder ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_InternalOrder__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<InternalOrder, InternalOrder.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_InternalOrder__FieldAccessorTable; }
    }
    
    public const int OrderFieldNumber = 1;
    private bool hasOrder;
    private global::D3.Store.Order order_;
    public bool HasOrder {
      get { return hasOrder; }
    }
    public global::D3.Store.Order Order {
      get { return order_ ?? global::D3.Store.Order.DefaultInstance; }
    }
    
    public const int OrderIdFieldNumber = 2;
    private bool hasOrderId;
    private string orderId_ = "";
    public bool HasOrderId {
      get { return hasOrderId; }
    }
    public string OrderId {
      get { return orderId_; }
    }
    
    public const int AccountIdFieldNumber = 3;
    private bool hasAccountId;
    private ulong accountId_;
    public bool HasAccountId {
      get { return hasAccountId; }
    }
    public ulong AccountId {
      get { return accountId_; }
    }
    
    public const int GameAccountIdFieldNumber = 4;
    private bool hasGameAccountId;
    private ulong gameAccountId_;
    public bool HasGameAccountId {
      get { return hasGameAccountId; }
    }
    public ulong GameAccountId {
      get { return gameAccountId_; }
    }
    
    public const int CreationTimeFieldNumber = 6;
    private bool hasCreationTime;
    private long creationTime_;
    public bool HasCreationTime {
      get { return hasCreationTime; }
    }
    public long CreationTime {
      get { return creationTime_; }
    }
    
    public const int UnderManualReviewFieldNumber = 8;
    private bool hasUnderManualReview;
    private bool underManualReview_;
    public bool HasUnderManualReview {
      get { return hasUnderManualReview; }
    }
    public bool UnderManualReview {
      get { return underManualReview_; }
    }
    
    public const int BootstrapTimeFieldNumber = 9;
    private bool hasBootstrapTime;
    private long bootstrapTime_;
    public bool HasBootstrapTime {
      get { return hasBootstrapTime; }
    }
    public long BootstrapTime {
      get { return bootstrapTime_; }
    }
    
    public const int ProductIdFieldNumber = 10;
    private bool hasProductId;
    private uint productId_;
    public bool HasProductId {
      get { return hasProductId; }
    }
    public uint ProductId {
      get { return productId_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _internalOrderFieldNames;
      if (hasOrder) {
        output.WriteMessage(1, field_names[4], Order);
      }
      if (hasOrderId) {
        output.WriteString(2, field_names[5], OrderId);
      }
      if (hasAccountId) {
        output.WriteUInt64(3, field_names[0], AccountId);
      }
      if (hasGameAccountId) {
        output.WriteUInt64(4, field_names[3], GameAccountId);
      }
      if (hasCreationTime) {
        output.WriteSInt64(6, field_names[2], CreationTime);
      }
      if (hasUnderManualReview) {
        output.WriteBool(8, field_names[7], UnderManualReview);
      }
      if (hasBootstrapTime) {
        output.WriteSInt64(9, field_names[1], BootstrapTime);
      }
      if (hasProductId) {
        output.WriteUInt32(10, field_names[6], ProductId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasOrder) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Order);
        }
        if (hasOrderId) {
          size += pb::CodedOutputStream.ComputeStringSize(2, OrderId);
        }
        if (hasAccountId) {
          size += pb::CodedOutputStream.ComputeUInt64Size(3, AccountId);
        }
        if (hasGameAccountId) {
          size += pb::CodedOutputStream.ComputeUInt64Size(4, GameAccountId);
        }
        if (hasCreationTime) {
          size += pb::CodedOutputStream.ComputeSInt64Size(6, CreationTime);
        }
        if (hasUnderManualReview) {
          size += pb::CodedOutputStream.ComputeBoolSize(8, UnderManualReview);
        }
        if (hasBootstrapTime) {
          size += pb::CodedOutputStream.ComputeSInt64Size(9, BootstrapTime);
        }
        if (hasProductId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(10, ProductId);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static InternalOrder ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static InternalOrder ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static InternalOrder ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static InternalOrder ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static InternalOrder ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static InternalOrder ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static InternalOrder ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static InternalOrder ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static InternalOrder ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static InternalOrder ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private InternalOrder MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(InternalOrder prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<InternalOrder, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(InternalOrder cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private InternalOrder result;
      
      private InternalOrder PrepareBuilder() {
        if (resultIsReadOnly) {
          InternalOrder original = result;
          result = new InternalOrder();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override InternalOrder MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.InternalOrder.Descriptor; }
      }
      
      public override InternalOrder DefaultInstanceForType {
        get { return global::D3.Store.InternalOrder.DefaultInstance; }
      }
      
      public override InternalOrder BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is InternalOrder) {
          return MergeFrom((InternalOrder) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(InternalOrder other) {
        if (other == global::D3.Store.InternalOrder.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasOrder) {
          MergeOrder(other.Order);
        }
        if (other.HasOrderId) {
          OrderId = other.OrderId;
        }
        if (other.HasAccountId) {
          AccountId = other.AccountId;
        }
        if (other.HasGameAccountId) {
          GameAccountId = other.GameAccountId;
        }
        if (other.HasCreationTime) {
          CreationTime = other.CreationTime;
        }
        if (other.HasUnderManualReview) {
          UnderManualReview = other.UnderManualReview;
        }
        if (other.HasBootstrapTime) {
          BootstrapTime = other.BootstrapTime;
        }
        if (other.HasProductId) {
          ProductId = other.ProductId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_internalOrderFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _internalOrderFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.Store.Order.Builder subBuilder = global::D3.Store.Order.CreateBuilder();
              if (result.hasOrder) {
                subBuilder.MergeFrom(Order);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Order = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              result.hasOrderId = input.ReadString(ref result.orderId_);
              break;
            }
            case 24: {
              result.hasAccountId = input.ReadUInt64(ref result.accountId_);
              break;
            }
            case 32: {
              result.hasGameAccountId = input.ReadUInt64(ref result.gameAccountId_);
              break;
            }
            case 48: {
              result.hasCreationTime = input.ReadSInt64(ref result.creationTime_);
              break;
            }
            case 64: {
              result.hasUnderManualReview = input.ReadBool(ref result.underManualReview_);
              break;
            }
            case 72: {
              result.hasBootstrapTime = input.ReadSInt64(ref result.bootstrapTime_);
              break;
            }
            case 80: {
              result.hasProductId = input.ReadUInt32(ref result.productId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasOrder {
       get { return result.hasOrder; }
      }
      public global::D3.Store.Order Order {
        get { return result.Order; }
        set { SetOrder(value); }
      }
      public Builder SetOrder(global::D3.Store.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOrder = true;
        result.order_ = value;
        return this;
      }
      public Builder SetOrder(global::D3.Store.Order.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasOrder = true;
        result.order_ = builderForValue.Build();
        return this;
      }
      public Builder MergeOrder(global::D3.Store.Order value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasOrder &&
            result.order_ != global::D3.Store.Order.DefaultInstance) {
            result.order_ = global::D3.Store.Order.CreateBuilder(result.order_).MergeFrom(value).BuildPartial();
        } else {
          result.order_ = value;
        }
        result.hasOrder = true;
        return this;
      }
      public Builder ClearOrder() {
        PrepareBuilder();
        result.hasOrder = false;
        result.order_ = null;
        return this;
      }
      
      public bool HasOrderId {
        get { return result.hasOrderId; }
      }
      public string OrderId {
        get { return result.OrderId; }
        set { SetOrderId(value); }
      }
      public Builder SetOrderId(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOrderId = true;
        result.orderId_ = value;
        return this;
      }
      public Builder ClearOrderId() {
        PrepareBuilder();
        result.hasOrderId = false;
        result.orderId_ = "";
        return this;
      }
      
      public bool HasAccountId {
        get { return result.hasAccountId; }
      }
      public ulong AccountId {
        get { return result.AccountId; }
        set { SetAccountId(value); }
      }
      public Builder SetAccountId(ulong value) {
        PrepareBuilder();
        result.hasAccountId = true;
        result.accountId_ = value;
        return this;
      }
      public Builder ClearAccountId() {
        PrepareBuilder();
        result.hasAccountId = false;
        result.accountId_ = 0UL;
        return this;
      }
      
      public bool HasGameAccountId {
        get { return result.hasGameAccountId; }
      }
      public ulong GameAccountId {
        get { return result.GameAccountId; }
        set { SetGameAccountId(value); }
      }
      public Builder SetGameAccountId(ulong value) {
        PrepareBuilder();
        result.hasGameAccountId = true;
        result.gameAccountId_ = value;
        return this;
      }
      public Builder ClearGameAccountId() {
        PrepareBuilder();
        result.hasGameAccountId = false;
        result.gameAccountId_ = 0UL;
        return this;
      }
      
      public bool HasCreationTime {
        get { return result.hasCreationTime; }
      }
      public long CreationTime {
        get { return result.CreationTime; }
        set { SetCreationTime(value); }
      }
      public Builder SetCreationTime(long value) {
        PrepareBuilder();
        result.hasCreationTime = true;
        result.creationTime_ = value;
        return this;
      }
      public Builder ClearCreationTime() {
        PrepareBuilder();
        result.hasCreationTime = false;
        result.creationTime_ = 0;
        return this;
      }
      
      public bool HasUnderManualReview {
        get { return result.hasUnderManualReview; }
      }
      public bool UnderManualReview {
        get { return result.UnderManualReview; }
        set { SetUnderManualReview(value); }
      }
      public Builder SetUnderManualReview(bool value) {
        PrepareBuilder();
        result.hasUnderManualReview = true;
        result.underManualReview_ = value;
        return this;
      }
      public Builder ClearUnderManualReview() {
        PrepareBuilder();
        result.hasUnderManualReview = false;
        result.underManualReview_ = false;
        return this;
      }
      
      public bool HasBootstrapTime {
        get { return result.hasBootstrapTime; }
      }
      public long BootstrapTime {
        get { return result.BootstrapTime; }
        set { SetBootstrapTime(value); }
      }
      public Builder SetBootstrapTime(long value) {
        PrepareBuilder();
        result.hasBootstrapTime = true;
        result.bootstrapTime_ = value;
        return this;
      }
      public Builder ClearBootstrapTime() {
        PrepareBuilder();
        result.hasBootstrapTime = false;
        result.bootstrapTime_ = 0;
        return this;
      }
      
      public bool HasProductId {
        get { return result.hasProductId; }
      }
      public uint ProductId {
        get { return result.ProductId; }
        set { SetProductId(value); }
      }
      public Builder SetProductId(uint value) {
        PrepareBuilder();
        result.hasProductId = true;
        result.productId_ = value;
        return this;
      }
      public Builder ClearProductId() {
        PrepareBuilder();
        result.hasProductId = false;
        result.productId_ = 0;
        return this;
      }
    }
    static InternalOrder() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class InternalProduct : pb::GeneratedMessage<InternalProduct, InternalProduct.Builder> {
    private InternalProduct() { }
    private static readonly InternalProduct defaultInstance = new InternalProduct().MakeReadOnly();
    private static readonly string[] _internalProductFieldNames = new string[] { "earliest_valid_version", "free_in_igr", "license_ids", "product" };
    private static readonly uint[] _internalProductFieldTags = new uint[] { 34, 24, 16, 10 };
    public static InternalProduct DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override InternalProduct DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override InternalProduct ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_InternalProduct__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<InternalProduct, InternalProduct.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_InternalProduct__FieldAccessorTable; }
    }
    
    public const int ProductFieldNumber = 1;
    private bool hasProduct;
    private global::D3.Store.Product product_;
    public bool HasProduct {
      get { return hasProduct; }
    }
    public global::D3.Store.Product Product {
      get { return product_ ?? global::D3.Store.Product.DefaultInstance; }
    }
    
    public const int LicenseIdsFieldNumber = 2;
    private pbc::PopsicleList<ulong> licenseIds_ = new pbc::PopsicleList<ulong>();
    public scg::IList<ulong> LicenseIdsList {
      get { return pbc::Lists.AsReadOnly(licenseIds_); }
    }
    public int LicenseIdsCount {
      get { return licenseIds_.Count; }
    }
    public ulong GetLicenseIds(int index) {
      return licenseIds_[index];
    }
    
    public const int FreeInIgrFieldNumber = 3;
    private bool hasFreeInIgr;
    private bool freeInIgr_;
    public bool HasFreeInIgr {
      get { return hasFreeInIgr; }
    }
    public bool FreeInIgr {
      get { return freeInIgr_; }
    }
    
    public const int EarliestValidVersionFieldNumber = 4;
    private bool hasEarliestValidVersion;
    private string earliestValidVersion_ = "";
    public bool HasEarliestValidVersion {
      get { return hasEarliestValidVersion; }
    }
    public string EarliestValidVersion {
      get { return earliestValidVersion_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _internalProductFieldNames;
      if (hasProduct) {
        output.WriteMessage(1, field_names[3], Product);
      }
      if (licenseIds_.Count > 0) {
        output.WriteUInt64Array(2, field_names[2], licenseIds_);
      }
      if (hasFreeInIgr) {
        output.WriteBool(3, field_names[1], FreeInIgr);
      }
      if (hasEarliestValidVersion) {
        output.WriteString(4, field_names[0], EarliestValidVersion);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasProduct) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Product);
        }
        {
          int dataSize = 0;
          foreach (ulong element in LicenseIdsList) {
            dataSize += pb::CodedOutputStream.ComputeUInt64SizeNoTag(element);
          }
          size += dataSize;
          size += 1 * licenseIds_.Count;
        }
        if (hasFreeInIgr) {
          size += pb::CodedOutputStream.ComputeBoolSize(3, FreeInIgr);
        }
        if (hasEarliestValidVersion) {
          size += pb::CodedOutputStream.ComputeStringSize(4, EarliestValidVersion);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static InternalProduct ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static InternalProduct ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static InternalProduct ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static InternalProduct ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static InternalProduct ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static InternalProduct ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static InternalProduct ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static InternalProduct ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static InternalProduct ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static InternalProduct ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private InternalProduct MakeReadOnly() {
      licenseIds_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(InternalProduct prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<InternalProduct, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(InternalProduct cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private InternalProduct result;
      
      private InternalProduct PrepareBuilder() {
        if (resultIsReadOnly) {
          InternalProduct original = result;
          result = new InternalProduct();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override InternalProduct MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.InternalProduct.Descriptor; }
      }
      
      public override InternalProduct DefaultInstanceForType {
        get { return global::D3.Store.InternalProduct.DefaultInstance; }
      }
      
      public override InternalProduct BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is InternalProduct) {
          return MergeFrom((InternalProduct) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(InternalProduct other) {
        if (other == global::D3.Store.InternalProduct.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasProduct) {
          MergeProduct(other.Product);
        }
        if (other.licenseIds_.Count != 0) {
          result.licenseIds_.Add(other.licenseIds_);
        }
        if (other.HasFreeInIgr) {
          FreeInIgr = other.FreeInIgr;
        }
        if (other.HasEarliestValidVersion) {
          EarliestValidVersion = other.EarliestValidVersion;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_internalProductFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _internalProductFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.Store.Product.Builder subBuilder = global::D3.Store.Product.CreateBuilder();
              if (result.hasProduct) {
                subBuilder.MergeFrom(Product);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Product = subBuilder.BuildPartial();
              break;
            }
            case 18:
            case 16: {
              input.ReadUInt64Array(tag, field_name, result.licenseIds_);
              break;
            }
            case 24: {
              result.hasFreeInIgr = input.ReadBool(ref result.freeInIgr_);
              break;
            }
            case 34: {
              result.hasEarliestValidVersion = input.ReadString(ref result.earliestValidVersion_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasProduct {
       get { return result.hasProduct; }
      }
      public global::D3.Store.Product Product {
        get { return result.Product; }
        set { SetProduct(value); }
      }
      public Builder SetProduct(global::D3.Store.Product value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasProduct = true;
        result.product_ = value;
        return this;
      }
      public Builder SetProduct(global::D3.Store.Product.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasProduct = true;
        result.product_ = builderForValue.Build();
        return this;
      }
      public Builder MergeProduct(global::D3.Store.Product value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasProduct &&
            result.product_ != global::D3.Store.Product.DefaultInstance) {
            result.product_ = global::D3.Store.Product.CreateBuilder(result.product_).MergeFrom(value).BuildPartial();
        } else {
          result.product_ = value;
        }
        result.hasProduct = true;
        return this;
      }
      public Builder ClearProduct() {
        PrepareBuilder();
        result.hasProduct = false;
        result.product_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<ulong> LicenseIdsList {
        get { return PrepareBuilder().licenseIds_; }
      }
      public int LicenseIdsCount {
        get { return result.LicenseIdsCount; }
      }
      public ulong GetLicenseIds(int index) {
        return result.GetLicenseIds(index);
      }
      public Builder SetLicenseIds(int index, ulong value) {
        PrepareBuilder();
        result.licenseIds_[index] = value;
        return this;
      }
      public Builder AddLicenseIds(ulong value) {
        PrepareBuilder();
        result.licenseIds_.Add(value);
        return this;
      }
      public Builder AddRangeLicenseIds(scg::IEnumerable<ulong> values) {
        PrepareBuilder();
        result.licenseIds_.Add(values);
        return this;
      }
      public Builder ClearLicenseIds() {
        PrepareBuilder();
        result.licenseIds_.Clear();
        return this;
      }
      
      public bool HasFreeInIgr {
        get { return result.hasFreeInIgr; }
      }
      public bool FreeInIgr {
        get { return result.FreeInIgr; }
        set { SetFreeInIgr(value); }
      }
      public Builder SetFreeInIgr(bool value) {
        PrepareBuilder();
        result.hasFreeInIgr = true;
        result.freeInIgr_ = value;
        return this;
      }
      public Builder ClearFreeInIgr() {
        PrepareBuilder();
        result.hasFreeInIgr = false;
        result.freeInIgr_ = false;
        return this;
      }
      
      public bool HasEarliestValidVersion {
        get { return result.hasEarliestValidVersion; }
      }
      public string EarliestValidVersion {
        get { return result.EarliestValidVersion; }
        set { SetEarliestValidVersion(value); }
      }
      public Builder SetEarliestValidVersion(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasEarliestValidVersion = true;
        result.earliestValidVersion_ = value;
        return this;
      }
      public Builder ClearEarliestValidVersion() {
        PrepareBuilder();
        result.hasEarliestValidVersion = false;
        result.earliestValidVersion_ = "";
        return this;
      }
    }
    static InternalProduct() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class InternalPlaceOrderResponse : pb::GeneratedMessage<InternalPlaceOrderResponse, InternalPlaceOrderResponse.Builder> {
    private InternalPlaceOrderResponse() { }
    private static readonly InternalPlaceOrderResponse defaultInstance = new InternalPlaceOrderResponse().MakeReadOnly();
    private static readonly string[] _internalPlaceOrderResponseFieldNames = new string[] { "order_id" };
    private static readonly uint[] _internalPlaceOrderResponseFieldTags = new uint[] { 10 };
    public static InternalPlaceOrderResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override InternalPlaceOrderResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override InternalPlaceOrderResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_InternalPlaceOrderResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<InternalPlaceOrderResponse, InternalPlaceOrderResponse.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_InternalPlaceOrderResponse__FieldAccessorTable; }
    }
    
    public const int OrderIdFieldNumber = 1;
    private bool hasOrderId;
    private string orderId_ = "";
    public bool HasOrderId {
      get { return hasOrderId; }
    }
    public string OrderId {
      get { return orderId_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _internalPlaceOrderResponseFieldNames;
      if (hasOrderId) {
        output.WriteString(1, field_names[0], OrderId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasOrderId) {
          size += pb::CodedOutputStream.ComputeStringSize(1, OrderId);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static InternalPlaceOrderResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static InternalPlaceOrderResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static InternalPlaceOrderResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static InternalPlaceOrderResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static InternalPlaceOrderResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static InternalPlaceOrderResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static InternalPlaceOrderResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static InternalPlaceOrderResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static InternalPlaceOrderResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static InternalPlaceOrderResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private InternalPlaceOrderResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(InternalPlaceOrderResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<InternalPlaceOrderResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(InternalPlaceOrderResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private InternalPlaceOrderResponse result;
      
      private InternalPlaceOrderResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          InternalPlaceOrderResponse original = result;
          result = new InternalPlaceOrderResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override InternalPlaceOrderResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.InternalPlaceOrderResponse.Descriptor; }
      }
      
      public override InternalPlaceOrderResponse DefaultInstanceForType {
        get { return global::D3.Store.InternalPlaceOrderResponse.DefaultInstance; }
      }
      
      public override InternalPlaceOrderResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is InternalPlaceOrderResponse) {
          return MergeFrom((InternalPlaceOrderResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(InternalPlaceOrderResponse other) {
        if (other == global::D3.Store.InternalPlaceOrderResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasOrderId) {
          OrderId = other.OrderId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_internalPlaceOrderResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _internalPlaceOrderResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasOrderId = input.ReadString(ref result.orderId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasOrderId {
        get { return result.hasOrderId; }
      }
      public string OrderId {
        get { return result.OrderId; }
        set { SetOrderId(value); }
      }
      public Builder SetOrderId(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOrderId = true;
        result.orderId_ = value;
        return this;
      }
      public Builder ClearOrderId() {
        PrepareBuilder();
        result.hasOrderId = false;
        result.orderId_ = "";
        return this;
      }
    }
    static InternalPlaceOrderResponse() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ModifyLicense : pb::GeneratedMessage<ModifyLicense, ModifyLicense.Builder> {
    private ModifyLicense() { }
    private static readonly ModifyLicense defaultInstance = new ModifyLicense().MakeReadOnly();
    private static readonly string[] _modifyLicenseFieldNames = new string[] { "account_license_id", "status" };
    private static readonly uint[] _modifyLicenseFieldTags = new uint[] { 8, 16 };
    public static ModifyLicense DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ModifyLicense DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ModifyLicense ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_ModifyLicense__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ModifyLicense, ModifyLicense.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_ModifyLicense__FieldAccessorTable; }
    }
    
    public const int AccountLicenseIdFieldNumber = 1;
    private bool hasAccountLicenseId;
    private ulong accountLicenseId_;
    public bool HasAccountLicenseId {
      get { return hasAccountLicenseId; }
    }
    public ulong AccountLicenseId {
      get { return accountLicenseId_; }
    }
    
    public const int StatusFieldNumber = 2;
    private bool hasStatus;
    private int status_;
    public bool HasStatus {
      get { return hasStatus; }
    }
    public int Status {
      get { return status_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _modifyLicenseFieldNames;
      if (hasAccountLicenseId) {
        output.WriteUInt64(1, field_names[0], AccountLicenseId);
      }
      if (hasStatus) {
        output.WriteInt32(2, field_names[1], Status);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasAccountLicenseId) {
          size += pb::CodedOutputStream.ComputeUInt64Size(1, AccountLicenseId);
        }
        if (hasStatus) {
          size += pb::CodedOutputStream.ComputeInt32Size(2, Status);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ModifyLicense ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ModifyLicense ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ModifyLicense ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ModifyLicense ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ModifyLicense ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ModifyLicense ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ModifyLicense ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ModifyLicense ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ModifyLicense ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ModifyLicense ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ModifyLicense MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ModifyLicense prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ModifyLicense, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ModifyLicense cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ModifyLicense result;
      
      private ModifyLicense PrepareBuilder() {
        if (resultIsReadOnly) {
          ModifyLicense original = result;
          result = new ModifyLicense();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ModifyLicense MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.ModifyLicense.Descriptor; }
      }
      
      public override ModifyLicense DefaultInstanceForType {
        get { return global::D3.Store.ModifyLicense.DefaultInstance; }
      }
      
      public override ModifyLicense BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ModifyLicense) {
          return MergeFrom((ModifyLicense) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ModifyLicense other) {
        if (other == global::D3.Store.ModifyLicense.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasAccountLicenseId) {
          AccountLicenseId = other.AccountLicenseId;
        }
        if (other.HasStatus) {
          Status = other.Status;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_modifyLicenseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _modifyLicenseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasAccountLicenseId = input.ReadUInt64(ref result.accountLicenseId_);
              break;
            }
            case 16: {
              result.hasStatus = input.ReadInt32(ref result.status_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasAccountLicenseId {
        get { return result.hasAccountLicenseId; }
      }
      public ulong AccountLicenseId {
        get { return result.AccountLicenseId; }
        set { SetAccountLicenseId(value); }
      }
      public Builder SetAccountLicenseId(ulong value) {
        PrepareBuilder();
        result.hasAccountLicenseId = true;
        result.accountLicenseId_ = value;
        return this;
      }
      public Builder ClearAccountLicenseId() {
        PrepareBuilder();
        result.hasAccountLicenseId = false;
        result.accountLicenseId_ = 0UL;
        return this;
      }
      
      public bool HasStatus {
        get { return result.hasStatus; }
      }
      public int Status {
        get { return result.Status; }
        set { SetStatus(value); }
      }
      public Builder SetStatus(int value) {
        PrepareBuilder();
        result.hasStatus = true;
        result.status_ = value;
        return this;
      }
      public Builder ClearStatus() {
        PrepareBuilder();
        result.hasStatus = false;
        result.status_ = 0;
        return this;
      }
    }
    static ModifyLicense() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ModifyLicenseResponse : pb::GeneratedMessage<ModifyLicenseResponse, ModifyLicenseResponse.Builder> {
    private ModifyLicenseResponse() { }
    private static readonly ModifyLicenseResponse defaultInstance = new ModifyLicenseResponse().MakeReadOnly();
    private static readonly string[] _modifyLicenseResponseFieldNames = new string[] {  };
    private static readonly uint[] _modifyLicenseResponseFieldTags = new uint[] {  };
    public static ModifyLicenseResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ModifyLicenseResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ModifyLicenseResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_ModifyLicenseResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ModifyLicenseResponse, ModifyLicenseResponse.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_ModifyLicenseResponse__FieldAccessorTable; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _modifyLicenseResponseFieldNames;
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ModifyLicenseResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ModifyLicenseResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ModifyLicenseResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ModifyLicenseResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ModifyLicenseResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ModifyLicenseResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ModifyLicenseResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ModifyLicenseResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ModifyLicenseResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ModifyLicenseResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ModifyLicenseResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ModifyLicenseResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ModifyLicenseResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ModifyLicenseResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ModifyLicenseResponse result;
      
      private ModifyLicenseResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          ModifyLicenseResponse original = result;
          result = new ModifyLicenseResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ModifyLicenseResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.ModifyLicenseResponse.Descriptor; }
      }
      
      public override ModifyLicenseResponse DefaultInstanceForType {
        get { return global::D3.Store.ModifyLicenseResponse.DefaultInstance; }
      }
      
      public override ModifyLicenseResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ModifyLicenseResponse) {
          return MergeFrom((ModifyLicenseResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ModifyLicenseResponse other) {
        if (other == global::D3.Store.ModifyLicenseResponse.DefaultInstance) return this;
        PrepareBuilder();
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_modifyLicenseResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _modifyLicenseResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
    }
    static ModifyLicenseResponse() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class BPayOrderStatus : pb::GeneratedMessage<BPayOrderStatus, BPayOrderStatus.Builder> {
    private BPayOrderStatus() { }
    private static readonly BPayOrderStatus defaultInstance = new BPayOrderStatus().MakeReadOnly();
    private static readonly string[] _bPayOrderStatusFieldNames = new string[] { "consumables", "entitlements", "licenses", "order_id", "product_id", "revoked", "status" };
    private static readonly uint[] _bPayOrderStatusFieldTags = new uint[] { 34, 26, 42, 58, 64, 48, 8 };
    public static BPayOrderStatus DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override BPayOrderStatus DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override BPayOrderStatus ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_BPayOrderStatus__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<BPayOrderStatus, BPayOrderStatus.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_BPayOrderStatus__FieldAccessorTable; }
    }
    
    public const int StatusFieldNumber = 1;
    private bool hasStatus;
    private int status_;
    public bool HasStatus {
      get { return hasStatus; }
    }
    public int Status {
      get { return status_; }
    }
    
    public const int EntitlementsFieldNumber = 3;
    private pbc::PopsicleList<global::D3.Store.EntitlementUpdate> entitlements_ = new pbc::PopsicleList<global::D3.Store.EntitlementUpdate>();
    public scg::IList<global::D3.Store.EntitlementUpdate> EntitlementsList {
      get { return entitlements_; }
    }
    public int EntitlementsCount {
      get { return entitlements_.Count; }
    }
    public global::D3.Store.EntitlementUpdate GetEntitlements(int index) {
      return entitlements_[index];
    }
    
    public const int ConsumablesFieldNumber = 4;
    private pbc::PopsicleList<global::D3.Store.ConsumableLicense> consumables_ = new pbc::PopsicleList<global::D3.Store.ConsumableLicense>();
    public scg::IList<global::D3.Store.ConsumableLicense> ConsumablesList {
      get { return consumables_; }
    }
    public int ConsumablesCount {
      get { return consumables_.Count; }
    }
    public global::D3.Store.ConsumableLicense GetConsumables(int index) {
      return consumables_[index];
    }
    
    public const int LicensesFieldNumber = 5;
    private pbc::PopsicleList<global::D3.OnlineServiceServer.License> licenses_ = new pbc::PopsicleList<global::D3.OnlineServiceServer.License>();
    public scg::IList<global::D3.OnlineServiceServer.License> LicensesList {
      get { return licenses_; }
    }
    public int LicensesCount {
      get { return licenses_.Count; }
    }
    public global::D3.OnlineServiceServer.License GetLicenses(int index) {
      return licenses_[index];
    }
    
    public const int RevokedFieldNumber = 6;
    private bool hasRevoked;
    private bool revoked_;
    public bool HasRevoked {
      get { return hasRevoked; }
    }
    public bool Revoked {
      get { return revoked_; }
    }
    
    public const int OrderIdFieldNumber = 7;
    private bool hasOrderId;
    private string orderId_ = "";
    public bool HasOrderId {
      get { return hasOrderId; }
    }
    public string OrderId {
      get { return orderId_; }
    }
    
    public const int ProductIdFieldNumber = 8;
    private bool hasProductId;
    private uint productId_;
    public bool HasProductId {
      get { return hasProductId; }
    }
    public uint ProductId {
      get { return productId_; }
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::D3.OnlineServiceServer.License element in LicensesList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _bPayOrderStatusFieldNames;
      if (hasStatus) {
        output.WriteInt32(1, field_names[6], Status);
      }
      if (entitlements_.Count > 0) {
        output.WriteMessageArray(3, field_names[1], entitlements_);
      }
      if (consumables_.Count > 0) {
        output.WriteMessageArray(4, field_names[0], consumables_);
      }
      if (licenses_.Count > 0) {
        output.WriteMessageArray(5, field_names[2], licenses_);
      }
      if (hasRevoked) {
        output.WriteBool(6, field_names[5], Revoked);
      }
      if (hasOrderId) {
        output.WriteString(7, field_names[3], OrderId);
      }
      if (hasProductId) {
        output.WriteUInt32(8, field_names[4], ProductId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasStatus) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, Status);
        }
        foreach (global::D3.Store.EntitlementUpdate element in EntitlementsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, element);
        }
        foreach (global::D3.Store.ConsumableLicense element in ConsumablesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, element);
        }
        foreach (global::D3.OnlineServiceServer.License element in LicensesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(5, element);
        }
        if (hasRevoked) {
          size += pb::CodedOutputStream.ComputeBoolSize(6, Revoked);
        }
        if (hasOrderId) {
          size += pb::CodedOutputStream.ComputeStringSize(7, OrderId);
        }
        if (hasProductId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(8, ProductId);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static BPayOrderStatus ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static BPayOrderStatus ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static BPayOrderStatus ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static BPayOrderStatus ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static BPayOrderStatus ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static BPayOrderStatus ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static BPayOrderStatus ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static BPayOrderStatus ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static BPayOrderStatus ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static BPayOrderStatus ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private BPayOrderStatus MakeReadOnly() {
      entitlements_.MakeReadOnly();
      consumables_.MakeReadOnly();
      licenses_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(BPayOrderStatus prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<BPayOrderStatus, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(BPayOrderStatus cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private BPayOrderStatus result;
      
      private BPayOrderStatus PrepareBuilder() {
        if (resultIsReadOnly) {
          BPayOrderStatus original = result;
          result = new BPayOrderStatus();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override BPayOrderStatus MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.BPayOrderStatus.Descriptor; }
      }
      
      public override BPayOrderStatus DefaultInstanceForType {
        get { return global::D3.Store.BPayOrderStatus.DefaultInstance; }
      }
      
      public override BPayOrderStatus BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is BPayOrderStatus) {
          return MergeFrom((BPayOrderStatus) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(BPayOrderStatus other) {
        if (other == global::D3.Store.BPayOrderStatus.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasStatus) {
          Status = other.Status;
        }
        if (other.entitlements_.Count != 0) {
          result.entitlements_.Add(other.entitlements_);
        }
        if (other.consumables_.Count != 0) {
          result.consumables_.Add(other.consumables_);
        }
        if (other.licenses_.Count != 0) {
          result.licenses_.Add(other.licenses_);
        }
        if (other.HasRevoked) {
          Revoked = other.Revoked;
        }
        if (other.HasOrderId) {
          OrderId = other.OrderId;
        }
        if (other.HasProductId) {
          ProductId = other.ProductId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_bPayOrderStatusFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _bPayOrderStatusFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasStatus = input.ReadInt32(ref result.status_);
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.entitlements_, global::D3.Store.EntitlementUpdate.DefaultInstance, extensionRegistry);
              break;
            }
            case 34: {
              input.ReadMessageArray(tag, field_name, result.consumables_, global::D3.Store.ConsumableLicense.DefaultInstance, extensionRegistry);
              break;
            }
            case 42: {
              input.ReadMessageArray(tag, field_name, result.licenses_, global::D3.OnlineServiceServer.License.DefaultInstance, extensionRegistry);
              break;
            }
            case 48: {
              result.hasRevoked = input.ReadBool(ref result.revoked_);
              break;
            }
            case 58: {
              result.hasOrderId = input.ReadString(ref result.orderId_);
              break;
            }
            case 64: {
              result.hasProductId = input.ReadUInt32(ref result.productId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasStatus {
        get { return result.hasStatus; }
      }
      public int Status {
        get { return result.Status; }
        set { SetStatus(value); }
      }
      public Builder SetStatus(int value) {
        PrepareBuilder();
        result.hasStatus = true;
        result.status_ = value;
        return this;
      }
      public Builder ClearStatus() {
        PrepareBuilder();
        result.hasStatus = false;
        result.status_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Store.EntitlementUpdate> EntitlementsList {
        get { return PrepareBuilder().entitlements_; }
      }
      public int EntitlementsCount {
        get { return result.EntitlementsCount; }
      }
      public global::D3.Store.EntitlementUpdate GetEntitlements(int index) {
        return result.GetEntitlements(index);
      }
      public Builder SetEntitlements(int index, global::D3.Store.EntitlementUpdate value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.entitlements_[index] = value;
        return this;
      }
      public Builder SetEntitlements(int index, global::D3.Store.EntitlementUpdate.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.entitlements_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddEntitlements(global::D3.Store.EntitlementUpdate value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.entitlements_.Add(value);
        return this;
      }
      public Builder AddEntitlements(global::D3.Store.EntitlementUpdate.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.entitlements_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeEntitlements(scg::IEnumerable<global::D3.Store.EntitlementUpdate> values) {
        PrepareBuilder();
        result.entitlements_.Add(values);
        return this;
      }
      public Builder ClearEntitlements() {
        PrepareBuilder();
        result.entitlements_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Store.ConsumableLicense> ConsumablesList {
        get { return PrepareBuilder().consumables_; }
      }
      public int ConsumablesCount {
        get { return result.ConsumablesCount; }
      }
      public global::D3.Store.ConsumableLicense GetConsumables(int index) {
        return result.GetConsumables(index);
      }
      public Builder SetConsumables(int index, global::D3.Store.ConsumableLicense value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.consumables_[index] = value;
        return this;
      }
      public Builder SetConsumables(int index, global::D3.Store.ConsumableLicense.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.consumables_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddConsumables(global::D3.Store.ConsumableLicense value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.consumables_.Add(value);
        return this;
      }
      public Builder AddConsumables(global::D3.Store.ConsumableLicense.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.consumables_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeConsumables(scg::IEnumerable<global::D3.Store.ConsumableLicense> values) {
        PrepareBuilder();
        result.consumables_.Add(values);
        return this;
      }
      public Builder ClearConsumables() {
        PrepareBuilder();
        result.consumables_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.OnlineServiceServer.License> LicensesList {
        get { return PrepareBuilder().licenses_; }
      }
      public int LicensesCount {
        get { return result.LicensesCount; }
      }
      public global::D3.OnlineServiceServer.License GetLicenses(int index) {
        return result.GetLicenses(index);
      }
      public Builder SetLicenses(int index, global::D3.OnlineServiceServer.License value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.licenses_[index] = value;
        return this;
      }
      public Builder SetLicenses(int index, global::D3.OnlineServiceServer.License.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.licenses_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddLicenses(global::D3.OnlineServiceServer.License value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.licenses_.Add(value);
        return this;
      }
      public Builder AddLicenses(global::D3.OnlineServiceServer.License.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.licenses_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeLicenses(scg::IEnumerable<global::D3.OnlineServiceServer.License> values) {
        PrepareBuilder();
        result.licenses_.Add(values);
        return this;
      }
      public Builder ClearLicenses() {
        PrepareBuilder();
        result.licenses_.Clear();
        return this;
      }
      
      public bool HasRevoked {
        get { return result.hasRevoked; }
      }
      public bool Revoked {
        get { return result.Revoked; }
        set { SetRevoked(value); }
      }
      public Builder SetRevoked(bool value) {
        PrepareBuilder();
        result.hasRevoked = true;
        result.revoked_ = value;
        return this;
      }
      public Builder ClearRevoked() {
        PrepareBuilder();
        result.hasRevoked = false;
        result.revoked_ = false;
        return this;
      }
      
      public bool HasOrderId {
        get { return result.hasOrderId; }
      }
      public string OrderId {
        get { return result.OrderId; }
        set { SetOrderId(value); }
      }
      public Builder SetOrderId(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOrderId = true;
        result.orderId_ = value;
        return this;
      }
      public Builder ClearOrderId() {
        PrepareBuilder();
        result.hasOrderId = false;
        result.orderId_ = "";
        return this;
      }
      
      public bool HasProductId {
        get { return result.hasProductId; }
      }
      public uint ProductId {
        get { return result.ProductId; }
        set { SetProductId(value); }
      }
      public Builder SetProductId(uint value) {
        PrepareBuilder();
        result.hasProductId = true;
        result.productId_ = value;
        return this;
      }
      public Builder ClearProductId() {
        PrepareBuilder();
        result.hasProductId = false;
        result.productId_ = 0;
        return this;
      }
    }
    static BPayOrderStatus() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetCurrency : pb::GeneratedMessage<GetCurrency, GetCurrency.Builder> {
    private GetCurrency() { }
    private static readonly GetCurrency defaultInstance = new GetCurrency().MakeReadOnly();
    private static readonly string[] _getCurrencyFieldNames = new string[] {  };
    private static readonly uint[] _getCurrencyFieldTags = new uint[] {  };
    public static GetCurrency DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetCurrency DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetCurrency ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetCurrency__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetCurrency, GetCurrency.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetCurrency__FieldAccessorTable; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getCurrencyFieldNames;
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetCurrency ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetCurrency ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetCurrency ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetCurrency ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetCurrency ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetCurrency ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetCurrency ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetCurrency ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetCurrency ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetCurrency ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetCurrency MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetCurrency prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetCurrency, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetCurrency cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetCurrency result;
      
      private GetCurrency PrepareBuilder() {
        if (resultIsReadOnly) {
          GetCurrency original = result;
          result = new GetCurrency();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetCurrency MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetCurrency.Descriptor; }
      }
      
      public override GetCurrency DefaultInstanceForType {
        get { return global::D3.Store.GetCurrency.DefaultInstance; }
      }
      
      public override GetCurrency BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetCurrency) {
          return MergeFrom((GetCurrency) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetCurrency other) {
        if (other == global::D3.Store.GetCurrency.DefaultInstance) return this;
        PrepareBuilder();
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getCurrencyFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getCurrencyFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
    }
    static GetCurrency() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetCurrencyResponse : pb::GeneratedMessage<GetCurrencyResponse, GetCurrencyResponse.Builder> {
    private GetCurrencyResponse() { }
    private static readonly GetCurrencyResponse defaultInstance = new GetCurrencyResponse().MakeReadOnly();
    private static readonly string[] _getCurrencyResponseFieldNames = new string[] { "currency" };
    private static readonly uint[] _getCurrencyResponseFieldTags = new uint[] { 8 };
    public static GetCurrencyResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetCurrencyResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetCurrencyResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetCurrencyResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetCurrencyResponse, GetCurrencyResponse.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetCurrencyResponse__FieldAccessorTable; }
    }
    
    public const int CurrencyFieldNumber = 1;
    private bool hasCurrency;
    private int currency_;
    public bool HasCurrency {
      get { return hasCurrency; }
    }
    public int Currency {
      get { return currency_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getCurrencyResponseFieldNames;
      if (hasCurrency) {
        output.WriteInt32(1, field_names[0], Currency);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCurrency) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, Currency);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetCurrencyResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetCurrencyResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetCurrencyResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetCurrencyResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetCurrencyResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetCurrencyResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetCurrencyResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetCurrencyResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetCurrencyResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetCurrencyResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetCurrencyResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetCurrencyResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetCurrencyResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetCurrencyResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetCurrencyResponse result;
      
      private GetCurrencyResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          GetCurrencyResponse original = result;
          result = new GetCurrencyResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetCurrencyResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetCurrencyResponse.Descriptor; }
      }
      
      public override GetCurrencyResponse DefaultInstanceForType {
        get { return global::D3.Store.GetCurrencyResponse.DefaultInstance; }
      }
      
      public override GetCurrencyResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetCurrencyResponse) {
          return MergeFrom((GetCurrencyResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetCurrencyResponse other) {
        if (other == global::D3.Store.GetCurrencyResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCurrency) {
          Currency = other.Currency;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getCurrencyResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getCurrencyResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasCurrency = input.ReadInt32(ref result.currency_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCurrency {
        get { return result.hasCurrency; }
      }
      public int Currency {
        get { return result.Currency; }
        set { SetCurrency(value); }
      }
      public Builder SetCurrency(int value) {
        PrepareBuilder();
        result.hasCurrency = true;
        result.currency_ = value;
        return this;
      }
      public Builder ClearCurrency() {
        PrepareBuilder();
        result.hasCurrency = false;
        result.currency_ = 0;
        return this;
      }
    }
    static GetCurrencyResponse() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ConsumableLicense : pb::GeneratedMessage<ConsumableLicense, ConsumableLicense.Builder> {
    private ConsumableLicense() { }
    private static readonly ConsumableLicense defaultInstance = new ConsumableLicense().MakeReadOnly();
    private static readonly string[] _consumableLicenseFieldNames = new string[] { "amount", "consumed", "license_instance_id", "licenseid", "type" };
    private static readonly uint[] _consumableLicenseFieldTags = new uint[] { 24, 40, 16, 8, 32 };
    public static ConsumableLicense DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ConsumableLicense DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ConsumableLicense ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_ConsumableLicense__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ConsumableLicense, ConsumableLicense.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_ConsumableLicense__FieldAccessorTable; }
    }
    
    public const int LicenseidFieldNumber = 1;
    private bool hasLicenseid;
    private ulong licenseid_;
    public bool HasLicenseid {
      get { return hasLicenseid; }
    }
    public ulong Licenseid {
      get { return licenseid_; }
    }
    
    public const int LicenseInstanceIdFieldNumber = 2;
    private bool hasLicenseInstanceId;
    private ulong licenseInstanceId_;
    public bool HasLicenseInstanceId {
      get { return hasLicenseInstanceId; }
    }
    public ulong LicenseInstanceId {
      get { return licenseInstanceId_; }
    }
    
    public const int AmountFieldNumber = 3;
    private bool hasAmount;
    private long amount_;
    public bool HasAmount {
      get { return hasAmount; }
    }
    public long Amount {
      get { return amount_; }
    }
    
    public const int TypeFieldNumber = 4;
    private bool hasType;
    private int type_;
    public bool HasType {
      get { return hasType; }
    }
    public int Type {
      get { return type_; }
    }
    
    public const int ConsumedFieldNumber = 5;
    private bool hasConsumed;
    private bool consumed_;
    public bool HasConsumed {
      get { return hasConsumed; }
    }
    public bool Consumed {
      get { return consumed_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _consumableLicenseFieldNames;
      if (hasLicenseid) {
        output.WriteUInt64(1, field_names[3], Licenseid);
      }
      if (hasLicenseInstanceId) {
        output.WriteUInt64(2, field_names[2], LicenseInstanceId);
      }
      if (hasAmount) {
        output.WriteInt64(3, field_names[0], Amount);
      }
      if (hasType) {
        output.WriteInt32(4, field_names[4], Type);
      }
      if (hasConsumed) {
        output.WriteBool(5, field_names[1], Consumed);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasLicenseid) {
          size += pb::CodedOutputStream.ComputeUInt64Size(1, Licenseid);
        }
        if (hasLicenseInstanceId) {
          size += pb::CodedOutputStream.ComputeUInt64Size(2, LicenseInstanceId);
        }
        if (hasAmount) {
          size += pb::CodedOutputStream.ComputeInt64Size(3, Amount);
        }
        if (hasType) {
          size += pb::CodedOutputStream.ComputeInt32Size(4, Type);
        }
        if (hasConsumed) {
          size += pb::CodedOutputStream.ComputeBoolSize(5, Consumed);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ConsumableLicense ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ConsumableLicense ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ConsumableLicense ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ConsumableLicense ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ConsumableLicense ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ConsumableLicense ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ConsumableLicense ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ConsumableLicense ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ConsumableLicense ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ConsumableLicense ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ConsumableLicense MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ConsumableLicense prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ConsumableLicense, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ConsumableLicense cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ConsumableLicense result;
      
      private ConsumableLicense PrepareBuilder() {
        if (resultIsReadOnly) {
          ConsumableLicense original = result;
          result = new ConsumableLicense();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ConsumableLicense MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.ConsumableLicense.Descriptor; }
      }
      
      public override ConsumableLicense DefaultInstanceForType {
        get { return global::D3.Store.ConsumableLicense.DefaultInstance; }
      }
      
      public override ConsumableLicense BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ConsumableLicense) {
          return MergeFrom((ConsumableLicense) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ConsumableLicense other) {
        if (other == global::D3.Store.ConsumableLicense.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasLicenseid) {
          Licenseid = other.Licenseid;
        }
        if (other.HasLicenseInstanceId) {
          LicenseInstanceId = other.LicenseInstanceId;
        }
        if (other.HasAmount) {
          Amount = other.Amount;
        }
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasConsumed) {
          Consumed = other.Consumed;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_consumableLicenseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _consumableLicenseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasLicenseid = input.ReadUInt64(ref result.licenseid_);
              break;
            }
            case 16: {
              result.hasLicenseInstanceId = input.ReadUInt64(ref result.licenseInstanceId_);
              break;
            }
            case 24: {
              result.hasAmount = input.ReadInt64(ref result.amount_);
              break;
            }
            case 32: {
              result.hasType = input.ReadInt32(ref result.type_);
              break;
            }
            case 40: {
              result.hasConsumed = input.ReadBool(ref result.consumed_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasLicenseid {
        get { return result.hasLicenseid; }
      }
      public ulong Licenseid {
        get { return result.Licenseid; }
        set { SetLicenseid(value); }
      }
      public Builder SetLicenseid(ulong value) {
        PrepareBuilder();
        result.hasLicenseid = true;
        result.licenseid_ = value;
        return this;
      }
      public Builder ClearLicenseid() {
        PrepareBuilder();
        result.hasLicenseid = false;
        result.licenseid_ = 0UL;
        return this;
      }
      
      public bool HasLicenseInstanceId {
        get { return result.hasLicenseInstanceId; }
      }
      public ulong LicenseInstanceId {
        get { return result.LicenseInstanceId; }
        set { SetLicenseInstanceId(value); }
      }
      public Builder SetLicenseInstanceId(ulong value) {
        PrepareBuilder();
        result.hasLicenseInstanceId = true;
        result.licenseInstanceId_ = value;
        return this;
      }
      public Builder ClearLicenseInstanceId() {
        PrepareBuilder();
        result.hasLicenseInstanceId = false;
        result.licenseInstanceId_ = 0UL;
        return this;
      }
      
      public bool HasAmount {
        get { return result.hasAmount; }
      }
      public long Amount {
        get { return result.Amount; }
        set { SetAmount(value); }
      }
      public Builder SetAmount(long value) {
        PrepareBuilder();
        result.hasAmount = true;
        result.amount_ = value;
        return this;
      }
      public Builder ClearAmount() {
        PrepareBuilder();
        result.hasAmount = false;
        result.amount_ = 0L;
        return this;
      }
      
      public bool HasType {
        get { return result.hasType; }
      }
      public int Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(int value) {
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = 0;
        return this;
      }
      
      public bool HasConsumed {
        get { return result.hasConsumed; }
      }
      public bool Consumed {
        get { return result.Consumed; }
        set { SetConsumed(value); }
      }
      public Builder SetConsumed(bool value) {
        PrepareBuilder();
        result.hasConsumed = true;
        result.consumed_ = value;
        return this;
      }
      public Builder ClearConsumed() {
        PrepareBuilder();
        result.hasConsumed = false;
        result.consumed_ = false;
        return this;
      }
    }
    static ConsumableLicense() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class LicenseInstance : pb::GeneratedMessage<LicenseInstance, LicenseInstance.Builder> {
    private LicenseInstance() { }
    private static readonly LicenseInstance defaultInstance = new LicenseInstance().MakeReadOnly();
    private static readonly string[] _licenseInstanceFieldNames = new string[] { "license", "state" };
    private static readonly uint[] _licenseInstanceFieldTags = new uint[] { 10, 16 };
    public static LicenseInstance DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override LicenseInstance DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override LicenseInstance ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_LicenseInstance__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<LicenseInstance, LicenseInstance.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_LicenseInstance__FieldAccessorTable; }
    }
    
    public const int LicenseFieldNumber = 1;
    private bool hasLicense;
    private global::D3.OnlineServiceServer.License license_;
    public bool HasLicense {
      get { return hasLicense; }
    }
    public global::D3.OnlineServiceServer.License License {
      get { return license_ ?? global::D3.OnlineServiceServer.License.DefaultInstance; }
    }
    
    public const int StateFieldNumber = 2;
    private bool hasState;
    private int state_;
    public bool HasState {
      get { return hasState; }
    }
    public int State {
      get { return state_; }
    }
    
    public override bool IsInitialized {
      get {
        if (HasLicense) {
          if (!License.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _licenseInstanceFieldNames;
      if (hasLicense) {
        output.WriteMessage(1, field_names[0], License);
      }
      if (hasState) {
        output.WriteInt32(2, field_names[1], State);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasLicense) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, License);
        }
        if (hasState) {
          size += pb::CodedOutputStream.ComputeInt32Size(2, State);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static LicenseInstance ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LicenseInstance ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LicenseInstance ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LicenseInstance ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LicenseInstance ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LicenseInstance ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static LicenseInstance ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static LicenseInstance ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static LicenseInstance ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LicenseInstance ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private LicenseInstance MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(LicenseInstance prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<LicenseInstance, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(LicenseInstance cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private LicenseInstance result;
      
      private LicenseInstance PrepareBuilder() {
        if (resultIsReadOnly) {
          LicenseInstance original = result;
          result = new LicenseInstance();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override LicenseInstance MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.LicenseInstance.Descriptor; }
      }
      
      public override LicenseInstance DefaultInstanceForType {
        get { return global::D3.Store.LicenseInstance.DefaultInstance; }
      }
      
      public override LicenseInstance BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is LicenseInstance) {
          return MergeFrom((LicenseInstance) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(LicenseInstance other) {
        if (other == global::D3.Store.LicenseInstance.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasLicense) {
          MergeLicense(other.License);
        }
        if (other.HasState) {
          State = other.State;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_licenseInstanceFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _licenseInstanceFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.OnlineServiceServer.License.Builder subBuilder = global::D3.OnlineServiceServer.License.CreateBuilder();
              if (result.hasLicense) {
                subBuilder.MergeFrom(License);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              License = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              result.hasState = input.ReadInt32(ref result.state_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasLicense {
       get { return result.hasLicense; }
      }
      public global::D3.OnlineServiceServer.License License {
        get { return result.License; }
        set { SetLicense(value); }
      }
      public Builder SetLicense(global::D3.OnlineServiceServer.License value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLicense = true;
        result.license_ = value;
        return this;
      }
      public Builder SetLicense(global::D3.OnlineServiceServer.License.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasLicense = true;
        result.license_ = builderForValue.Build();
        return this;
      }
      public Builder MergeLicense(global::D3.OnlineServiceServer.License value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasLicense &&
            result.license_ != global::D3.OnlineServiceServer.License.DefaultInstance) {
            result.license_ = global::D3.OnlineServiceServer.License.CreateBuilder(result.license_).MergeFrom(value).BuildPartial();
        } else {
          result.license_ = value;
        }
        result.hasLicense = true;
        return this;
      }
      public Builder ClearLicense() {
        PrepareBuilder();
        result.hasLicense = false;
        result.license_ = null;
        return this;
      }
      
      public bool HasState {
        get { return result.hasState; }
      }
      public int State {
        get { return result.State; }
        set { SetState(value); }
      }
      public Builder SetState(int value) {
        PrepareBuilder();
        result.hasState = true;
        result.state_ = value;
        return this;
      }
      public Builder ClearState() {
        PrepareBuilder();
        result.hasState = false;
        result.state_ = 0;
        return this;
      }
    }
    static LicenseInstance() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class LicenseAttributes : pb::GeneratedMessage<LicenseAttributes, LicenseAttributes.Builder> {
    private LicenseAttributes() { }
    private static readonly LicenseAttributes defaultInstance = new LicenseAttributes().MakeReadOnly();
    private static readonly string[] _licenseAttributesFieldNames = new string[] { "content_license_id", "gbid", "licenseid", "max_stack_count", "platinum_amount" };
    private static readonly uint[] _licenseAttributesFieldTags = new uint[] { 32, 24, 8, 40, 16 };
    public static LicenseAttributes DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override LicenseAttributes DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override LicenseAttributes ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_LicenseAttributes__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<LicenseAttributes, LicenseAttributes.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_LicenseAttributes__FieldAccessorTable; }
    }
    
    public const int LicenseidFieldNumber = 1;
    private bool hasLicenseid;
    private ulong licenseid_;
    public bool HasLicenseid {
      get { return hasLicenseid; }
    }
    public ulong Licenseid {
      get { return licenseid_; }
    }
    
    public const int PlatinumAmountFieldNumber = 2;
    private bool hasPlatinumAmount;
    private ulong platinumAmount_;
    public bool HasPlatinumAmount {
      get { return hasPlatinumAmount; }
    }
    public ulong PlatinumAmount {
      get { return platinumAmount_; }
    }
    
    public const int GbidFieldNumber = 3;
    private bool hasGbid;
    private int gbid_;
    public bool HasGbid {
      get { return hasGbid; }
    }
    public int Gbid {
      get { return gbid_; }
    }
    
    public const int ContentLicenseIdFieldNumber = 4;
    private pbc::PopsicleList<int> contentLicenseId_ = new pbc::PopsicleList<int>();
    public scg::IList<int> ContentLicenseIdList {
      get { return pbc::Lists.AsReadOnly(contentLicenseId_); }
    }
    public int ContentLicenseIdCount {
      get { return contentLicenseId_.Count; }
    }
    public int GetContentLicenseId(int index) {
      return contentLicenseId_[index];
    }
    
    public const int MaxStackCountFieldNumber = 5;
    private bool hasMaxStackCount;
    private uint maxStackCount_;
    public bool HasMaxStackCount {
      get { return hasMaxStackCount; }
    }
    public uint MaxStackCount {
      get { return maxStackCount_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _licenseAttributesFieldNames;
      if (hasLicenseid) {
        output.WriteUInt64(1, field_names[2], Licenseid);
      }
      if (hasPlatinumAmount) {
        output.WriteUInt64(2, field_names[4], PlatinumAmount);
      }
      if (hasGbid) {
        output.WriteInt32(3, field_names[1], Gbid);
      }
      if (contentLicenseId_.Count > 0) {
        output.WriteInt32Array(4, field_names[0], contentLicenseId_);
      }
      if (hasMaxStackCount) {
        output.WriteUInt32(5, field_names[3], MaxStackCount);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasLicenseid) {
          size += pb::CodedOutputStream.ComputeUInt64Size(1, Licenseid);
        }
        if (hasPlatinumAmount) {
          size += pb::CodedOutputStream.ComputeUInt64Size(2, PlatinumAmount);
        }
        if (hasGbid) {
          size += pb::CodedOutputStream.ComputeInt32Size(3, Gbid);
        }
        {
          int dataSize = 0;
          foreach (int element in ContentLicenseIdList) {
            dataSize += pb::CodedOutputStream.ComputeInt32SizeNoTag(element);
          }
          size += dataSize;
          size += 1 * contentLicenseId_.Count;
        }
        if (hasMaxStackCount) {
          size += pb::CodedOutputStream.ComputeUInt32Size(5, MaxStackCount);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static LicenseAttributes ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LicenseAttributes ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LicenseAttributes ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LicenseAttributes ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LicenseAttributes ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LicenseAttributes ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static LicenseAttributes ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static LicenseAttributes ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static LicenseAttributes ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LicenseAttributes ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private LicenseAttributes MakeReadOnly() {
      contentLicenseId_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(LicenseAttributes prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<LicenseAttributes, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(LicenseAttributes cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private LicenseAttributes result;
      
      private LicenseAttributes PrepareBuilder() {
        if (resultIsReadOnly) {
          LicenseAttributes original = result;
          result = new LicenseAttributes();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override LicenseAttributes MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.LicenseAttributes.Descriptor; }
      }
      
      public override LicenseAttributes DefaultInstanceForType {
        get { return global::D3.Store.LicenseAttributes.DefaultInstance; }
      }
      
      public override LicenseAttributes BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is LicenseAttributes) {
          return MergeFrom((LicenseAttributes) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(LicenseAttributes other) {
        if (other == global::D3.Store.LicenseAttributes.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasLicenseid) {
          Licenseid = other.Licenseid;
        }
        if (other.HasPlatinumAmount) {
          PlatinumAmount = other.PlatinumAmount;
        }
        if (other.HasGbid) {
          Gbid = other.Gbid;
        }
        if (other.contentLicenseId_.Count != 0) {
          result.contentLicenseId_.Add(other.contentLicenseId_);
        }
        if (other.HasMaxStackCount) {
          MaxStackCount = other.MaxStackCount;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_licenseAttributesFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _licenseAttributesFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasLicenseid = input.ReadUInt64(ref result.licenseid_);
              break;
            }
            case 16: {
              result.hasPlatinumAmount = input.ReadUInt64(ref result.platinumAmount_);
              break;
            }
            case 24: {
              result.hasGbid = input.ReadInt32(ref result.gbid_);
              break;
            }
            case 34:
            case 32: {
              input.ReadInt32Array(tag, field_name, result.contentLicenseId_);
              break;
            }
            case 40: {
              result.hasMaxStackCount = input.ReadUInt32(ref result.maxStackCount_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasLicenseid {
        get { return result.hasLicenseid; }
      }
      public ulong Licenseid {
        get { return result.Licenseid; }
        set { SetLicenseid(value); }
      }
      public Builder SetLicenseid(ulong value) {
        PrepareBuilder();
        result.hasLicenseid = true;
        result.licenseid_ = value;
        return this;
      }
      public Builder ClearLicenseid() {
        PrepareBuilder();
        result.hasLicenseid = false;
        result.licenseid_ = 0UL;
        return this;
      }
      
      public bool HasPlatinumAmount {
        get { return result.hasPlatinumAmount; }
      }
      public ulong PlatinumAmount {
        get { return result.PlatinumAmount; }
        set { SetPlatinumAmount(value); }
      }
      public Builder SetPlatinumAmount(ulong value) {
        PrepareBuilder();
        result.hasPlatinumAmount = true;
        result.platinumAmount_ = value;
        return this;
      }
      public Builder ClearPlatinumAmount() {
        PrepareBuilder();
        result.hasPlatinumAmount = false;
        result.platinumAmount_ = 0UL;
        return this;
      }
      
      public bool HasGbid {
        get { return result.hasGbid; }
      }
      public int Gbid {
        get { return result.Gbid; }
        set { SetGbid(value); }
      }
      public Builder SetGbid(int value) {
        PrepareBuilder();
        result.hasGbid = true;
        result.gbid_ = value;
        return this;
      }
      public Builder ClearGbid() {
        PrepareBuilder();
        result.hasGbid = false;
        result.gbid_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<int> ContentLicenseIdList {
        get { return PrepareBuilder().contentLicenseId_; }
      }
      public int ContentLicenseIdCount {
        get { return result.ContentLicenseIdCount; }
      }
      public int GetContentLicenseId(int index) {
        return result.GetContentLicenseId(index);
      }
      public Builder SetContentLicenseId(int index, int value) {
        PrepareBuilder();
        result.contentLicenseId_[index] = value;
        return this;
      }
      public Builder AddContentLicenseId(int value) {
        PrepareBuilder();
        result.contentLicenseId_.Add(value);
        return this;
      }
      public Builder AddRangeContentLicenseId(scg::IEnumerable<int> values) {
        PrepareBuilder();
        result.contentLicenseId_.Add(values);
        return this;
      }
      public Builder ClearContentLicenseId() {
        PrepareBuilder();
        result.contentLicenseId_.Clear();
        return this;
      }
      
      public bool HasMaxStackCount {
        get { return result.hasMaxStackCount; }
      }
      public uint MaxStackCount {
        get { return result.MaxStackCount; }
        set { SetMaxStackCount(value); }
      }
      public Builder SetMaxStackCount(uint value) {
        PrepareBuilder();
        result.hasMaxStackCount = true;
        result.maxStackCount_ = value;
        return this;
      }
      public Builder ClearMaxStackCount() {
        PrepareBuilder();
        result.hasMaxStackCount = false;
        result.maxStackCount_ = 0;
        return this;
      }
    }
    static LicenseAttributes() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ProductCatalog : pb::GeneratedMessage<ProductCatalog, ProductCatalog.Builder> {
    private ProductCatalog() { }
    private static readonly ProductCatalog defaultInstance = new ProductCatalog().MakeReadOnly();
    private static readonly string[] _productCatalogFieldNames = new string[] { "currencies", "digest", "license_attributes", "products", "proto_version", "version" };
    private static readonly uint[] _productCatalogFieldTags = new uint[] { 50, 34, 26, 18, 8, 40 };
    public static ProductCatalog DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ProductCatalog DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ProductCatalog ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_ProductCatalog__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ProductCatalog, ProductCatalog.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_ProductCatalog__FieldAccessorTable; }
    }
    
    public const int ProtoVersionFieldNumber = 1;
    private bool hasProtoVersion;
    private uint protoVersion_;
    public bool HasProtoVersion {
      get { return hasProtoVersion; }
    }
    public uint ProtoVersion {
      get { return protoVersion_; }
    }
    
    public const int ProductsFieldNumber = 2;
    private pbc::PopsicleList<global::D3.Store.InternalProduct> products_ = new pbc::PopsicleList<global::D3.Store.InternalProduct>();
    public scg::IList<global::D3.Store.InternalProduct> ProductsList {
      get { return products_; }
    }
    public int ProductsCount {
      get { return products_.Count; }
    }
    public global::D3.Store.InternalProduct GetProducts(int index) {
      return products_[index];
    }
    
    public const int LicenseAttributesFieldNumber = 3;
    private pbc::PopsicleList<global::D3.Store.LicenseAttributes> licenseAttributes_ = new pbc::PopsicleList<global::D3.Store.LicenseAttributes>();
    public scg::IList<global::D3.Store.LicenseAttributes> LicenseAttributesList {
      get { return licenseAttributes_; }
    }
    public int LicenseAttributesCount {
      get { return licenseAttributes_.Count; }
    }
    public global::D3.Store.LicenseAttributes GetLicenseAttributes(int index) {
      return licenseAttributes_[index];
    }
    
    public const int DigestFieldNumber = 4;
    private bool hasDigest;
    private pb::ByteString digest_ = pb::ByteString.Empty;
    public bool HasDigest {
      get { return hasDigest; }
    }
    public pb::ByteString Digest {
      get { return digest_; }
    }
    
    public const int VersionFieldNumber = 5;
    private bool hasVersion;
    private long version_;
    public bool HasVersion {
      get { return hasVersion; }
    }
    public long Version {
      get { return version_; }
    }
    
    public const int CurrenciesFieldNumber = 6;
    private pbc::PopsicleList<global::D3.Store.Currency> currencies_ = new pbc::PopsicleList<global::D3.Store.Currency>();
    public scg::IList<global::D3.Store.Currency> CurrenciesList {
      get { return currencies_; }
    }
    public int CurrenciesCount {
      get { return currencies_.Count; }
    }
    public global::D3.Store.Currency GetCurrencies(int index) {
      return currencies_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasProtoVersion) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _productCatalogFieldNames;
      if (hasProtoVersion) {
        output.WriteUInt32(1, field_names[4], ProtoVersion);
      }
      if (products_.Count > 0) {
        output.WriteMessageArray(2, field_names[3], products_);
      }
      if (licenseAttributes_.Count > 0) {
        output.WriteMessageArray(3, field_names[2], licenseAttributes_);
      }
      if (hasDigest) {
        output.WriteBytes(4, field_names[1], Digest);
      }
      if (hasVersion) {
        output.WriteInt64(5, field_names[5], Version);
      }
      if (currencies_.Count > 0) {
        output.WriteMessageArray(6, field_names[0], currencies_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasProtoVersion) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, ProtoVersion);
        }
        foreach (global::D3.Store.InternalProduct element in ProductsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, element);
        }
        foreach (global::D3.Store.LicenseAttributes element in LicenseAttributesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, element);
        }
        if (hasDigest) {
          size += pb::CodedOutputStream.ComputeBytesSize(4, Digest);
        }
        if (hasVersion) {
          size += pb::CodedOutputStream.ComputeInt64Size(5, Version);
        }
        foreach (global::D3.Store.Currency element in CurrenciesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(6, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ProductCatalog ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ProductCatalog ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ProductCatalog ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ProductCatalog ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ProductCatalog ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ProductCatalog ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ProductCatalog ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ProductCatalog ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ProductCatalog ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ProductCatalog ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ProductCatalog MakeReadOnly() {
      products_.MakeReadOnly();
      licenseAttributes_.MakeReadOnly();
      currencies_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ProductCatalog prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ProductCatalog, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ProductCatalog cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ProductCatalog result;
      
      private ProductCatalog PrepareBuilder() {
        if (resultIsReadOnly) {
          ProductCatalog original = result;
          result = new ProductCatalog();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ProductCatalog MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.ProductCatalog.Descriptor; }
      }
      
      public override ProductCatalog DefaultInstanceForType {
        get { return global::D3.Store.ProductCatalog.DefaultInstance; }
      }
      
      public override ProductCatalog BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ProductCatalog) {
          return MergeFrom((ProductCatalog) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ProductCatalog other) {
        if (other == global::D3.Store.ProductCatalog.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasProtoVersion) {
          ProtoVersion = other.ProtoVersion;
        }
        if (other.products_.Count != 0) {
          result.products_.Add(other.products_);
        }
        if (other.licenseAttributes_.Count != 0) {
          result.licenseAttributes_.Add(other.licenseAttributes_);
        }
        if (other.HasDigest) {
          Digest = other.Digest;
        }
        if (other.HasVersion) {
          Version = other.Version;
        }
        if (other.currencies_.Count != 0) {
          result.currencies_.Add(other.currencies_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_productCatalogFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _productCatalogFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasProtoVersion = input.ReadUInt32(ref result.protoVersion_);
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.products_, global::D3.Store.InternalProduct.DefaultInstance, extensionRegistry);
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.licenseAttributes_, global::D3.Store.LicenseAttributes.DefaultInstance, extensionRegistry);
              break;
            }
            case 34: {
              result.hasDigest = input.ReadBytes(ref result.digest_);
              break;
            }
            case 40: {
              result.hasVersion = input.ReadInt64(ref result.version_);
              break;
            }
            case 50: {
              input.ReadMessageArray(tag, field_name, result.currencies_, global::D3.Store.Currency.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasProtoVersion {
        get { return result.hasProtoVersion; }
      }
      public uint ProtoVersion {
        get { return result.ProtoVersion; }
        set { SetProtoVersion(value); }
      }
      public Builder SetProtoVersion(uint value) {
        PrepareBuilder();
        result.hasProtoVersion = true;
        result.protoVersion_ = value;
        return this;
      }
      public Builder ClearProtoVersion() {
        PrepareBuilder();
        result.hasProtoVersion = false;
        result.protoVersion_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Store.InternalProduct> ProductsList {
        get { return PrepareBuilder().products_; }
      }
      public int ProductsCount {
        get { return result.ProductsCount; }
      }
      public global::D3.Store.InternalProduct GetProducts(int index) {
        return result.GetProducts(index);
      }
      public Builder SetProducts(int index, global::D3.Store.InternalProduct value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.products_[index] = value;
        return this;
      }
      public Builder SetProducts(int index, global::D3.Store.InternalProduct.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.products_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddProducts(global::D3.Store.InternalProduct value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.products_.Add(value);
        return this;
      }
      public Builder AddProducts(global::D3.Store.InternalProduct.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.products_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeProducts(scg::IEnumerable<global::D3.Store.InternalProduct> values) {
        PrepareBuilder();
        result.products_.Add(values);
        return this;
      }
      public Builder ClearProducts() {
        PrepareBuilder();
        result.products_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Store.LicenseAttributes> LicenseAttributesList {
        get { return PrepareBuilder().licenseAttributes_; }
      }
      public int LicenseAttributesCount {
        get { return result.LicenseAttributesCount; }
      }
      public global::D3.Store.LicenseAttributes GetLicenseAttributes(int index) {
        return result.GetLicenseAttributes(index);
      }
      public Builder SetLicenseAttributes(int index, global::D3.Store.LicenseAttributes value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.licenseAttributes_[index] = value;
        return this;
      }
      public Builder SetLicenseAttributes(int index, global::D3.Store.LicenseAttributes.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.licenseAttributes_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddLicenseAttributes(global::D3.Store.LicenseAttributes value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.licenseAttributes_.Add(value);
        return this;
      }
      public Builder AddLicenseAttributes(global::D3.Store.LicenseAttributes.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.licenseAttributes_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeLicenseAttributes(scg::IEnumerable<global::D3.Store.LicenseAttributes> values) {
        PrepareBuilder();
        result.licenseAttributes_.Add(values);
        return this;
      }
      public Builder ClearLicenseAttributes() {
        PrepareBuilder();
        result.licenseAttributes_.Clear();
        return this;
      }
      
      public bool HasDigest {
        get { return result.hasDigest; }
      }
      public pb::ByteString Digest {
        get { return result.Digest; }
        set { SetDigest(value); }
      }
      public Builder SetDigest(pb::ByteString value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDigest = true;
        result.digest_ = value;
        return this;
      }
      public Builder ClearDigest() {
        PrepareBuilder();
        result.hasDigest = false;
        result.digest_ = pb::ByteString.Empty;
        return this;
      }
      
      public bool HasVersion {
        get { return result.hasVersion; }
      }
      public long Version {
        get { return result.Version; }
        set { SetVersion(value); }
      }
      public Builder SetVersion(long value) {
        PrepareBuilder();
        result.hasVersion = true;
        result.version_ = value;
        return this;
      }
      public Builder ClearVersion() {
        PrepareBuilder();
        result.hasVersion = false;
        result.version_ = 0L;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Store.Currency> CurrenciesList {
        get { return PrepareBuilder().currencies_; }
      }
      public int CurrenciesCount {
        get { return result.CurrenciesCount; }
      }
      public global::D3.Store.Currency GetCurrencies(int index) {
        return result.GetCurrencies(index);
      }
      public Builder SetCurrencies(int index, global::D3.Store.Currency value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.currencies_[index] = value;
        return this;
      }
      public Builder SetCurrencies(int index, global::D3.Store.Currency.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.currencies_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddCurrencies(global::D3.Store.Currency value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.currencies_.Add(value);
        return this;
      }
      public Builder AddCurrencies(global::D3.Store.Currency.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.currencies_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeCurrencies(scg::IEnumerable<global::D3.Store.Currency> values) {
        PrepareBuilder();
        result.currencies_.Add(values);
        return this;
      }
      public Builder ClearCurrencies() {
        PrepareBuilder();
        result.currencies_.Clear();
        return this;
      }
    }
    static ProductCatalog() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class CountryInformation : pb::GeneratedMessage<CountryInformation, CountryInformation.Builder> {
    private CountryInformation() { }
    private static readonly CountryInformation defaultInstance = new CountryInformation().MakeReadOnly();
    private static readonly string[] _countryInformationFieldNames = new string[] { "country_name", "currency" };
    private static readonly uint[] _countryInformationFieldTags = new uint[] { 10, 16 };
    public static CountryInformation DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override CountryInformation DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override CountryInformation ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_CountryInformation__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<CountryInformation, CountryInformation.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_CountryInformation__FieldAccessorTable; }
    }
    
    public const int CountryNameFieldNumber = 1;
    private bool hasCountryName;
    private string countryName_ = "";
    public bool HasCountryName {
      get { return hasCountryName; }
    }
    public string CountryName {
      get { return countryName_; }
    }
    
    public const int CurrencyFieldNumber = 2;
    private bool hasCurrency;
    private int currency_;
    public bool HasCurrency {
      get { return hasCurrency; }
    }
    public int Currency {
      get { return currency_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _countryInformationFieldNames;
      if (hasCountryName) {
        output.WriteString(1, field_names[0], CountryName);
      }
      if (hasCurrency) {
        output.WriteInt32(2, field_names[1], Currency);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasCountryName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, CountryName);
        }
        if (hasCurrency) {
          size += pb::CodedOutputStream.ComputeInt32Size(2, Currency);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static CountryInformation ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CountryInformation ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CountryInformation ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CountryInformation ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CountryInformation ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CountryInformation ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static CountryInformation ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static CountryInformation ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static CountryInformation ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CountryInformation ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private CountryInformation MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(CountryInformation prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<CountryInformation, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(CountryInformation cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private CountryInformation result;
      
      private CountryInformation PrepareBuilder() {
        if (resultIsReadOnly) {
          CountryInformation original = result;
          result = new CountryInformation();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override CountryInformation MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.CountryInformation.Descriptor; }
      }
      
      public override CountryInformation DefaultInstanceForType {
        get { return global::D3.Store.CountryInformation.DefaultInstance; }
      }
      
      public override CountryInformation BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is CountryInformation) {
          return MergeFrom((CountryInformation) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(CountryInformation other) {
        if (other == global::D3.Store.CountryInformation.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCountryName) {
          CountryName = other.CountryName;
        }
        if (other.HasCurrency) {
          Currency = other.Currency;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_countryInformationFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _countryInformationFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasCountryName = input.ReadString(ref result.countryName_);
              break;
            }
            case 16: {
              result.hasCurrency = input.ReadInt32(ref result.currency_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCountryName {
        get { return result.hasCountryName; }
      }
      public string CountryName {
        get { return result.CountryName; }
        set { SetCountryName(value); }
      }
      public Builder SetCountryName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCountryName = true;
        result.countryName_ = value;
        return this;
      }
      public Builder ClearCountryName() {
        PrepareBuilder();
        result.hasCountryName = false;
        result.countryName_ = "";
        return this;
      }
      
      public bool HasCurrency {
        get { return result.hasCurrency; }
      }
      public int Currency {
        get { return result.Currency; }
        set { SetCurrency(value); }
      }
      public Builder SetCurrency(int value) {
        PrepareBuilder();
        result.hasCurrency = true;
        result.currency_ = value;
        return this;
      }
      public Builder ClearCurrency() {
        PrepareBuilder();
        result.hasCurrency = false;
        result.currency_ = 0;
        return this;
      }
    }
    static CountryInformation() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class CountryConfig : pb::GeneratedMessage<CountryConfig, CountryConfig.Builder> {
    private CountryConfig() { }
    private static readonly CountryConfig defaultInstance = new CountryConfig().MakeReadOnly();
    private static readonly string[] _countryConfigFieldNames = new string[] { "country_info" };
    private static readonly uint[] _countryConfigFieldTags = new uint[] { 10 };
    public static CountryConfig DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override CountryConfig DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override CountryConfig ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_CountryConfig__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<CountryConfig, CountryConfig.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_CountryConfig__FieldAccessorTable; }
    }
    
    public const int CountryInfoFieldNumber = 1;
    private pbc::PopsicleList<global::D3.Store.CountryInformation> countryInfo_ = new pbc::PopsicleList<global::D3.Store.CountryInformation>();
    public scg::IList<global::D3.Store.CountryInformation> CountryInfoList {
      get { return countryInfo_; }
    }
    public int CountryInfoCount {
      get { return countryInfo_.Count; }
    }
    public global::D3.Store.CountryInformation GetCountryInfo(int index) {
      return countryInfo_[index];
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _countryConfigFieldNames;
      if (countryInfo_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], countryInfo_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::D3.Store.CountryInformation element in CountryInfoList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static CountryConfig ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CountryConfig ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CountryConfig ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CountryConfig ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CountryConfig ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CountryConfig ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static CountryConfig ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static CountryConfig ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static CountryConfig ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CountryConfig ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private CountryConfig MakeReadOnly() {
      countryInfo_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(CountryConfig prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<CountryConfig, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(CountryConfig cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private CountryConfig result;
      
      private CountryConfig PrepareBuilder() {
        if (resultIsReadOnly) {
          CountryConfig original = result;
          result = new CountryConfig();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override CountryConfig MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.CountryConfig.Descriptor; }
      }
      
      public override CountryConfig DefaultInstanceForType {
        get { return global::D3.Store.CountryConfig.DefaultInstance; }
      }
      
      public override CountryConfig BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is CountryConfig) {
          return MergeFrom((CountryConfig) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(CountryConfig other) {
        if (other == global::D3.Store.CountryConfig.DefaultInstance) return this;
        PrepareBuilder();
        if (other.countryInfo_.Count != 0) {
          result.countryInfo_.Add(other.countryInfo_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_countryConfigFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _countryConfigFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.countryInfo_, global::D3.Store.CountryInformation.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::D3.Store.CountryInformation> CountryInfoList {
        get { return PrepareBuilder().countryInfo_; }
      }
      public int CountryInfoCount {
        get { return result.CountryInfoCount; }
      }
      public global::D3.Store.CountryInformation GetCountryInfo(int index) {
        return result.GetCountryInfo(index);
      }
      public Builder SetCountryInfo(int index, global::D3.Store.CountryInformation value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.countryInfo_[index] = value;
        return this;
      }
      public Builder SetCountryInfo(int index, global::D3.Store.CountryInformation.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.countryInfo_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddCountryInfo(global::D3.Store.CountryInformation value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.countryInfo_.Add(value);
        return this;
      }
      public Builder AddCountryInfo(global::D3.Store.CountryInformation.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.countryInfo_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeCountryInfo(scg::IEnumerable<global::D3.Store.CountryInformation> values) {
        PrepareBuilder();
        result.countryInfo_.Add(values);
        return this;
      }
      public Builder ClearCountryInfo() {
        PrepareBuilder();
        result.countryInfo_.Clear();
        return this;
      }
    }
    static CountryConfig() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class CheckGTAPPStatusResponse : pb::GeneratedMessage<CheckGTAPPStatusResponse, CheckGTAPPStatusResponse.Builder> {
    private CheckGTAPPStatusResponse() { }
    private static readonly CheckGTAPPStatusResponse defaultInstance = new CheckGTAPPStatusResponse().MakeReadOnly();
    private static readonly string[] _checkGTAPPStatusResponseFieldNames = new string[] { "status" };
    private static readonly uint[] _checkGTAPPStatusResponseFieldTags = new uint[] { 8 };
    public static CheckGTAPPStatusResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override CheckGTAPPStatusResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override CheckGTAPPStatusResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_CheckGTAPPStatusResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<CheckGTAPPStatusResponse, CheckGTAPPStatusResponse.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_CheckGTAPPStatusResponse__FieldAccessorTable; }
    }
    
    public const int StatusFieldNumber = 1;
    private bool hasStatus;
    private uint status_;
    public bool HasStatus {
      get { return hasStatus; }
    }
    public uint Status {
      get { return status_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _checkGTAPPStatusResponseFieldNames;
      if (hasStatus) {
        output.WriteUInt32(1, field_names[0], Status);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasStatus) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, Status);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static CheckGTAPPStatusResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CheckGTAPPStatusResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CheckGTAPPStatusResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CheckGTAPPStatusResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CheckGTAPPStatusResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CheckGTAPPStatusResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static CheckGTAPPStatusResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static CheckGTAPPStatusResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static CheckGTAPPStatusResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CheckGTAPPStatusResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private CheckGTAPPStatusResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(CheckGTAPPStatusResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<CheckGTAPPStatusResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(CheckGTAPPStatusResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private CheckGTAPPStatusResponse result;
      
      private CheckGTAPPStatusResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          CheckGTAPPStatusResponse original = result;
          result = new CheckGTAPPStatusResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override CheckGTAPPStatusResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.CheckGTAPPStatusResponse.Descriptor; }
      }
      
      public override CheckGTAPPStatusResponse DefaultInstanceForType {
        get { return global::D3.Store.CheckGTAPPStatusResponse.DefaultInstance; }
      }
      
      public override CheckGTAPPStatusResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is CheckGTAPPStatusResponse) {
          return MergeFrom((CheckGTAPPStatusResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(CheckGTAPPStatusResponse other) {
        if (other == global::D3.Store.CheckGTAPPStatusResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasStatus) {
          Status = other.Status;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_checkGTAPPStatusResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _checkGTAPPStatusResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasStatus = input.ReadUInt32(ref result.status_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasStatus {
        get { return result.hasStatus; }
      }
      public uint Status {
        get { return result.Status; }
        set { SetStatus(value); }
      }
      public Builder SetStatus(uint value) {
        PrepareBuilder();
        result.hasStatus = true;
        result.status_ = value;
        return this;
      }
      public Builder ClearStatus() {
        PrepareBuilder();
        result.hasStatus = false;
        result.status_ = 0;
        return this;
      }
    }
    static CheckGTAPPStatusResponse() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GetGTAPPBalance : pb::GeneratedMessage<GetGTAPPBalance, GetGTAPPBalance.Builder> {
    private GetGTAPPBalance() { }
    private static readonly GetGTAPPBalance defaultInstance = new GetGTAPPBalance().MakeReadOnly();
    private static readonly string[] _getGTAPPBalanceFieldNames = new string[] { "balance", "held_balance" };
    private static readonly uint[] _getGTAPPBalanceFieldTags = new uint[] { 8, 16 };
    public static GetGTAPPBalance DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GetGTAPPBalance DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GetGTAPPBalance ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetGTAPPBalance__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GetGTAPPBalance, GetGTAPPBalance.Builder> InternalFieldAccessors {
      get { return global::D3.Store.Store.internal__static_D3_Store_GetGTAPPBalance__FieldAccessorTable; }
    }
    
    public const int BalanceFieldNumber = 1;
    private bool hasBalance;
    private long balance_;
    public bool HasBalance {
      get { return hasBalance; }
    }
    public long Balance {
      get { return balance_; }
    }
    
    public const int HeldBalanceFieldNumber = 2;
    private bool hasHeldBalance;
    private long heldBalance_;
    public bool HasHeldBalance {
      get { return hasHeldBalance; }
    }
    public long HeldBalance {
      get { return heldBalance_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _getGTAPPBalanceFieldNames;
      if (hasBalance) {
        output.WriteSInt64(1, field_names[0], Balance);
      }
      if (hasHeldBalance) {
        output.WriteSInt64(2, field_names[1], HeldBalance);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBalance) {
          size += pb::CodedOutputStream.ComputeSInt64Size(1, Balance);
        }
        if (hasHeldBalance) {
          size += pb::CodedOutputStream.ComputeSInt64Size(2, HeldBalance);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GetGTAPPBalance ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetGTAPPBalance ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetGTAPPBalance ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GetGTAPPBalance ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GetGTAPPBalance ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetGTAPPBalance ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GetGTAPPBalance ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GetGTAPPBalance ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GetGTAPPBalance ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GetGTAPPBalance ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GetGTAPPBalance MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GetGTAPPBalance prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GetGTAPPBalance, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GetGTAPPBalance cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GetGTAPPBalance result;
      
      private GetGTAPPBalance PrepareBuilder() {
        if (resultIsReadOnly) {
          GetGTAPPBalance original = result;
          result = new GetGTAPPBalance();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GetGTAPPBalance MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.Store.GetGTAPPBalance.Descriptor; }
      }
      
      public override GetGTAPPBalance DefaultInstanceForType {
        get { return global::D3.Store.GetGTAPPBalance.DefaultInstance; }
      }
      
      public override GetGTAPPBalance BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GetGTAPPBalance) {
          return MergeFrom((GetGTAPPBalance) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GetGTAPPBalance other) {
        if (other == global::D3.Store.GetGTAPPBalance.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBalance) {
          Balance = other.Balance;
        }
        if (other.HasHeldBalance) {
          HeldBalance = other.HeldBalance;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_getGTAPPBalanceFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _getGTAPPBalanceFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasBalance = input.ReadSInt64(ref result.balance_);
              break;
            }
            case 16: {
              result.hasHeldBalance = input.ReadSInt64(ref result.heldBalance_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasBalance {
        get { return result.hasBalance; }
      }
      public long Balance {
        get { return result.Balance; }
        set { SetBalance(value); }
      }
      public Builder SetBalance(long value) {
        PrepareBuilder();
        result.hasBalance = true;
        result.balance_ = value;
        return this;
      }
      public Builder ClearBalance() {
        PrepareBuilder();
        result.hasBalance = false;
        result.balance_ = 0;
        return this;
      }
      
      public bool HasHeldBalance {
        get { return result.hasHeldBalance; }
      }
      public long HeldBalance {
        get { return result.HeldBalance; }
        set { SetHeldBalance(value); }
      }
      public Builder SetHeldBalance(long value) {
        PrepareBuilder();
        result.hasHeldBalance = true;
        result.heldBalance_ = value;
        return this;
      }
      public Builder ClearHeldBalance() {
        PrepareBuilder();
        result.hasHeldBalance = false;
        result.heldBalance_ = 0;
        return this;
      }
    }
    static GetGTAPPBalance() {
      object.ReferenceEquals(global::D3.Store.Store.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
