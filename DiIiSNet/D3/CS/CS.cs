// Generated by ProtoGen, Version=2.4.1.473, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace D3.CS {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public static partial class CS {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_D3_CS_ToolTip__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.ToolTip, global::D3.CS.ToolTip.Builder> internal__static_D3_CS_ToolTip__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_CS_HeroesList__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.HeroesList, global::D3.CS.HeroesList.Builder> internal__static_D3_CS_HeroesList__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_CS_TooltipList__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.TooltipList, global::D3.CS.TooltipList.Builder> internal__static_D3_CS_TooltipList__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_CS_FallenHero__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.FallenHero, global::D3.CS.FallenHero.Builder> internal__static_D3_CS_FallenHero__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_CS_PersonalBests__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.PersonalBests, global::D3.CS.PersonalBests.Builder> internal__static_D3_CS_PersonalBests__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_CS_ConsumedLicense_deprecated__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.ConsumedLicense_deprecated, global::D3.CS.ConsumedLicense_deprecated.Builder> internal__static_D3_CS_ConsumedLicense_deprecated__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_CS_ConsumedLicenses_deprecated__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.ConsumedLicenses_deprecated, global::D3.CS.ConsumedLicenses_deprecated.Builder> internal__static_D3_CS_ConsumedLicenses_deprecated__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_CS_Snapshot__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.Snapshot, global::D3.CS.Snapshot.Builder> internal__static_D3_CS_Snapshot__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_CS_SnapshotVersion__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.SnapshotVersion, global::D3.CS.SnapshotVersion.Builder> internal__static_D3_CS_SnapshotVersion__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_CS_SnapshotVersions__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.SnapshotVersions, global::D3.CS.SnapshotVersions.Builder> internal__static_D3_CS_SnapshotVersions__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_CS_PartitionedGBID__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.PartitionedGBID, global::D3.CS.PartitionedGBID.Builder> internal__static_D3_CS_PartitionedGBID__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_CS_PartitionedGBIDList__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.PartitionedGBIDList, global::D3.CS.PartitionedGBIDList.Builder> internal__static_D3_CS_PartitionedGBIDList__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_CS_PartitionedGBIDCapQuantity__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.PartitionedGBIDCapQuantity, global::D3.CS.PartitionedGBIDCapQuantity.Builder> internal__static_D3_CS_PartitionedGBIDCapQuantity__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_CS_PartitionedGBIDCapQuantityList__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.PartitionedGBIDCapQuantityList, global::D3.CS.PartitionedGBIDCapQuantityList.Builder> internal__static_D3_CS_PartitionedGBIDCapQuantityList__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_CS_AccountData__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.CS.AccountData, global::D3.CS.AccountData.Builder> internal__static_D3_CS_AccountData__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static CS() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          "CghDUy5wcm90bxIFRDMuQ1MaC0l0ZW1zLnByb3RvGhNPbmxpbmVTZXJ2aWNl" + 
          "LnByb3RvGgpIZXJvLnByb3RvGg1BY2NvdW50LnByb3RvGg1Qcm9maWxlLnBy" + 
          "b3RvGgtHdWlsZC5wcm90bxoOU2V0dGluZ3MucHJvdG8aEUxlYWRlcmJvYXJk" + 
          "LnByb3RvGhJBY2hpZXZlbWVudHMucHJvdG8i9gMKB1Rvb2xUaXASMAoGaXRl" + 
          "bUlkGAEgAigLMhguRDMuT25saW5lU2VydmljZS5JdGVtSWRSBml0ZW1JZBIq" + 
          "ChBJdGVtUXVhbGl0eUxldmVsGAIgAigNUhBJdGVtUXVhbGl0eUxldmVsEhIK" + 
          "BE5hbWUYAyACKAlSBE5hbWUSEgoEVHlwZRgEIAIoCVIEVHlwZRIYCgdTZXRJ" + 
          "dGVtGAUgAigFUgdTZXRJdGVtEhYKBkZsYXZvchgGIAIoCVIGRmxhdm9yEhIK" + 
          "BENvc3QYByACKAlSBENvc3QSHgoKRHVyYWJpbGl0eRgIIAIoCVIKRHVyYWJp" + 
          "bGl0eRIcCglDbGFzc1JlcXMYCSACKAlSCUNsYXNzUmVxcxIiCgxSZXF1aXJl" + 
          "bWVudHMYCiACKAlSDFJlcXVpcmVtZW50cxI1ChZFbmhhbmNlbWVudF9kZXBy" + 
          "ZWNhdGVkGAsgASgJUhVFbmhhbmNlbWVudERlcHJlY2F0ZWQSHgoKU3RhY2tD" + 
          "b3VudBgMIAIoBFIKU3RhY2tDb3VudBIeCgpOdW1Tb2NrZXRzGA0gAigNUgpO" + 
          "dW1Tb2NrZXRzEiQKDUZpbGxlZFNvY2tldHMYDiACKA1SDUZpbGxlZFNvY2tl" + 
          "dHMSIAoLRGlzcGxheU5hbWUYDyACKAlSC0Rpc3BsYXlOYW1lIpsBCgpIZXJv" + 
          "ZXNMaXN0Ei0KB2RpZ2VzdHMYASACKAsyEy5EMy5IZXJvLkRpZ2VzdExpc3RS" + 
          "B2RpZ2VzdHMSLAoSY3VycmVudF9zZWFzb25fbnVtGAIgAigNUhBjdXJyZW50" + 
          "U2Vhc29uTnVtEjAKFGN1cnJlbnRfc2Vhc29uX3N0YXRlGAMgAigNUhJjdXJy" + 
          "ZW50U2Vhc29uU3RhdGUiOQoLVG9vbHRpcExpc3QSKgoIdG9vbHRpcHMYASAD" + 
          "KAsyDi5EMy5DUy5Ub29sVGlwUgh0b29sdGlwcyJ8CgpGYWxsZW5IZXJvEjEK" + 
          "B3Byb2ZpbGUYASACKAsyFy5EMy5Qcm9maWxlLkhlcm9Qcm9maWxlUgdwcm9m" + 
          "aWxlEicKBmRpZ2VzdBgCIAIoCzIPLkQzLkhlcm8uRGlnZXN0UgZkaWdlc3QS" + 
          "EgoEdGltZRgDIAIoCVIEdGltZSK0AQoNUGVyc29uYWxCZXN0cxJRCg5wYXJ0" + 
          "aXRpb25fdHlwZRgBIAIoDjIdLkQzLkxlYWRlcmJvYXJkLlBhcnRpdGlvblR5" + 
          "cGU6C1VOU1BFQ0lGSUVEUg1wYXJ0aXRpb25UeXBlEiEKDHBhcnRpdGlvbl9p" + 
          "ZBgCIAIoDVILcGFydGl0aW9uSWQSLQoGc2NvcmVzGAMgAygLMhUuRDMuTGVh" + 
          "ZGVyYm9hcmQuU2NvcmVSBnNjb3JlcyJNChpDb25zdW1lZExpY2Vuc2VfZGVw" + 
          "cmVjYXRlZBIOCgJpZBgBIAIoElICaWQSHwoLaW5zdGFuY2VfaWQYAiACKBJS" + 
          "Cmluc3RhbmNlSWQiWgobQ29uc3VtZWRMaWNlbnNlc19kZXByZWNhdGVkEjsK" + 
          "B2xpY2Vuc2UYASADKAsyIS5EMy5DUy5Db25zdW1lZExpY2Vuc2VfZGVwcmVj" + 
          "YXRlZFIHbGljZW5zZSKpCAoIU25hcHNob3QSGAoHdmVyc2lvbhgBIAIoBFIH" + 
          "dmVyc2lvbhI7CgpkZWZpbml0aW9uGAIgAigLMhsuRDMuQWNjb3VudC5TYXZl" + 
          "ZERlZmluaXRpb25SCmRlZmluaXRpb24SLgoFaGVyb3MYAyADKAsyGC5EMy5I" + 
          "ZXJvLlNhdmVkRGVmaW5pdGlvblIFaGVyb3MSQAoNaGVyb19wcm9maWxlcxgF" + 
          "IAIoCzIbLkQzLlByb2ZpbGUuSGVyb1Byb2ZpbGVMaXN0UgxoZXJvUHJvZmls" + 
          "ZXMSNAoMZmFsbGVuX2hlcm9zGAYgAygLMhEuRDMuQ1MuRmFsbGVuSGVyb1IL" + 
          "ZmFsbGVuSGVyb3MSJQoFbWFpbHMYByABKAsyDy5EMy5JdGVtcy5NYWlsc1IF" + 
          "bWFpbHMSHwoLY3JlYXRlX3RpbWUYCCABKA1SCmNyZWF0ZVRpbWUSRQoQYWNj" + 
          "b3VudF9wcm9maWxlcxgJIAMoCzIaLkQzLlByb2ZpbGUuQWNjb3VudFByb2Zp" + 
          "bGVSD2FjY291bnRQcm9maWxlcxI5CgphY2NvdW50X2lkGAogASgLMhouRDMu" + 
          "T25saW5lU2VydmljZS5FbnRpdHlJZFIJYWNjb3VudElkElgKGmRlcHJlY2F0" + 
          "ZWRfYWNjb3VudF9wcm9maWxlGAQgAigLMhouRDMuUHJvZmlsZS5BY2NvdW50" + 
          "UHJvZmlsZVIYZGVwcmVjYXRlZEFjY291bnRQcm9maWxlElEKEmd1aWxkX3Jl" + 
          "c3RyaWN0aW9ucxgLIAEoCzIiLkQzLkd1aWxkLkd1aWxkQWNjb3VudFJlc3Ry" + 
          "aWN0aW9uc1IRZ3VpbGRSZXN0cmljdGlvbnMSUgoVZ2FtZV9hY2NvdW50X3Nl" + 
          "dHRpbmdzGAwgASgLMh4uRDMuQ2xpZW50LkdhbWVBY2NvdW50U2V0dGluZ3NS" + 
          "E2dhbWVBY2NvdW50U2V0dGluZ3MSOAoLcHJlZmVyZW5jZXMYDSABKAsyFi5E" + 
          "My5DbGllbnQuUHJlZmVyZW5jZXNSC3ByZWZlcmVuY2VzEhYKBmJhbm5lZBgO" + 
          "IAEoCFIGYmFubmVkEkIKEmFsbF9wZXJzb25hbF9iZXN0cxgSIAMoCzIULkQz" + 
          "LkNTLlBlcnNvbmFsQmVzdHNSEGFsbFBlcnNvbmFsQmVzdHMSZAocZGVwcmVj" + 
          "YXRlZF9jb25zdW1lZF9saWNlbnNlcxgTIAEoCzIiLkQzLkNTLkNvbnN1bWVk" + 
          "TGljZW5zZXNfZGVwcmVjYXRlZFIaZGVwcmVjYXRlZENvbnN1bWVkTGljZW5z" + 
          "ZXMSVwoVYWNoaWV2ZW1lbnRfc25hcHNob3RzGBQgAygLMiIuRDMuQWNoaWV2" + 
          "ZW1lbnRzLlBhcnRpdGlvblNuYXBzaG90UhRhY2hpZXZlbWVudFNuYXBzaG90" + 
          "cyJYCg9TbmFwc2hvdFZlcnNpb24SGAoHdmVyc2lvbhgBIAIoBFIHdmVyc2lv" + 
          "bhIrCghzbmFwc2hvdBgCIAIoCzIPLkQzLkNTLlNuYXBzaG90UghzbmFwc2hv" + 
          "dCKmAQoQU25hcHNob3RWZXJzaW9ucxIyCgh2ZXJzaW9ucxgBIAMoCzIWLkQz" + 
          "LkNTLlNuYXBzaG90VmVyc2lvblIIdmVyc2lvbnMSLAoSY3VycmVudF9zZWFz" + 
          "b25fbnVtGAIgASgNUhBjdXJyZW50U2Vhc29uTnVtEjAKFGN1cnJlbnRfc2Vh" + 
          "c29uX3N0YXRlGAMgASgNUhJjdXJyZW50U2Vhc29uU3RhdGUiSAoPUGFydGl0" + 
          "aW9uZWRHQklEEhIKBGdiaWQYASACKA9SBGdiaWQSIQoMcGFydGl0aW9uX2lk" + 
          "GAIgAigNUgtwYXJ0aXRpb25JZCJaChNQYXJ0aXRpb25lZEdCSURMaXN0EkMK" + 
          "EXBhcnRpdGlvbmVkX2diaWRzGAEgAygLMhYuRDMuQ1MuUGFydGl0aW9uZWRH" + 
          "QklEUhBwYXJ0aXRpb25lZEdiaWRzInYKGlBhcnRpdGlvbmVkR0JJRENhcFF1" + 
          "YW50aXR5EhIKBGdiaWQYASACKA9SBGdiaWQSIQoMcGFydGl0aW9uX2lkGAIg" + 
          "AigNUgtwYXJ0aXRpb25JZBIhCgxjYXBfcXVhbnRpdHkYAyACKARSC2NhcFF1" + 
          "YW50aXR5InAKHlBhcnRpdGlvbmVkR0JJRENhcFF1YW50aXR5TGlzdBJOChFw" + 
          "YXJ0aXRpb25lZF9nYmlkcxgBIAMoCzIhLkQzLkNTLlBhcnRpdGlvbmVkR0JJ" + 
          "RENhcFF1YW50aXR5UhBwYXJ0aXRpb25lZEdiaWRzItEBCgtBY2NvdW50RGF0" + 
          "YRIqCgZkaWdlc3QYASACKAsyEi5EMy5BY2NvdW50LkRpZ2VzdFIGZGlnZXN0" + 
          "EjwKCnBhcnRpdGlvbnMYAiADKAsyHC5EMy5BY2NvdW50LkFjY291bnRQYXJ0" + 
          "aXRpb25SCnBhcnRpdGlvbnMSWAoaYWNjb3VudF93aWRlX2N1cnJlbmN5X2Rh" + 
          "dGEYAyABKAsyGy5EMy5JdGVtcy5DdXJyZW5jeVNhdmVkRGF0YVIXYWNjb3Vu" + 
          "dFdpZGVDdXJyZW5jeURhdGE=");
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_D3_CS_ToolTip__Descriptor = Descriptor.MessageTypes[0];
        internal__static_D3_CS_ToolTip__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.ToolTip, global::D3.CS.ToolTip.Builder>(internal__static_D3_CS_ToolTip__Descriptor,
                new string[] { "ItemId", "ItemQualityLevel", "Name", "Type", "SetItem", "Flavor", "Cost", "Durability", "ClassReqs", "Requirements", "EnhancementDeprecated", "StackCount", "NumSockets", "FilledSockets", "DisplayName", });
        internal__static_D3_CS_HeroesList__Descriptor = Descriptor.MessageTypes[1];
        internal__static_D3_CS_HeroesList__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.HeroesList, global::D3.CS.HeroesList.Builder>(internal__static_D3_CS_HeroesList__Descriptor,
                new string[] { "Digests", "CurrentSeasonNum", "CurrentSeasonState", });
        internal__static_D3_CS_TooltipList__Descriptor = Descriptor.MessageTypes[2];
        internal__static_D3_CS_TooltipList__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.TooltipList, global::D3.CS.TooltipList.Builder>(internal__static_D3_CS_TooltipList__Descriptor,
                new string[] { "Tooltips", });
        internal__static_D3_CS_FallenHero__Descriptor = Descriptor.MessageTypes[3];
        internal__static_D3_CS_FallenHero__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.FallenHero, global::D3.CS.FallenHero.Builder>(internal__static_D3_CS_FallenHero__Descriptor,
                new string[] { "Profile", "Digest", "Time", });
        internal__static_D3_CS_PersonalBests__Descriptor = Descriptor.MessageTypes[4];
        internal__static_D3_CS_PersonalBests__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.PersonalBests, global::D3.CS.PersonalBests.Builder>(internal__static_D3_CS_PersonalBests__Descriptor,
                new string[] { "PartitionType", "PartitionId", "Scores", });
        internal__static_D3_CS_ConsumedLicense_deprecated__Descriptor = Descriptor.MessageTypes[5];
        internal__static_D3_CS_ConsumedLicense_deprecated__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.ConsumedLicense_deprecated, global::D3.CS.ConsumedLicense_deprecated.Builder>(internal__static_D3_CS_ConsumedLicense_deprecated__Descriptor,
                new string[] { "Id", "InstanceId", });
        internal__static_D3_CS_ConsumedLicenses_deprecated__Descriptor = Descriptor.MessageTypes[6];
        internal__static_D3_CS_ConsumedLicenses_deprecated__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.ConsumedLicenses_deprecated, global::D3.CS.ConsumedLicenses_deprecated.Builder>(internal__static_D3_CS_ConsumedLicenses_deprecated__Descriptor,
                new string[] { "License", });
        internal__static_D3_CS_Snapshot__Descriptor = Descriptor.MessageTypes[7];
        internal__static_D3_CS_Snapshot__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.Snapshot, global::D3.CS.Snapshot.Builder>(internal__static_D3_CS_Snapshot__Descriptor,
                new string[] { "Version", "Definition", "Heros", "HeroProfiles", "FallenHeros", "Mails", "CreateTime", "AccountProfiles", "AccountId", "DeprecatedAccountProfile", "GuildRestrictions", "GameAccountSettings", "Preferences", "Banned", "AllPersonalBests", "DeprecatedConsumedLicenses", "AchievementSnapshots", });
        internal__static_D3_CS_SnapshotVersion__Descriptor = Descriptor.MessageTypes[8];
        internal__static_D3_CS_SnapshotVersion__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.SnapshotVersion, global::D3.CS.SnapshotVersion.Builder>(internal__static_D3_CS_SnapshotVersion__Descriptor,
                new string[] { "Version", "Snapshot", });
        internal__static_D3_CS_SnapshotVersions__Descriptor = Descriptor.MessageTypes[9];
        internal__static_D3_CS_SnapshotVersions__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.SnapshotVersions, global::D3.CS.SnapshotVersions.Builder>(internal__static_D3_CS_SnapshotVersions__Descriptor,
                new string[] { "Versions", "CurrentSeasonNum", "CurrentSeasonState", });
        internal__static_D3_CS_PartitionedGBID__Descriptor = Descriptor.MessageTypes[10];
        internal__static_D3_CS_PartitionedGBID__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.PartitionedGBID, global::D3.CS.PartitionedGBID.Builder>(internal__static_D3_CS_PartitionedGBID__Descriptor,
                new string[] { "Gbid", "PartitionId", });
        internal__static_D3_CS_PartitionedGBIDList__Descriptor = Descriptor.MessageTypes[11];
        internal__static_D3_CS_PartitionedGBIDList__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.PartitionedGBIDList, global::D3.CS.PartitionedGBIDList.Builder>(internal__static_D3_CS_PartitionedGBIDList__Descriptor,
                new string[] { "PartitionedGbids", });
        internal__static_D3_CS_PartitionedGBIDCapQuantity__Descriptor = Descriptor.MessageTypes[12];
        internal__static_D3_CS_PartitionedGBIDCapQuantity__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.PartitionedGBIDCapQuantity, global::D3.CS.PartitionedGBIDCapQuantity.Builder>(internal__static_D3_CS_PartitionedGBIDCapQuantity__Descriptor,
                new string[] { "Gbid", "PartitionId", "CapQuantity", });
        internal__static_D3_CS_PartitionedGBIDCapQuantityList__Descriptor = Descriptor.MessageTypes[13];
        internal__static_D3_CS_PartitionedGBIDCapQuantityList__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.PartitionedGBIDCapQuantityList, global::D3.CS.PartitionedGBIDCapQuantityList.Builder>(internal__static_D3_CS_PartitionedGBIDCapQuantityList__Descriptor,
                new string[] { "PartitionedGbids", });
        internal__static_D3_CS_AccountData__Descriptor = Descriptor.MessageTypes[14];
        internal__static_D3_CS_AccountData__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.CS.AccountData, global::D3.CS.AccountData.Builder>(internal__static_D3_CS_AccountData__Descriptor,
                new string[] { "Digest", "Partitions", "AccountWideCurrencyData", });
        pb::ExtensionRegistry registry = pb::ExtensionRegistry.CreateInstance();
        RegisterAllExtensions(registry);
        global::D3.Items.Items.RegisterAllExtensions(registry);
        global::D3.OnlineService.OnlineService.RegisterAllExtensions(registry);
        global::D3.Hero.Hero.RegisterAllExtensions(registry);
        global::D3.Account.Account.RegisterAllExtensions(registry);
        global::D3.Profile.Profile.RegisterAllExtensions(registry);
        global::D3.Guild.Proto.Guild.RegisterAllExtensions(registry);
        global::D3.Client.Settings.RegisterAllExtensions(registry);
        global::D3.Leaderboard.Leaderboard.RegisterAllExtensions(registry);
        global::D3.Achievements.Achievements.RegisterAllExtensions(registry);
        return registry;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          global::D3.Items.Items.Descriptor, 
          global::D3.OnlineService.OnlineService.Descriptor, 
          global::D3.Hero.Hero.Descriptor, 
          global::D3.Account.Account.Descriptor, 
          global::D3.Profile.Profile.Descriptor, 
          global::D3.Guild.Proto.Guild.Descriptor, 
          global::D3.Client.Settings.Descriptor, 
          global::D3.Leaderboard.Leaderboard.Descriptor, 
          global::D3.Achievements.Achievements.Descriptor, 
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ToolTip : pb::GeneratedMessage<ToolTip, ToolTip.Builder> {
    private ToolTip() { }
    private static readonly ToolTip defaultInstance = new ToolTip().MakeReadOnly();
    private static readonly string[] _toolTipFieldNames = new string[] { "ClassReqs", "Cost", "DisplayName", "Durability", "Enhancement_deprecated", "FilledSockets", "Flavor", "ItemQualityLevel", "Name", "NumSockets", "Requirements", "SetItem", "StackCount", "Type", "itemId" };
    private static readonly uint[] _toolTipFieldTags = new uint[] { 74, 58, 122, 66, 90, 112, 50, 16, 26, 104, 82, 40, 96, 34, 10 };
    public static ToolTip DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ToolTip DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ToolTip ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_ToolTip__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ToolTip, ToolTip.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_ToolTip__FieldAccessorTable; }
    }
    
    public const int ItemIdFieldNumber = 1;
    private bool hasItemId;
    private global::D3.OnlineService.ItemId itemId_;
    public bool HasItemId {
      get { return hasItemId; }
    }
    public global::D3.OnlineService.ItemId ItemId {
      get { return itemId_ ?? global::D3.OnlineService.ItemId.DefaultInstance; }
    }
    
    public const int ItemQualityLevelFieldNumber = 2;
    private bool hasItemQualityLevel;
    private uint itemQualityLevel_;
    public bool HasItemQualityLevel {
      get { return hasItemQualityLevel; }
    }
    public uint ItemQualityLevel {
      get { return itemQualityLevel_; }
    }
    
    public const int NameFieldNumber = 3;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int TypeFieldNumber = 4;
    private bool hasType;
    private string type_ = "";
    public bool HasType {
      get { return hasType; }
    }
    public string Type {
      get { return type_; }
    }
    
    public const int SetItemFieldNumber = 5;
    private bool hasSetItem;
    private int setItem_;
    public bool HasSetItem {
      get { return hasSetItem; }
    }
    public int SetItem {
      get { return setItem_; }
    }
    
    public const int FlavorFieldNumber = 6;
    private bool hasFlavor;
    private string flavor_ = "";
    public bool HasFlavor {
      get { return hasFlavor; }
    }
    public string Flavor {
      get { return flavor_; }
    }
    
    public const int CostFieldNumber = 7;
    private bool hasCost;
    private string cost_ = "";
    public bool HasCost {
      get { return hasCost; }
    }
    public string Cost {
      get { return cost_; }
    }
    
    public const int DurabilityFieldNumber = 8;
    private bool hasDurability;
    private string durability_ = "";
    public bool HasDurability {
      get { return hasDurability; }
    }
    public string Durability {
      get { return durability_; }
    }
    
    public const int ClassReqsFieldNumber = 9;
    private bool hasClassReqs;
    private string classReqs_ = "";
    public bool HasClassReqs {
      get { return hasClassReqs; }
    }
    public string ClassReqs {
      get { return classReqs_; }
    }
    
    public const int RequirementsFieldNumber = 10;
    private bool hasRequirements;
    private string requirements_ = "";
    public bool HasRequirements {
      get { return hasRequirements; }
    }
    public string Requirements {
      get { return requirements_; }
    }
    
    public const int EnhancementDeprecatedFieldNumber = 11;
    private bool hasEnhancementDeprecated;
    private string enhancementDeprecated_ = "";
    public bool HasEnhancementDeprecated {
      get { return hasEnhancementDeprecated; }
    }
    public string EnhancementDeprecated {
      get { return enhancementDeprecated_; }
    }
    
    public const int StackCountFieldNumber = 12;
    private bool hasStackCount;
    private ulong stackCount_;
    public bool HasStackCount {
      get { return hasStackCount; }
    }
    public ulong StackCount {
      get { return stackCount_; }
    }
    
    public const int NumSocketsFieldNumber = 13;
    private bool hasNumSockets;
    private uint numSockets_;
    public bool HasNumSockets {
      get { return hasNumSockets; }
    }
    public uint NumSockets {
      get { return numSockets_; }
    }
    
    public const int FilledSocketsFieldNumber = 14;
    private bool hasFilledSockets;
    private uint filledSockets_;
    public bool HasFilledSockets {
      get { return hasFilledSockets; }
    }
    public uint FilledSockets {
      get { return filledSockets_; }
    }
    
    public const int DisplayNameFieldNumber = 15;
    private bool hasDisplayName;
    private string displayName_ = "";
    public bool HasDisplayName {
      get { return hasDisplayName; }
    }
    public string DisplayName {
      get { return displayName_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasItemId) return false;
        if (!hasItemQualityLevel) return false;
        if (!hasName) return false;
        if (!hasType) return false;
        if (!hasSetItem) return false;
        if (!hasFlavor) return false;
        if (!hasCost) return false;
        if (!hasDurability) return false;
        if (!hasClassReqs) return false;
        if (!hasRequirements) return false;
        if (!hasStackCount) return false;
        if (!hasNumSockets) return false;
        if (!hasFilledSockets) return false;
        if (!hasDisplayName) return false;
        if (!ItemId.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _toolTipFieldNames;
      if (hasItemId) {
        output.WriteMessage(1, field_names[14], ItemId);
      }
      if (hasItemQualityLevel) {
        output.WriteUInt32(2, field_names[7], ItemQualityLevel);
      }
      if (hasName) {
        output.WriteString(3, field_names[8], Name);
      }
      if (hasType) {
        output.WriteString(4, field_names[13], Type);
      }
      if (hasSetItem) {
        output.WriteInt32(5, field_names[11], SetItem);
      }
      if (hasFlavor) {
        output.WriteString(6, field_names[6], Flavor);
      }
      if (hasCost) {
        output.WriteString(7, field_names[1], Cost);
      }
      if (hasDurability) {
        output.WriteString(8, field_names[3], Durability);
      }
      if (hasClassReqs) {
        output.WriteString(9, field_names[0], ClassReqs);
      }
      if (hasRequirements) {
        output.WriteString(10, field_names[10], Requirements);
      }
      if (hasEnhancementDeprecated) {
        output.WriteString(11, field_names[4], EnhancementDeprecated);
      }
      if (hasStackCount) {
        output.WriteUInt64(12, field_names[12], StackCount);
      }
      if (hasNumSockets) {
        output.WriteUInt32(13, field_names[9], NumSockets);
      }
      if (hasFilledSockets) {
        output.WriteUInt32(14, field_names[5], FilledSockets);
      }
      if (hasDisplayName) {
        output.WriteString(15, field_names[2], DisplayName);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasItemId) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, ItemId);
        }
        if (hasItemQualityLevel) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, ItemQualityLevel);
        }
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(3, Name);
        }
        if (hasType) {
          size += pb::CodedOutputStream.ComputeStringSize(4, Type);
        }
        if (hasSetItem) {
          size += pb::CodedOutputStream.ComputeInt32Size(5, SetItem);
        }
        if (hasFlavor) {
          size += pb::CodedOutputStream.ComputeStringSize(6, Flavor);
        }
        if (hasCost) {
          size += pb::CodedOutputStream.ComputeStringSize(7, Cost);
        }
        if (hasDurability) {
          size += pb::CodedOutputStream.ComputeStringSize(8, Durability);
        }
        if (hasClassReqs) {
          size += pb::CodedOutputStream.ComputeStringSize(9, ClassReqs);
        }
        if (hasRequirements) {
          size += pb::CodedOutputStream.ComputeStringSize(10, Requirements);
        }
        if (hasEnhancementDeprecated) {
          size += pb::CodedOutputStream.ComputeStringSize(11, EnhancementDeprecated);
        }
        if (hasStackCount) {
          size += pb::CodedOutputStream.ComputeUInt64Size(12, StackCount);
        }
        if (hasNumSockets) {
          size += pb::CodedOutputStream.ComputeUInt32Size(13, NumSockets);
        }
        if (hasFilledSockets) {
          size += pb::CodedOutputStream.ComputeUInt32Size(14, FilledSockets);
        }
        if (hasDisplayName) {
          size += pb::CodedOutputStream.ComputeStringSize(15, DisplayName);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ToolTip ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ToolTip ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ToolTip ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ToolTip ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ToolTip ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ToolTip ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ToolTip ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ToolTip ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ToolTip ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ToolTip ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ToolTip MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ToolTip prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ToolTip, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ToolTip cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ToolTip result;
      
      private ToolTip PrepareBuilder() {
        if (resultIsReadOnly) {
          ToolTip original = result;
          result = new ToolTip();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ToolTip MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.ToolTip.Descriptor; }
      }
      
      public override ToolTip DefaultInstanceForType {
        get { return global::D3.CS.ToolTip.DefaultInstance; }
      }
      
      public override ToolTip BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ToolTip) {
          return MergeFrom((ToolTip) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ToolTip other) {
        if (other == global::D3.CS.ToolTip.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasItemId) {
          MergeItemId(other.ItemId);
        }
        if (other.HasItemQualityLevel) {
          ItemQualityLevel = other.ItemQualityLevel;
        }
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasSetItem) {
          SetItem = other.SetItem;
        }
        if (other.HasFlavor) {
          Flavor = other.Flavor;
        }
        if (other.HasCost) {
          Cost = other.Cost;
        }
        if (other.HasDurability) {
          Durability = other.Durability;
        }
        if (other.HasClassReqs) {
          ClassReqs = other.ClassReqs;
        }
        if (other.HasRequirements) {
          Requirements = other.Requirements;
        }
        if (other.HasEnhancementDeprecated) {
          EnhancementDeprecated = other.EnhancementDeprecated;
        }
        if (other.HasStackCount) {
          StackCount = other.StackCount;
        }
        if (other.HasNumSockets) {
          NumSockets = other.NumSockets;
        }
        if (other.HasFilledSockets) {
          FilledSockets = other.FilledSockets;
        }
        if (other.HasDisplayName) {
          DisplayName = other.DisplayName;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_toolTipFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _toolTipFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.OnlineService.ItemId.Builder subBuilder = global::D3.OnlineService.ItemId.CreateBuilder();
              if (result.hasItemId) {
                subBuilder.MergeFrom(ItemId);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              ItemId = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              result.hasItemQualityLevel = input.ReadUInt32(ref result.itemQualityLevel_);
              break;
            }
            case 26: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 34: {
              result.hasType = input.ReadString(ref result.type_);
              break;
            }
            case 40: {
              result.hasSetItem = input.ReadInt32(ref result.setItem_);
              break;
            }
            case 50: {
              result.hasFlavor = input.ReadString(ref result.flavor_);
              break;
            }
            case 58: {
              result.hasCost = input.ReadString(ref result.cost_);
              break;
            }
            case 66: {
              result.hasDurability = input.ReadString(ref result.durability_);
              break;
            }
            case 74: {
              result.hasClassReqs = input.ReadString(ref result.classReqs_);
              break;
            }
            case 82: {
              result.hasRequirements = input.ReadString(ref result.requirements_);
              break;
            }
            case 90: {
              result.hasEnhancementDeprecated = input.ReadString(ref result.enhancementDeprecated_);
              break;
            }
            case 96: {
              result.hasStackCount = input.ReadUInt64(ref result.stackCount_);
              break;
            }
            case 104: {
              result.hasNumSockets = input.ReadUInt32(ref result.numSockets_);
              break;
            }
            case 112: {
              result.hasFilledSockets = input.ReadUInt32(ref result.filledSockets_);
              break;
            }
            case 122: {
              result.hasDisplayName = input.ReadString(ref result.displayName_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasItemId {
       get { return result.hasItemId; }
      }
      public global::D3.OnlineService.ItemId ItemId {
        get { return result.ItemId; }
        set { SetItemId(value); }
      }
      public Builder SetItemId(global::D3.OnlineService.ItemId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasItemId = true;
        result.itemId_ = value;
        return this;
      }
      public Builder SetItemId(global::D3.OnlineService.ItemId.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasItemId = true;
        result.itemId_ = builderForValue.Build();
        return this;
      }
      public Builder MergeItemId(global::D3.OnlineService.ItemId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasItemId &&
            result.itemId_ != global::D3.OnlineService.ItemId.DefaultInstance) {
            result.itemId_ = global::D3.OnlineService.ItemId.CreateBuilder(result.itemId_).MergeFrom(value).BuildPartial();
        } else {
          result.itemId_ = value;
        }
        result.hasItemId = true;
        return this;
      }
      public Builder ClearItemId() {
        PrepareBuilder();
        result.hasItemId = false;
        result.itemId_ = null;
        return this;
      }
      
      public bool HasItemQualityLevel {
        get { return result.hasItemQualityLevel; }
      }
      public uint ItemQualityLevel {
        get { return result.ItemQualityLevel; }
        set { SetItemQualityLevel(value); }
      }
      public Builder SetItemQualityLevel(uint value) {
        PrepareBuilder();
        result.hasItemQualityLevel = true;
        result.itemQualityLevel_ = value;
        return this;
      }
      public Builder ClearItemQualityLevel() {
        PrepareBuilder();
        result.hasItemQualityLevel = false;
        result.itemQualityLevel_ = 0;
        return this;
      }
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasType {
        get { return result.hasType; }
      }
      public string Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = "";
        return this;
      }
      
      public bool HasSetItem {
        get { return result.hasSetItem; }
      }
      public int SetItem {
        get { return result.SetItem; }
        set { SetSetItem(value); }
      }
      public Builder SetSetItem(int value) {
        PrepareBuilder();
        result.hasSetItem = true;
        result.setItem_ = value;
        return this;
      }
      public Builder ClearSetItem() {
        PrepareBuilder();
        result.hasSetItem = false;
        result.setItem_ = 0;
        return this;
      }
      
      public bool HasFlavor {
        get { return result.hasFlavor; }
      }
      public string Flavor {
        get { return result.Flavor; }
        set { SetFlavor(value); }
      }
      public Builder SetFlavor(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasFlavor = true;
        result.flavor_ = value;
        return this;
      }
      public Builder ClearFlavor() {
        PrepareBuilder();
        result.hasFlavor = false;
        result.flavor_ = "";
        return this;
      }
      
      public bool HasCost {
        get { return result.hasCost; }
      }
      public string Cost {
        get { return result.Cost; }
        set { SetCost(value); }
      }
      public Builder SetCost(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCost = true;
        result.cost_ = value;
        return this;
      }
      public Builder ClearCost() {
        PrepareBuilder();
        result.hasCost = false;
        result.cost_ = "";
        return this;
      }
      
      public bool HasDurability {
        get { return result.hasDurability; }
      }
      public string Durability {
        get { return result.Durability; }
        set { SetDurability(value); }
      }
      public Builder SetDurability(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDurability = true;
        result.durability_ = value;
        return this;
      }
      public Builder ClearDurability() {
        PrepareBuilder();
        result.hasDurability = false;
        result.durability_ = "";
        return this;
      }
      
      public bool HasClassReqs {
        get { return result.hasClassReqs; }
      }
      public string ClassReqs {
        get { return result.ClassReqs; }
        set { SetClassReqs(value); }
      }
      public Builder SetClassReqs(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasClassReqs = true;
        result.classReqs_ = value;
        return this;
      }
      public Builder ClearClassReqs() {
        PrepareBuilder();
        result.hasClassReqs = false;
        result.classReqs_ = "";
        return this;
      }
      
      public bool HasRequirements {
        get { return result.hasRequirements; }
      }
      public string Requirements {
        get { return result.Requirements; }
        set { SetRequirements(value); }
      }
      public Builder SetRequirements(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRequirements = true;
        result.requirements_ = value;
        return this;
      }
      public Builder ClearRequirements() {
        PrepareBuilder();
        result.hasRequirements = false;
        result.requirements_ = "";
        return this;
      }
      
      public bool HasEnhancementDeprecated {
        get { return result.hasEnhancementDeprecated; }
      }
      public string EnhancementDeprecated {
        get { return result.EnhancementDeprecated; }
        set { SetEnhancementDeprecated(value); }
      }
      public Builder SetEnhancementDeprecated(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasEnhancementDeprecated = true;
        result.enhancementDeprecated_ = value;
        return this;
      }
      public Builder ClearEnhancementDeprecated() {
        PrepareBuilder();
        result.hasEnhancementDeprecated = false;
        result.enhancementDeprecated_ = "";
        return this;
      }
      
      public bool HasStackCount {
        get { return result.hasStackCount; }
      }
      public ulong StackCount {
        get { return result.StackCount; }
        set { SetStackCount(value); }
      }
      public Builder SetStackCount(ulong value) {
        PrepareBuilder();
        result.hasStackCount = true;
        result.stackCount_ = value;
        return this;
      }
      public Builder ClearStackCount() {
        PrepareBuilder();
        result.hasStackCount = false;
        result.stackCount_ = 0UL;
        return this;
      }
      
      public bool HasNumSockets {
        get { return result.hasNumSockets; }
      }
      public uint NumSockets {
        get { return result.NumSockets; }
        set { SetNumSockets(value); }
      }
      public Builder SetNumSockets(uint value) {
        PrepareBuilder();
        result.hasNumSockets = true;
        result.numSockets_ = value;
        return this;
      }
      public Builder ClearNumSockets() {
        PrepareBuilder();
        result.hasNumSockets = false;
        result.numSockets_ = 0;
        return this;
      }
      
      public bool HasFilledSockets {
        get { return result.hasFilledSockets; }
      }
      public uint FilledSockets {
        get { return result.FilledSockets; }
        set { SetFilledSockets(value); }
      }
      public Builder SetFilledSockets(uint value) {
        PrepareBuilder();
        result.hasFilledSockets = true;
        result.filledSockets_ = value;
        return this;
      }
      public Builder ClearFilledSockets() {
        PrepareBuilder();
        result.hasFilledSockets = false;
        result.filledSockets_ = 0;
        return this;
      }
      
      public bool HasDisplayName {
        get { return result.hasDisplayName; }
      }
      public string DisplayName {
        get { return result.DisplayName; }
        set { SetDisplayName(value); }
      }
      public Builder SetDisplayName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDisplayName = true;
        result.displayName_ = value;
        return this;
      }
      public Builder ClearDisplayName() {
        PrepareBuilder();
        result.hasDisplayName = false;
        result.displayName_ = "";
        return this;
      }
    }
    static ToolTip() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class HeroesList : pb::GeneratedMessage<HeroesList, HeroesList.Builder> {
    private HeroesList() { }
    private static readonly HeroesList defaultInstance = new HeroesList().MakeReadOnly();
    private static readonly string[] _heroesListFieldNames = new string[] { "current_season_num", "current_season_state", "digests" };
    private static readonly uint[] _heroesListFieldTags = new uint[] { 16, 24, 10 };
    public static HeroesList DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override HeroesList DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override HeroesList ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_HeroesList__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<HeroesList, HeroesList.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_HeroesList__FieldAccessorTable; }
    }
    
    public const int DigestsFieldNumber = 1;
    private bool hasDigests;
    private global::D3.Hero.DigestList digests_;
    public bool HasDigests {
      get { return hasDigests; }
    }
    public global::D3.Hero.DigestList Digests {
      get { return digests_ ?? global::D3.Hero.DigestList.DefaultInstance; }
    }
    
    public const int CurrentSeasonNumFieldNumber = 2;
    private bool hasCurrentSeasonNum;
    private uint currentSeasonNum_;
    public bool HasCurrentSeasonNum {
      get { return hasCurrentSeasonNum; }
    }
    public uint CurrentSeasonNum {
      get { return currentSeasonNum_; }
    }
    
    public const int CurrentSeasonStateFieldNumber = 3;
    private bool hasCurrentSeasonState;
    private uint currentSeasonState_;
    public bool HasCurrentSeasonState {
      get { return hasCurrentSeasonState; }
    }
    public uint CurrentSeasonState {
      get { return currentSeasonState_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasDigests) return false;
        if (!hasCurrentSeasonNum) return false;
        if (!hasCurrentSeasonState) return false;
        if (!Digests.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _heroesListFieldNames;
      if (hasDigests) {
        output.WriteMessage(1, field_names[2], Digests);
      }
      if (hasCurrentSeasonNum) {
        output.WriteUInt32(2, field_names[0], CurrentSeasonNum);
      }
      if (hasCurrentSeasonState) {
        output.WriteUInt32(3, field_names[1], CurrentSeasonState);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasDigests) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Digests);
        }
        if (hasCurrentSeasonNum) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, CurrentSeasonNum);
        }
        if (hasCurrentSeasonState) {
          size += pb::CodedOutputStream.ComputeUInt32Size(3, CurrentSeasonState);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static HeroesList ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HeroesList ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HeroesList ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HeroesList ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HeroesList ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HeroesList ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static HeroesList ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static HeroesList ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static HeroesList ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HeroesList ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private HeroesList MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(HeroesList prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<HeroesList, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(HeroesList cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private HeroesList result;
      
      private HeroesList PrepareBuilder() {
        if (resultIsReadOnly) {
          HeroesList original = result;
          result = new HeroesList();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override HeroesList MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.HeroesList.Descriptor; }
      }
      
      public override HeroesList DefaultInstanceForType {
        get { return global::D3.CS.HeroesList.DefaultInstance; }
      }
      
      public override HeroesList BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is HeroesList) {
          return MergeFrom((HeroesList) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(HeroesList other) {
        if (other == global::D3.CS.HeroesList.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasDigests) {
          MergeDigests(other.Digests);
        }
        if (other.HasCurrentSeasonNum) {
          CurrentSeasonNum = other.CurrentSeasonNum;
        }
        if (other.HasCurrentSeasonState) {
          CurrentSeasonState = other.CurrentSeasonState;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_heroesListFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _heroesListFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.Hero.DigestList.Builder subBuilder = global::D3.Hero.DigestList.CreateBuilder();
              if (result.hasDigests) {
                subBuilder.MergeFrom(Digests);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Digests = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              result.hasCurrentSeasonNum = input.ReadUInt32(ref result.currentSeasonNum_);
              break;
            }
            case 24: {
              result.hasCurrentSeasonState = input.ReadUInt32(ref result.currentSeasonState_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasDigests {
       get { return result.hasDigests; }
      }
      public global::D3.Hero.DigestList Digests {
        get { return result.Digests; }
        set { SetDigests(value); }
      }
      public Builder SetDigests(global::D3.Hero.DigestList value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDigests = true;
        result.digests_ = value;
        return this;
      }
      public Builder SetDigests(global::D3.Hero.DigestList.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasDigests = true;
        result.digests_ = builderForValue.Build();
        return this;
      }
      public Builder MergeDigests(global::D3.Hero.DigestList value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasDigests &&
            result.digests_ != global::D3.Hero.DigestList.DefaultInstance) {
            result.digests_ = global::D3.Hero.DigestList.CreateBuilder(result.digests_).MergeFrom(value).BuildPartial();
        } else {
          result.digests_ = value;
        }
        result.hasDigests = true;
        return this;
      }
      public Builder ClearDigests() {
        PrepareBuilder();
        result.hasDigests = false;
        result.digests_ = null;
        return this;
      }
      
      public bool HasCurrentSeasonNum {
        get { return result.hasCurrentSeasonNum; }
      }
      public uint CurrentSeasonNum {
        get { return result.CurrentSeasonNum; }
        set { SetCurrentSeasonNum(value); }
      }
      public Builder SetCurrentSeasonNum(uint value) {
        PrepareBuilder();
        result.hasCurrentSeasonNum = true;
        result.currentSeasonNum_ = value;
        return this;
      }
      public Builder ClearCurrentSeasonNum() {
        PrepareBuilder();
        result.hasCurrentSeasonNum = false;
        result.currentSeasonNum_ = 0;
        return this;
      }
      
      public bool HasCurrentSeasonState {
        get { return result.hasCurrentSeasonState; }
      }
      public uint CurrentSeasonState {
        get { return result.CurrentSeasonState; }
        set { SetCurrentSeasonState(value); }
      }
      public Builder SetCurrentSeasonState(uint value) {
        PrepareBuilder();
        result.hasCurrentSeasonState = true;
        result.currentSeasonState_ = value;
        return this;
      }
      public Builder ClearCurrentSeasonState() {
        PrepareBuilder();
        result.hasCurrentSeasonState = false;
        result.currentSeasonState_ = 0;
        return this;
      }
    }
    static HeroesList() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class TooltipList : pb::GeneratedMessage<TooltipList, TooltipList.Builder> {
    private TooltipList() { }
    private static readonly TooltipList defaultInstance = new TooltipList().MakeReadOnly();
    private static readonly string[] _tooltipListFieldNames = new string[] { "tooltips" };
    private static readonly uint[] _tooltipListFieldTags = new uint[] { 10 };
    public static TooltipList DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override TooltipList DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TooltipList ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_TooltipList__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<TooltipList, TooltipList.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_TooltipList__FieldAccessorTable; }
    }
    
    public const int TooltipsFieldNumber = 1;
    private pbc::PopsicleList<global::D3.CS.ToolTip> tooltips_ = new pbc::PopsicleList<global::D3.CS.ToolTip>();
    public scg::IList<global::D3.CS.ToolTip> TooltipsList {
      get { return tooltips_; }
    }
    public int TooltipsCount {
      get { return tooltips_.Count; }
    }
    public global::D3.CS.ToolTip GetTooltips(int index) {
      return tooltips_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::D3.CS.ToolTip element in TooltipsList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tooltipListFieldNames;
      if (tooltips_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], tooltips_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::D3.CS.ToolTip element in TooltipsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static TooltipList ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static TooltipList ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static TooltipList ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static TooltipList ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static TooltipList ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static TooltipList ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static TooltipList ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static TooltipList ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static TooltipList ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static TooltipList ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TooltipList MakeReadOnly() {
      tooltips_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(TooltipList prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<TooltipList, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TooltipList cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TooltipList result;
      
      private TooltipList PrepareBuilder() {
        if (resultIsReadOnly) {
          TooltipList original = result;
          result = new TooltipList();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TooltipList MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.TooltipList.Descriptor; }
      }
      
      public override TooltipList DefaultInstanceForType {
        get { return global::D3.CS.TooltipList.DefaultInstance; }
      }
      
      public override TooltipList BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is TooltipList) {
          return MergeFrom((TooltipList) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TooltipList other) {
        if (other == global::D3.CS.TooltipList.DefaultInstance) return this;
        PrepareBuilder();
        if (other.tooltips_.Count != 0) {
          result.tooltips_.Add(other.tooltips_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tooltipListFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tooltipListFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.tooltips_, global::D3.CS.ToolTip.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::D3.CS.ToolTip> TooltipsList {
        get { return PrepareBuilder().tooltips_; }
      }
      public int TooltipsCount {
        get { return result.TooltipsCount; }
      }
      public global::D3.CS.ToolTip GetTooltips(int index) {
        return result.GetTooltips(index);
      }
      public Builder SetTooltips(int index, global::D3.CS.ToolTip value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.tooltips_[index] = value;
        return this;
      }
      public Builder SetTooltips(int index, global::D3.CS.ToolTip.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.tooltips_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddTooltips(global::D3.CS.ToolTip value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.tooltips_.Add(value);
        return this;
      }
      public Builder AddTooltips(global::D3.CS.ToolTip.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.tooltips_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeTooltips(scg::IEnumerable<global::D3.CS.ToolTip> values) {
        PrepareBuilder();
        result.tooltips_.Add(values);
        return this;
      }
      public Builder ClearTooltips() {
        PrepareBuilder();
        result.tooltips_.Clear();
        return this;
      }
    }
    static TooltipList() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class FallenHero : pb::GeneratedMessage<FallenHero, FallenHero.Builder> {
    private FallenHero() { }
    private static readonly FallenHero defaultInstance = new FallenHero().MakeReadOnly();
    private static readonly string[] _fallenHeroFieldNames = new string[] { "digest", "profile", "time" };
    private static readonly uint[] _fallenHeroFieldTags = new uint[] { 18, 10, 26 };
    public static FallenHero DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override FallenHero DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override FallenHero ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_FallenHero__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<FallenHero, FallenHero.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_FallenHero__FieldAccessorTable; }
    }
    
    public const int ProfileFieldNumber = 1;
    private bool hasProfile;
    private global::D3.Profile.HeroProfile profile_;
    public bool HasProfile {
      get { return hasProfile; }
    }
    public global::D3.Profile.HeroProfile Profile {
      get { return profile_ ?? global::D3.Profile.HeroProfile.DefaultInstance; }
    }
    
    public const int DigestFieldNumber = 2;
    private bool hasDigest;
    private global::D3.Hero.Digest digest_;
    public bool HasDigest {
      get { return hasDigest; }
    }
    public global::D3.Hero.Digest Digest {
      get { return digest_ ?? global::D3.Hero.Digest.DefaultInstance; }
    }
    
    public const int TimeFieldNumber = 3;
    private bool hasTime;
    private string time_ = "";
    public bool HasTime {
      get { return hasTime; }
    }
    public string Time {
      get { return time_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasProfile) return false;
        if (!hasDigest) return false;
        if (!hasTime) return false;
        if (!Profile.IsInitialized) return false;
        if (!Digest.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _fallenHeroFieldNames;
      if (hasProfile) {
        output.WriteMessage(1, field_names[1], Profile);
      }
      if (hasDigest) {
        output.WriteMessage(2, field_names[0], Digest);
      }
      if (hasTime) {
        output.WriteString(3, field_names[2], Time);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasProfile) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Profile);
        }
        if (hasDigest) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Digest);
        }
        if (hasTime) {
          size += pb::CodedOutputStream.ComputeStringSize(3, Time);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static FallenHero ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static FallenHero ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static FallenHero ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static FallenHero ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static FallenHero ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static FallenHero ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static FallenHero ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static FallenHero ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static FallenHero ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static FallenHero ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private FallenHero MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(FallenHero prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<FallenHero, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(FallenHero cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private FallenHero result;
      
      private FallenHero PrepareBuilder() {
        if (resultIsReadOnly) {
          FallenHero original = result;
          result = new FallenHero();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override FallenHero MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.FallenHero.Descriptor; }
      }
      
      public override FallenHero DefaultInstanceForType {
        get { return global::D3.CS.FallenHero.DefaultInstance; }
      }
      
      public override FallenHero BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is FallenHero) {
          return MergeFrom((FallenHero) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(FallenHero other) {
        if (other == global::D3.CS.FallenHero.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasProfile) {
          MergeProfile(other.Profile);
        }
        if (other.HasDigest) {
          MergeDigest(other.Digest);
        }
        if (other.HasTime) {
          Time = other.Time;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_fallenHeroFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _fallenHeroFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.Profile.HeroProfile.Builder subBuilder = global::D3.Profile.HeroProfile.CreateBuilder();
              if (result.hasProfile) {
                subBuilder.MergeFrom(Profile);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Profile = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::D3.Hero.Digest.Builder subBuilder = global::D3.Hero.Digest.CreateBuilder();
              if (result.hasDigest) {
                subBuilder.MergeFrom(Digest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Digest = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              result.hasTime = input.ReadString(ref result.time_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasProfile {
       get { return result.hasProfile; }
      }
      public global::D3.Profile.HeroProfile Profile {
        get { return result.Profile; }
        set { SetProfile(value); }
      }
      public Builder SetProfile(global::D3.Profile.HeroProfile value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasProfile = true;
        result.profile_ = value;
        return this;
      }
      public Builder SetProfile(global::D3.Profile.HeroProfile.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasProfile = true;
        result.profile_ = builderForValue.Build();
        return this;
      }
      public Builder MergeProfile(global::D3.Profile.HeroProfile value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasProfile &&
            result.profile_ != global::D3.Profile.HeroProfile.DefaultInstance) {
            result.profile_ = global::D3.Profile.HeroProfile.CreateBuilder(result.profile_).MergeFrom(value).BuildPartial();
        } else {
          result.profile_ = value;
        }
        result.hasProfile = true;
        return this;
      }
      public Builder ClearProfile() {
        PrepareBuilder();
        result.hasProfile = false;
        result.profile_ = null;
        return this;
      }
      
      public bool HasDigest {
       get { return result.hasDigest; }
      }
      public global::D3.Hero.Digest Digest {
        get { return result.Digest; }
        set { SetDigest(value); }
      }
      public Builder SetDigest(global::D3.Hero.Digest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDigest = true;
        result.digest_ = value;
        return this;
      }
      public Builder SetDigest(global::D3.Hero.Digest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasDigest = true;
        result.digest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeDigest(global::D3.Hero.Digest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasDigest &&
            result.digest_ != global::D3.Hero.Digest.DefaultInstance) {
            result.digest_ = global::D3.Hero.Digest.CreateBuilder(result.digest_).MergeFrom(value).BuildPartial();
        } else {
          result.digest_ = value;
        }
        result.hasDigest = true;
        return this;
      }
      public Builder ClearDigest() {
        PrepareBuilder();
        result.hasDigest = false;
        result.digest_ = null;
        return this;
      }
      
      public bool HasTime {
        get { return result.hasTime; }
      }
      public string Time {
        get { return result.Time; }
        set { SetTime(value); }
      }
      public Builder SetTime(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTime = true;
        result.time_ = value;
        return this;
      }
      public Builder ClearTime() {
        PrepareBuilder();
        result.hasTime = false;
        result.time_ = "";
        return this;
      }
    }
    static FallenHero() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class PersonalBests : pb::GeneratedMessage<PersonalBests, PersonalBests.Builder> {
    private PersonalBests() { }
    private static readonly PersonalBests defaultInstance = new PersonalBests().MakeReadOnly();
    private static readonly string[] _personalBestsFieldNames = new string[] { "partition_id", "partition_type", "scores" };
    private static readonly uint[] _personalBestsFieldTags = new uint[] { 16, 8, 26 };
    public static PersonalBests DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PersonalBests DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PersonalBests ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_PersonalBests__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PersonalBests, PersonalBests.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_PersonalBests__FieldAccessorTable; }
    }
    
    public const int PartitionTypeFieldNumber = 1;
    private bool hasPartitionType;
    private global::D3.Leaderboard.PartitionType partitionType_ = global::D3.Leaderboard.PartitionType.UNSPECIFIED;
    public bool HasPartitionType {
      get { return hasPartitionType; }
    }
    public global::D3.Leaderboard.PartitionType PartitionType {
      get { return partitionType_; }
    }
    
    public const int PartitionIdFieldNumber = 2;
    private bool hasPartitionId;
    private uint partitionId_;
    public bool HasPartitionId {
      get { return hasPartitionId; }
    }
    public uint PartitionId {
      get { return partitionId_; }
    }
    
    public const int ScoresFieldNumber = 3;
    private pbc::PopsicleList<global::D3.Leaderboard.Score> scores_ = new pbc::PopsicleList<global::D3.Leaderboard.Score>();
    public scg::IList<global::D3.Leaderboard.Score> ScoresList {
      get { return scores_; }
    }
    public int ScoresCount {
      get { return scores_.Count; }
    }
    public global::D3.Leaderboard.Score GetScores(int index) {
      return scores_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasPartitionType) return false;
        if (!hasPartitionId) return false;
        foreach (global::D3.Leaderboard.Score element in ScoresList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _personalBestsFieldNames;
      if (hasPartitionType) {
        output.WriteEnum(1, field_names[1], (int) PartitionType, PartitionType);
      }
      if (hasPartitionId) {
        output.WriteUInt32(2, field_names[0], PartitionId);
      }
      if (scores_.Count > 0) {
        output.WriteMessageArray(3, field_names[2], scores_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasPartitionType) {
          size += pb::CodedOutputStream.ComputeEnumSize(1, (int) PartitionType);
        }
        if (hasPartitionId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, PartitionId);
        }
        foreach (global::D3.Leaderboard.Score element in ScoresList) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PersonalBests ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PersonalBests ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PersonalBests ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PersonalBests ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PersonalBests ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PersonalBests ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PersonalBests ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PersonalBests ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PersonalBests ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PersonalBests ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PersonalBests MakeReadOnly() {
      scores_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PersonalBests prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<PersonalBests, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PersonalBests cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PersonalBests result;
      
      private PersonalBests PrepareBuilder() {
        if (resultIsReadOnly) {
          PersonalBests original = result;
          result = new PersonalBests();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PersonalBests MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.PersonalBests.Descriptor; }
      }
      
      public override PersonalBests DefaultInstanceForType {
        get { return global::D3.CS.PersonalBests.DefaultInstance; }
      }
      
      public override PersonalBests BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PersonalBests) {
          return MergeFrom((PersonalBests) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PersonalBests other) {
        if (other == global::D3.CS.PersonalBests.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasPartitionType) {
          PartitionType = other.PartitionType;
        }
        if (other.HasPartitionId) {
          PartitionId = other.PartitionId;
        }
        if (other.scores_.Count != 0) {
          result.scores_.Add(other.scores_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_personalBestsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _personalBestsFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.partitionType_, out unknown)) {
                result.hasPartitionType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 16: {
              result.hasPartitionId = input.ReadUInt32(ref result.partitionId_);
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.scores_, global::D3.Leaderboard.Score.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasPartitionType {
       get { return result.hasPartitionType; }
      }
      public global::D3.Leaderboard.PartitionType PartitionType {
        get { return result.PartitionType; }
        set { SetPartitionType(value); }
      }
      public Builder SetPartitionType(global::D3.Leaderboard.PartitionType value) {
        PrepareBuilder();
        result.hasPartitionType = true;
        result.partitionType_ = value;
        return this;
      }
      public Builder ClearPartitionType() {
        PrepareBuilder();
        result.hasPartitionType = false;
        result.partitionType_ = global::D3.Leaderboard.PartitionType.UNSPECIFIED;
        return this;
      }
      
      public bool HasPartitionId {
        get { return result.hasPartitionId; }
      }
      public uint PartitionId {
        get { return result.PartitionId; }
        set { SetPartitionId(value); }
      }
      public Builder SetPartitionId(uint value) {
        PrepareBuilder();
        result.hasPartitionId = true;
        result.partitionId_ = value;
        return this;
      }
      public Builder ClearPartitionId() {
        PrepareBuilder();
        result.hasPartitionId = false;
        result.partitionId_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Leaderboard.Score> ScoresList {
        get { return PrepareBuilder().scores_; }
      }
      public int ScoresCount {
        get { return result.ScoresCount; }
      }
      public global::D3.Leaderboard.Score GetScores(int index) {
        return result.GetScores(index);
      }
      public Builder SetScores(int index, global::D3.Leaderboard.Score value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.scores_[index] = value;
        return this;
      }
      public Builder SetScores(int index, global::D3.Leaderboard.Score.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.scores_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddScores(global::D3.Leaderboard.Score value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.scores_.Add(value);
        return this;
      }
      public Builder AddScores(global::D3.Leaderboard.Score.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.scores_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeScores(scg::IEnumerable<global::D3.Leaderboard.Score> values) {
        PrepareBuilder();
        result.scores_.Add(values);
        return this;
      }
      public Builder ClearScores() {
        PrepareBuilder();
        result.scores_.Clear();
        return this;
      }
    }
    static PersonalBests() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ConsumedLicense_deprecated : pb::GeneratedMessage<ConsumedLicense_deprecated, ConsumedLicense_deprecated.Builder> {
    private ConsumedLicense_deprecated() { }
    private static readonly ConsumedLicense_deprecated defaultInstance = new ConsumedLicense_deprecated().MakeReadOnly();
    private static readonly string[] _consumedLicenseDeprecatedFieldNames = new string[] { "id", "instance_id" };
    private static readonly uint[] _consumedLicenseDeprecatedFieldTags = new uint[] { 8, 16 };
    public static ConsumedLicense_deprecated DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ConsumedLicense_deprecated DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ConsumedLicense_deprecated ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_ConsumedLicense_deprecated__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ConsumedLicense_deprecated, ConsumedLicense_deprecated.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_ConsumedLicense_deprecated__FieldAccessorTable; }
    }
    
    public const int IdFieldNumber = 1;
    private bool hasId;
    private long id_;
    public bool HasId {
      get { return hasId; }
    }
    public long Id {
      get { return id_; }
    }
    
    public const int InstanceIdFieldNumber = 2;
    private bool hasInstanceId;
    private long instanceId_;
    public bool HasInstanceId {
      get { return hasInstanceId; }
    }
    public long InstanceId {
      get { return instanceId_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasId) return false;
        if (!hasInstanceId) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _consumedLicenseDeprecatedFieldNames;
      if (hasId) {
        output.WriteSInt64(1, field_names[0], Id);
      }
      if (hasInstanceId) {
        output.WriteSInt64(2, field_names[1], InstanceId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasId) {
          size += pb::CodedOutputStream.ComputeSInt64Size(1, Id);
        }
        if (hasInstanceId) {
          size += pb::CodedOutputStream.ComputeSInt64Size(2, InstanceId);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ConsumedLicense_deprecated ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ConsumedLicense_deprecated ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ConsumedLicense_deprecated ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ConsumedLicense_deprecated ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ConsumedLicense_deprecated ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ConsumedLicense_deprecated ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ConsumedLicense_deprecated ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ConsumedLicense_deprecated ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ConsumedLicense_deprecated ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ConsumedLicense_deprecated ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ConsumedLicense_deprecated MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ConsumedLicense_deprecated prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ConsumedLicense_deprecated, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ConsumedLicense_deprecated cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ConsumedLicense_deprecated result;
      
      private ConsumedLicense_deprecated PrepareBuilder() {
        if (resultIsReadOnly) {
          ConsumedLicense_deprecated original = result;
          result = new ConsumedLicense_deprecated();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ConsumedLicense_deprecated MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.ConsumedLicense_deprecated.Descriptor; }
      }
      
      public override ConsumedLicense_deprecated DefaultInstanceForType {
        get { return global::D3.CS.ConsumedLicense_deprecated.DefaultInstance; }
      }
      
      public override ConsumedLicense_deprecated BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ConsumedLicense_deprecated) {
          return MergeFrom((ConsumedLicense_deprecated) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ConsumedLicense_deprecated other) {
        if (other == global::D3.CS.ConsumedLicense_deprecated.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasId) {
          Id = other.Id;
        }
        if (other.HasInstanceId) {
          InstanceId = other.InstanceId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_consumedLicenseDeprecatedFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _consumedLicenseDeprecatedFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasId = input.ReadSInt64(ref result.id_);
              break;
            }
            case 16: {
              result.hasInstanceId = input.ReadSInt64(ref result.instanceId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasId {
        get { return result.hasId; }
      }
      public long Id {
        get { return result.Id; }
        set { SetId(value); }
      }
      public Builder SetId(long value) {
        PrepareBuilder();
        result.hasId = true;
        result.id_ = value;
        return this;
      }
      public Builder ClearId() {
        PrepareBuilder();
        result.hasId = false;
        result.id_ = 0;
        return this;
      }
      
      public bool HasInstanceId {
        get { return result.hasInstanceId; }
      }
      public long InstanceId {
        get { return result.InstanceId; }
        set { SetInstanceId(value); }
      }
      public Builder SetInstanceId(long value) {
        PrepareBuilder();
        result.hasInstanceId = true;
        result.instanceId_ = value;
        return this;
      }
      public Builder ClearInstanceId() {
        PrepareBuilder();
        result.hasInstanceId = false;
        result.instanceId_ = 0;
        return this;
      }
    }
    static ConsumedLicense_deprecated() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ConsumedLicenses_deprecated : pb::GeneratedMessage<ConsumedLicenses_deprecated, ConsumedLicenses_deprecated.Builder> {
    private ConsumedLicenses_deprecated() { }
    private static readonly ConsumedLicenses_deprecated defaultInstance = new ConsumedLicenses_deprecated().MakeReadOnly();
    private static readonly string[] _consumedLicensesDeprecatedFieldNames = new string[] { "license" };
    private static readonly uint[] _consumedLicensesDeprecatedFieldTags = new uint[] { 10 };
    public static ConsumedLicenses_deprecated DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ConsumedLicenses_deprecated DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ConsumedLicenses_deprecated ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_ConsumedLicenses_deprecated__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ConsumedLicenses_deprecated, ConsumedLicenses_deprecated.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_ConsumedLicenses_deprecated__FieldAccessorTable; }
    }
    
    public const int LicenseFieldNumber = 1;
    private pbc::PopsicleList<global::D3.CS.ConsumedLicense_deprecated> license_ = new pbc::PopsicleList<global::D3.CS.ConsumedLicense_deprecated>();
    public scg::IList<global::D3.CS.ConsumedLicense_deprecated> LicenseList {
      get { return license_; }
    }
    public int LicenseCount {
      get { return license_.Count; }
    }
    public global::D3.CS.ConsumedLicense_deprecated GetLicense(int index) {
      return license_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::D3.CS.ConsumedLicense_deprecated element in LicenseList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _consumedLicensesDeprecatedFieldNames;
      if (license_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], license_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::D3.CS.ConsumedLicense_deprecated element in LicenseList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ConsumedLicenses_deprecated ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ConsumedLicenses_deprecated ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ConsumedLicenses_deprecated ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ConsumedLicenses_deprecated ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ConsumedLicenses_deprecated ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ConsumedLicenses_deprecated ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ConsumedLicenses_deprecated ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ConsumedLicenses_deprecated ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ConsumedLicenses_deprecated ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ConsumedLicenses_deprecated ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ConsumedLicenses_deprecated MakeReadOnly() {
      license_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ConsumedLicenses_deprecated prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ConsumedLicenses_deprecated, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ConsumedLicenses_deprecated cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ConsumedLicenses_deprecated result;
      
      private ConsumedLicenses_deprecated PrepareBuilder() {
        if (resultIsReadOnly) {
          ConsumedLicenses_deprecated original = result;
          result = new ConsumedLicenses_deprecated();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ConsumedLicenses_deprecated MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.ConsumedLicenses_deprecated.Descriptor; }
      }
      
      public override ConsumedLicenses_deprecated DefaultInstanceForType {
        get { return global::D3.CS.ConsumedLicenses_deprecated.DefaultInstance; }
      }
      
      public override ConsumedLicenses_deprecated BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ConsumedLicenses_deprecated) {
          return MergeFrom((ConsumedLicenses_deprecated) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ConsumedLicenses_deprecated other) {
        if (other == global::D3.CS.ConsumedLicenses_deprecated.DefaultInstance) return this;
        PrepareBuilder();
        if (other.license_.Count != 0) {
          result.license_.Add(other.license_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_consumedLicensesDeprecatedFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _consumedLicensesDeprecatedFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.license_, global::D3.CS.ConsumedLicense_deprecated.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::D3.CS.ConsumedLicense_deprecated> LicenseList {
        get { return PrepareBuilder().license_; }
      }
      public int LicenseCount {
        get { return result.LicenseCount; }
      }
      public global::D3.CS.ConsumedLicense_deprecated GetLicense(int index) {
        return result.GetLicense(index);
      }
      public Builder SetLicense(int index, global::D3.CS.ConsumedLicense_deprecated value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.license_[index] = value;
        return this;
      }
      public Builder SetLicense(int index, global::D3.CS.ConsumedLicense_deprecated.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.license_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddLicense(global::D3.CS.ConsumedLicense_deprecated value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.license_.Add(value);
        return this;
      }
      public Builder AddLicense(global::D3.CS.ConsumedLicense_deprecated.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.license_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeLicense(scg::IEnumerable<global::D3.CS.ConsumedLicense_deprecated> values) {
        PrepareBuilder();
        result.license_.Add(values);
        return this;
      }
      public Builder ClearLicense() {
        PrepareBuilder();
        result.license_.Clear();
        return this;
      }
    }
    static ConsumedLicenses_deprecated() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Snapshot : pb::GeneratedMessage<Snapshot, Snapshot.Builder> {
    private Snapshot() { }
    private static readonly Snapshot defaultInstance = new Snapshot().MakeReadOnly();
    private static readonly string[] _snapshotFieldNames = new string[] { "account_id", "account_profiles", "achievement_snapshots", "all_personal_bests", "banned", "create_time", "definition", "deprecated_account_profile", "deprecated_consumed_licenses", "fallen_heros", "game_account_settings", "guild_restrictions", "hero_profiles", "heros", "mails", "preferences", "version" };
    private static readonly uint[] _snapshotFieldTags = new uint[] { 82, 74, 162, 146, 112, 64, 18, 34, 154, 50, 98, 90, 42, 26, 58, 106, 8 };
    public static Snapshot DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Snapshot DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Snapshot ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_Snapshot__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Snapshot, Snapshot.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_Snapshot__FieldAccessorTable; }
    }
    
    public const int VersionFieldNumber = 1;
    private bool hasVersion;
    private ulong version_;
    public bool HasVersion {
      get { return hasVersion; }
    }
    public ulong Version {
      get { return version_; }
    }
    
    public const int DefinitionFieldNumber = 2;
    private bool hasDefinition;
    private global::D3.Account.SavedDefinition definition_;
    public bool HasDefinition {
      get { return hasDefinition; }
    }
    public global::D3.Account.SavedDefinition Definition {
      get { return definition_ ?? global::D3.Account.SavedDefinition.DefaultInstance; }
    }
    
    public const int HerosFieldNumber = 3;
    private pbc::PopsicleList<global::D3.Hero.SavedDefinition> heros_ = new pbc::PopsicleList<global::D3.Hero.SavedDefinition>();
    public scg::IList<global::D3.Hero.SavedDefinition> HerosList {
      get { return heros_; }
    }
    public int HerosCount {
      get { return heros_.Count; }
    }
    public global::D3.Hero.SavedDefinition GetHeros(int index) {
      return heros_[index];
    }
    
    public const int HeroProfilesFieldNumber = 5;
    private bool hasHeroProfiles;
    private global::D3.Profile.HeroProfileList heroProfiles_;
    public bool HasHeroProfiles {
      get { return hasHeroProfiles; }
    }
    public global::D3.Profile.HeroProfileList HeroProfiles {
      get { return heroProfiles_ ?? global::D3.Profile.HeroProfileList.DefaultInstance; }
    }
    
    public const int FallenHerosFieldNumber = 6;
    private pbc::PopsicleList<global::D3.CS.FallenHero> fallenHeros_ = new pbc::PopsicleList<global::D3.CS.FallenHero>();
    public scg::IList<global::D3.CS.FallenHero> FallenHerosList {
      get { return fallenHeros_; }
    }
    public int FallenHerosCount {
      get { return fallenHeros_.Count; }
    }
    public global::D3.CS.FallenHero GetFallenHeros(int index) {
      return fallenHeros_[index];
    }
    
    public const int MailsFieldNumber = 7;
    private bool hasMails;
    private global::D3.Items.Mails mails_;
    public bool HasMails {
      get { return hasMails; }
    }
    public global::D3.Items.Mails Mails {
      get { return mails_ ?? global::D3.Items.Mails.DefaultInstance; }
    }
    
    public const int CreateTimeFieldNumber = 8;
    private bool hasCreateTime;
    private uint createTime_;
    public bool HasCreateTime {
      get { return hasCreateTime; }
    }
    public uint CreateTime {
      get { return createTime_; }
    }
    
    public const int AccountProfilesFieldNumber = 9;
    private pbc::PopsicleList<global::D3.Profile.AccountProfile> accountProfiles_ = new pbc::PopsicleList<global::D3.Profile.AccountProfile>();
    public scg::IList<global::D3.Profile.AccountProfile> AccountProfilesList {
      get { return accountProfiles_; }
    }
    public int AccountProfilesCount {
      get { return accountProfiles_.Count; }
    }
    public global::D3.Profile.AccountProfile GetAccountProfiles(int index) {
      return accountProfiles_[index];
    }
    
    public const int AccountIdFieldNumber = 10;
    private bool hasAccountId;
    private global::D3.OnlineService.EntityId accountId_;
    public bool HasAccountId {
      get { return hasAccountId; }
    }
    public global::D3.OnlineService.EntityId AccountId {
      get { return accountId_ ?? global::D3.OnlineService.EntityId.DefaultInstance; }
    }
    
    public const int DeprecatedAccountProfileFieldNumber = 4;
    private bool hasDeprecatedAccountProfile;
    private global::D3.Profile.AccountProfile deprecatedAccountProfile_;
    public bool HasDeprecatedAccountProfile {
      get { return hasDeprecatedAccountProfile; }
    }
    public global::D3.Profile.AccountProfile DeprecatedAccountProfile {
      get { return deprecatedAccountProfile_ ?? global::D3.Profile.AccountProfile.DefaultInstance; }
    }
    
    public const int GuildRestrictionsFieldNumber = 11;
    private bool hasGuildRestrictions;
    private global::D3.Guild.GuildAccountRestrictions guildRestrictions_;
    public bool HasGuildRestrictions {
      get { return hasGuildRestrictions; }
    }
    public global::D3.Guild.GuildAccountRestrictions GuildRestrictions {
      get { return guildRestrictions_ ?? global::D3.Guild.GuildAccountRestrictions.DefaultInstance; }
    }
    
    public const int GameAccountSettingsFieldNumber = 12;
    private bool hasGameAccountSettings;
    private global::D3.Client.GameAccountSettings gameAccountSettings_;
    public bool HasGameAccountSettings {
      get { return hasGameAccountSettings; }
    }
    public global::D3.Client.GameAccountSettings GameAccountSettings {
      get { return gameAccountSettings_ ?? global::D3.Client.GameAccountSettings.DefaultInstance; }
    }
    
    public const int PreferencesFieldNumber = 13;
    private bool hasPreferences;
    private global::D3.Client.Preferences preferences_;
    public bool HasPreferences {
      get { return hasPreferences; }
    }
    public global::D3.Client.Preferences Preferences {
      get { return preferences_ ?? global::D3.Client.Preferences.DefaultInstance; }
    }
    
    public const int BannedFieldNumber = 14;
    private bool hasBanned;
    private bool banned_;
    public bool HasBanned {
      get { return hasBanned; }
    }
    public bool Banned {
      get { return banned_; }
    }
    
    public const int AllPersonalBestsFieldNumber = 18;
    private pbc::PopsicleList<global::D3.CS.PersonalBests> allPersonalBests_ = new pbc::PopsicleList<global::D3.CS.PersonalBests>();
    public scg::IList<global::D3.CS.PersonalBests> AllPersonalBestsList {
      get { return allPersonalBests_; }
    }
    public int AllPersonalBestsCount {
      get { return allPersonalBests_.Count; }
    }
    public global::D3.CS.PersonalBests GetAllPersonalBests(int index) {
      return allPersonalBests_[index];
    }
    
    public const int DeprecatedConsumedLicensesFieldNumber = 19;
    private bool hasDeprecatedConsumedLicenses;
    private global::D3.CS.ConsumedLicenses_deprecated deprecatedConsumedLicenses_;
    public bool HasDeprecatedConsumedLicenses {
      get { return hasDeprecatedConsumedLicenses; }
    }
    public global::D3.CS.ConsumedLicenses_deprecated DeprecatedConsumedLicenses {
      get { return deprecatedConsumedLicenses_ ?? global::D3.CS.ConsumedLicenses_deprecated.DefaultInstance; }
    }
    
    public const int AchievementSnapshotsFieldNumber = 20;
    private pbc::PopsicleList<global::D3.Achievements.PartitionSnapshot> achievementSnapshots_ = new pbc::PopsicleList<global::D3.Achievements.PartitionSnapshot>();
    public scg::IList<global::D3.Achievements.PartitionSnapshot> AchievementSnapshotsList {
      get { return achievementSnapshots_; }
    }
    public int AchievementSnapshotsCount {
      get { return achievementSnapshots_.Count; }
    }
    public global::D3.Achievements.PartitionSnapshot GetAchievementSnapshots(int index) {
      return achievementSnapshots_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasVersion) return false;
        if (!hasDefinition) return false;
        if (!hasHeroProfiles) return false;
        if (!hasDeprecatedAccountProfile) return false;
        if (!Definition.IsInitialized) return false;
        foreach (global::D3.Hero.SavedDefinition element in HerosList) {
          if (!element.IsInitialized) return false;
        }
        if (!HeroProfiles.IsInitialized) return false;
        foreach (global::D3.CS.FallenHero element in FallenHerosList) {
          if (!element.IsInitialized) return false;
        }
        if (HasMails) {
          if (!Mails.IsInitialized) return false;
        }
        foreach (global::D3.Profile.AccountProfile element in AccountProfilesList) {
          if (!element.IsInitialized) return false;
        }
        if (HasAccountId) {
          if (!AccountId.IsInitialized) return false;
        }
        if (!DeprecatedAccountProfile.IsInitialized) return false;
        if (HasGuildRestrictions) {
          if (!GuildRestrictions.IsInitialized) return false;
        }
        if (HasGameAccountSettings) {
          if (!GameAccountSettings.IsInitialized) return false;
        }
        foreach (global::D3.CS.PersonalBests element in AllPersonalBestsList) {
          if (!element.IsInitialized) return false;
        }
        if (HasDeprecatedConsumedLicenses) {
          if (!DeprecatedConsumedLicenses.IsInitialized) return false;
        }
        foreach (global::D3.Achievements.PartitionSnapshot element in AchievementSnapshotsList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _snapshotFieldNames;
      if (hasVersion) {
        output.WriteUInt64(1, field_names[16], Version);
      }
      if (hasDefinition) {
        output.WriteMessage(2, field_names[6], Definition);
      }
      if (heros_.Count > 0) {
        output.WriteMessageArray(3, field_names[13], heros_);
      }
      if (hasDeprecatedAccountProfile) {
        output.WriteMessage(4, field_names[7], DeprecatedAccountProfile);
      }
      if (hasHeroProfiles) {
        output.WriteMessage(5, field_names[12], HeroProfiles);
      }
      if (fallenHeros_.Count > 0) {
        output.WriteMessageArray(6, field_names[9], fallenHeros_);
      }
      if (hasMails) {
        output.WriteMessage(7, field_names[14], Mails);
      }
      if (hasCreateTime) {
        output.WriteUInt32(8, field_names[5], CreateTime);
      }
      if (accountProfiles_.Count > 0) {
        output.WriteMessageArray(9, field_names[1], accountProfiles_);
      }
      if (hasAccountId) {
        output.WriteMessage(10, field_names[0], AccountId);
      }
      if (hasGuildRestrictions) {
        output.WriteMessage(11, field_names[11], GuildRestrictions);
      }
      if (hasGameAccountSettings) {
        output.WriteMessage(12, field_names[10], GameAccountSettings);
      }
      if (hasPreferences) {
        output.WriteMessage(13, field_names[15], Preferences);
      }
      if (hasBanned) {
        output.WriteBool(14, field_names[4], Banned);
      }
      if (allPersonalBests_.Count > 0) {
        output.WriteMessageArray(18, field_names[3], allPersonalBests_);
      }
      if (hasDeprecatedConsumedLicenses) {
        output.WriteMessage(19, field_names[8], DeprecatedConsumedLicenses);
      }
      if (achievementSnapshots_.Count > 0) {
        output.WriteMessageArray(20, field_names[2], achievementSnapshots_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasVersion) {
          size += pb::CodedOutputStream.ComputeUInt64Size(1, Version);
        }
        if (hasDefinition) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Definition);
        }
        foreach (global::D3.Hero.SavedDefinition element in HerosList) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, element);
        }
        if (hasHeroProfiles) {
          size += pb::CodedOutputStream.ComputeMessageSize(5, HeroProfiles);
        }
        foreach (global::D3.CS.FallenHero element in FallenHerosList) {
          size += pb::CodedOutputStream.ComputeMessageSize(6, element);
        }
        if (hasMails) {
          size += pb::CodedOutputStream.ComputeMessageSize(7, Mails);
        }
        if (hasCreateTime) {
          size += pb::CodedOutputStream.ComputeUInt32Size(8, CreateTime);
        }
        foreach (global::D3.Profile.AccountProfile element in AccountProfilesList) {
          size += pb::CodedOutputStream.ComputeMessageSize(9, element);
        }
        if (hasAccountId) {
          size += pb::CodedOutputStream.ComputeMessageSize(10, AccountId);
        }
        if (hasDeprecatedAccountProfile) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, DeprecatedAccountProfile);
        }
        if (hasGuildRestrictions) {
          size += pb::CodedOutputStream.ComputeMessageSize(11, GuildRestrictions);
        }
        if (hasGameAccountSettings) {
          size += pb::CodedOutputStream.ComputeMessageSize(12, GameAccountSettings);
        }
        if (hasPreferences) {
          size += pb::CodedOutputStream.ComputeMessageSize(13, Preferences);
        }
        if (hasBanned) {
          size += pb::CodedOutputStream.ComputeBoolSize(14, Banned);
        }
        foreach (global::D3.CS.PersonalBests element in AllPersonalBestsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(18, element);
        }
        if (hasDeprecatedConsumedLicenses) {
          size += pb::CodedOutputStream.ComputeMessageSize(19, DeprecatedConsumedLicenses);
        }
        foreach (global::D3.Achievements.PartitionSnapshot element in AchievementSnapshotsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(20, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Snapshot ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Snapshot ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Snapshot ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Snapshot ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Snapshot ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Snapshot ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Snapshot ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Snapshot ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Snapshot ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Snapshot ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Snapshot MakeReadOnly() {
      heros_.MakeReadOnly();
      fallenHeros_.MakeReadOnly();
      accountProfiles_.MakeReadOnly();
      allPersonalBests_.MakeReadOnly();
      achievementSnapshots_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Snapshot prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Snapshot, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Snapshot cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Snapshot result;
      
      private Snapshot PrepareBuilder() {
        if (resultIsReadOnly) {
          Snapshot original = result;
          result = new Snapshot();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Snapshot MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.Snapshot.Descriptor; }
      }
      
      public override Snapshot DefaultInstanceForType {
        get { return global::D3.CS.Snapshot.DefaultInstance; }
      }
      
      public override Snapshot BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Snapshot) {
          return MergeFrom((Snapshot) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Snapshot other) {
        if (other == global::D3.CS.Snapshot.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasVersion) {
          Version = other.Version;
        }
        if (other.HasDefinition) {
          MergeDefinition(other.Definition);
        }
        if (other.heros_.Count != 0) {
          result.heros_.Add(other.heros_);
        }
        if (other.HasHeroProfiles) {
          MergeHeroProfiles(other.HeroProfiles);
        }
        if (other.fallenHeros_.Count != 0) {
          result.fallenHeros_.Add(other.fallenHeros_);
        }
        if (other.HasMails) {
          MergeMails(other.Mails);
        }
        if (other.HasCreateTime) {
          CreateTime = other.CreateTime;
        }
        if (other.accountProfiles_.Count != 0) {
          result.accountProfiles_.Add(other.accountProfiles_);
        }
        if (other.HasAccountId) {
          MergeAccountId(other.AccountId);
        }
        if (other.HasDeprecatedAccountProfile) {
          MergeDeprecatedAccountProfile(other.DeprecatedAccountProfile);
        }
        if (other.HasGuildRestrictions) {
          MergeGuildRestrictions(other.GuildRestrictions);
        }
        if (other.HasGameAccountSettings) {
          MergeGameAccountSettings(other.GameAccountSettings);
        }
        if (other.HasPreferences) {
          MergePreferences(other.Preferences);
        }
        if (other.HasBanned) {
          Banned = other.Banned;
        }
        if (other.allPersonalBests_.Count != 0) {
          result.allPersonalBests_.Add(other.allPersonalBests_);
        }
        if (other.HasDeprecatedConsumedLicenses) {
          MergeDeprecatedConsumedLicenses(other.DeprecatedConsumedLicenses);
        }
        if (other.achievementSnapshots_.Count != 0) {
          result.achievementSnapshots_.Add(other.achievementSnapshots_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_snapshotFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _snapshotFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasVersion = input.ReadUInt64(ref result.version_);
              break;
            }
            case 18: {
              global::D3.Account.SavedDefinition.Builder subBuilder = global::D3.Account.SavedDefinition.CreateBuilder();
              if (result.hasDefinition) {
                subBuilder.MergeFrom(Definition);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Definition = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.heros_, global::D3.Hero.SavedDefinition.DefaultInstance, extensionRegistry);
              break;
            }
            case 34: {
              global::D3.Profile.AccountProfile.Builder subBuilder = global::D3.Profile.AccountProfile.CreateBuilder();
              if (result.hasDeprecatedAccountProfile) {
                subBuilder.MergeFrom(DeprecatedAccountProfile);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              DeprecatedAccountProfile = subBuilder.BuildPartial();
              break;
            }
            case 42: {
              global::D3.Profile.HeroProfileList.Builder subBuilder = global::D3.Profile.HeroProfileList.CreateBuilder();
              if (result.hasHeroProfiles) {
                subBuilder.MergeFrom(HeroProfiles);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              HeroProfiles = subBuilder.BuildPartial();
              break;
            }
            case 50: {
              input.ReadMessageArray(tag, field_name, result.fallenHeros_, global::D3.CS.FallenHero.DefaultInstance, extensionRegistry);
              break;
            }
            case 58: {
              global::D3.Items.Mails.Builder subBuilder = global::D3.Items.Mails.CreateBuilder();
              if (result.hasMails) {
                subBuilder.MergeFrom(Mails);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Mails = subBuilder.BuildPartial();
              break;
            }
            case 64: {
              result.hasCreateTime = input.ReadUInt32(ref result.createTime_);
              break;
            }
            case 74: {
              input.ReadMessageArray(tag, field_name, result.accountProfiles_, global::D3.Profile.AccountProfile.DefaultInstance, extensionRegistry);
              break;
            }
            case 82: {
              global::D3.OnlineService.EntityId.Builder subBuilder = global::D3.OnlineService.EntityId.CreateBuilder();
              if (result.hasAccountId) {
                subBuilder.MergeFrom(AccountId);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              AccountId = subBuilder.BuildPartial();
              break;
            }
            case 90: {
              global::D3.Guild.GuildAccountRestrictions.Builder subBuilder = global::D3.Guild.GuildAccountRestrictions.CreateBuilder();
              if (result.hasGuildRestrictions) {
                subBuilder.MergeFrom(GuildRestrictions);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              GuildRestrictions = subBuilder.BuildPartial();
              break;
            }
            case 98: {
              global::D3.Client.GameAccountSettings.Builder subBuilder = global::D3.Client.GameAccountSettings.CreateBuilder();
              if (result.hasGameAccountSettings) {
                subBuilder.MergeFrom(GameAccountSettings);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              GameAccountSettings = subBuilder.BuildPartial();
              break;
            }
            case 106: {
              global::D3.Client.Preferences.Builder subBuilder = global::D3.Client.Preferences.CreateBuilder();
              if (result.hasPreferences) {
                subBuilder.MergeFrom(Preferences);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Preferences = subBuilder.BuildPartial();
              break;
            }
            case 112: {
              result.hasBanned = input.ReadBool(ref result.banned_);
              break;
            }
            case 146: {
              input.ReadMessageArray(tag, field_name, result.allPersonalBests_, global::D3.CS.PersonalBests.DefaultInstance, extensionRegistry);
              break;
            }
            case 154: {
              global::D3.CS.ConsumedLicenses_deprecated.Builder subBuilder = global::D3.CS.ConsumedLicenses_deprecated.CreateBuilder();
              if (result.hasDeprecatedConsumedLicenses) {
                subBuilder.MergeFrom(DeprecatedConsumedLicenses);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              DeprecatedConsumedLicenses = subBuilder.BuildPartial();
              break;
            }
            case 162: {
              input.ReadMessageArray(tag, field_name, result.achievementSnapshots_, global::D3.Achievements.PartitionSnapshot.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasVersion {
        get { return result.hasVersion; }
      }
      public ulong Version {
        get { return result.Version; }
        set { SetVersion(value); }
      }
      public Builder SetVersion(ulong value) {
        PrepareBuilder();
        result.hasVersion = true;
        result.version_ = value;
        return this;
      }
      public Builder ClearVersion() {
        PrepareBuilder();
        result.hasVersion = false;
        result.version_ = 0UL;
        return this;
      }
      
      public bool HasDefinition {
       get { return result.hasDefinition; }
      }
      public global::D3.Account.SavedDefinition Definition {
        get { return result.Definition; }
        set { SetDefinition(value); }
      }
      public Builder SetDefinition(global::D3.Account.SavedDefinition value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDefinition = true;
        result.definition_ = value;
        return this;
      }
      public Builder SetDefinition(global::D3.Account.SavedDefinition.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasDefinition = true;
        result.definition_ = builderForValue.Build();
        return this;
      }
      public Builder MergeDefinition(global::D3.Account.SavedDefinition value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasDefinition &&
            result.definition_ != global::D3.Account.SavedDefinition.DefaultInstance) {
            result.definition_ = global::D3.Account.SavedDefinition.CreateBuilder(result.definition_).MergeFrom(value).BuildPartial();
        } else {
          result.definition_ = value;
        }
        result.hasDefinition = true;
        return this;
      }
      public Builder ClearDefinition() {
        PrepareBuilder();
        result.hasDefinition = false;
        result.definition_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Hero.SavedDefinition> HerosList {
        get { return PrepareBuilder().heros_; }
      }
      public int HerosCount {
        get { return result.HerosCount; }
      }
      public global::D3.Hero.SavedDefinition GetHeros(int index) {
        return result.GetHeros(index);
      }
      public Builder SetHeros(int index, global::D3.Hero.SavedDefinition value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.heros_[index] = value;
        return this;
      }
      public Builder SetHeros(int index, global::D3.Hero.SavedDefinition.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.heros_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddHeros(global::D3.Hero.SavedDefinition value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.heros_.Add(value);
        return this;
      }
      public Builder AddHeros(global::D3.Hero.SavedDefinition.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.heros_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeHeros(scg::IEnumerable<global::D3.Hero.SavedDefinition> values) {
        PrepareBuilder();
        result.heros_.Add(values);
        return this;
      }
      public Builder ClearHeros() {
        PrepareBuilder();
        result.heros_.Clear();
        return this;
      }
      
      public bool HasHeroProfiles {
       get { return result.hasHeroProfiles; }
      }
      public global::D3.Profile.HeroProfileList HeroProfiles {
        get { return result.HeroProfiles; }
        set { SetHeroProfiles(value); }
      }
      public Builder SetHeroProfiles(global::D3.Profile.HeroProfileList value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHeroProfiles = true;
        result.heroProfiles_ = value;
        return this;
      }
      public Builder SetHeroProfiles(global::D3.Profile.HeroProfileList.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasHeroProfiles = true;
        result.heroProfiles_ = builderForValue.Build();
        return this;
      }
      public Builder MergeHeroProfiles(global::D3.Profile.HeroProfileList value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasHeroProfiles &&
            result.heroProfiles_ != global::D3.Profile.HeroProfileList.DefaultInstance) {
            result.heroProfiles_ = global::D3.Profile.HeroProfileList.CreateBuilder(result.heroProfiles_).MergeFrom(value).BuildPartial();
        } else {
          result.heroProfiles_ = value;
        }
        result.hasHeroProfiles = true;
        return this;
      }
      public Builder ClearHeroProfiles() {
        PrepareBuilder();
        result.hasHeroProfiles = false;
        result.heroProfiles_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.CS.FallenHero> FallenHerosList {
        get { return PrepareBuilder().fallenHeros_; }
      }
      public int FallenHerosCount {
        get { return result.FallenHerosCount; }
      }
      public global::D3.CS.FallenHero GetFallenHeros(int index) {
        return result.GetFallenHeros(index);
      }
      public Builder SetFallenHeros(int index, global::D3.CS.FallenHero value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.fallenHeros_[index] = value;
        return this;
      }
      public Builder SetFallenHeros(int index, global::D3.CS.FallenHero.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.fallenHeros_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddFallenHeros(global::D3.CS.FallenHero value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.fallenHeros_.Add(value);
        return this;
      }
      public Builder AddFallenHeros(global::D3.CS.FallenHero.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.fallenHeros_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeFallenHeros(scg::IEnumerable<global::D3.CS.FallenHero> values) {
        PrepareBuilder();
        result.fallenHeros_.Add(values);
        return this;
      }
      public Builder ClearFallenHeros() {
        PrepareBuilder();
        result.fallenHeros_.Clear();
        return this;
      }
      
      public bool HasMails {
       get { return result.hasMails; }
      }
      public global::D3.Items.Mails Mails {
        get { return result.Mails; }
        set { SetMails(value); }
      }
      public Builder SetMails(global::D3.Items.Mails value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMails = true;
        result.mails_ = value;
        return this;
      }
      public Builder SetMails(global::D3.Items.Mails.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasMails = true;
        result.mails_ = builderForValue.Build();
        return this;
      }
      public Builder MergeMails(global::D3.Items.Mails value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasMails &&
            result.mails_ != global::D3.Items.Mails.DefaultInstance) {
            result.mails_ = global::D3.Items.Mails.CreateBuilder(result.mails_).MergeFrom(value).BuildPartial();
        } else {
          result.mails_ = value;
        }
        result.hasMails = true;
        return this;
      }
      public Builder ClearMails() {
        PrepareBuilder();
        result.hasMails = false;
        result.mails_ = null;
        return this;
      }
      
      public bool HasCreateTime {
        get { return result.hasCreateTime; }
      }
      public uint CreateTime {
        get { return result.CreateTime; }
        set { SetCreateTime(value); }
      }
      public Builder SetCreateTime(uint value) {
        PrepareBuilder();
        result.hasCreateTime = true;
        result.createTime_ = value;
        return this;
      }
      public Builder ClearCreateTime() {
        PrepareBuilder();
        result.hasCreateTime = false;
        result.createTime_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Profile.AccountProfile> AccountProfilesList {
        get { return PrepareBuilder().accountProfiles_; }
      }
      public int AccountProfilesCount {
        get { return result.AccountProfilesCount; }
      }
      public global::D3.Profile.AccountProfile GetAccountProfiles(int index) {
        return result.GetAccountProfiles(index);
      }
      public Builder SetAccountProfiles(int index, global::D3.Profile.AccountProfile value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.accountProfiles_[index] = value;
        return this;
      }
      public Builder SetAccountProfiles(int index, global::D3.Profile.AccountProfile.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.accountProfiles_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddAccountProfiles(global::D3.Profile.AccountProfile value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.accountProfiles_.Add(value);
        return this;
      }
      public Builder AddAccountProfiles(global::D3.Profile.AccountProfile.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.accountProfiles_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeAccountProfiles(scg::IEnumerable<global::D3.Profile.AccountProfile> values) {
        PrepareBuilder();
        result.accountProfiles_.Add(values);
        return this;
      }
      public Builder ClearAccountProfiles() {
        PrepareBuilder();
        result.accountProfiles_.Clear();
        return this;
      }
      
      public bool HasAccountId {
       get { return result.hasAccountId; }
      }
      public global::D3.OnlineService.EntityId AccountId {
        get { return result.AccountId; }
        set { SetAccountId(value); }
      }
      public Builder SetAccountId(global::D3.OnlineService.EntityId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAccountId = true;
        result.accountId_ = value;
        return this;
      }
      public Builder SetAccountId(global::D3.OnlineService.EntityId.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasAccountId = true;
        result.accountId_ = builderForValue.Build();
        return this;
      }
      public Builder MergeAccountId(global::D3.OnlineService.EntityId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasAccountId &&
            result.accountId_ != global::D3.OnlineService.EntityId.DefaultInstance) {
            result.accountId_ = global::D3.OnlineService.EntityId.CreateBuilder(result.accountId_).MergeFrom(value).BuildPartial();
        } else {
          result.accountId_ = value;
        }
        result.hasAccountId = true;
        return this;
      }
      public Builder ClearAccountId() {
        PrepareBuilder();
        result.hasAccountId = false;
        result.accountId_ = null;
        return this;
      }
      
      public bool HasDeprecatedAccountProfile {
       get { return result.hasDeprecatedAccountProfile; }
      }
      public global::D3.Profile.AccountProfile DeprecatedAccountProfile {
        get { return result.DeprecatedAccountProfile; }
        set { SetDeprecatedAccountProfile(value); }
      }
      public Builder SetDeprecatedAccountProfile(global::D3.Profile.AccountProfile value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDeprecatedAccountProfile = true;
        result.deprecatedAccountProfile_ = value;
        return this;
      }
      public Builder SetDeprecatedAccountProfile(global::D3.Profile.AccountProfile.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasDeprecatedAccountProfile = true;
        result.deprecatedAccountProfile_ = builderForValue.Build();
        return this;
      }
      public Builder MergeDeprecatedAccountProfile(global::D3.Profile.AccountProfile value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasDeprecatedAccountProfile &&
            result.deprecatedAccountProfile_ != global::D3.Profile.AccountProfile.DefaultInstance) {
            result.deprecatedAccountProfile_ = global::D3.Profile.AccountProfile.CreateBuilder(result.deprecatedAccountProfile_).MergeFrom(value).BuildPartial();
        } else {
          result.deprecatedAccountProfile_ = value;
        }
        result.hasDeprecatedAccountProfile = true;
        return this;
      }
      public Builder ClearDeprecatedAccountProfile() {
        PrepareBuilder();
        result.hasDeprecatedAccountProfile = false;
        result.deprecatedAccountProfile_ = null;
        return this;
      }
      
      public bool HasGuildRestrictions {
       get { return result.hasGuildRestrictions; }
      }
      public global::D3.Guild.GuildAccountRestrictions GuildRestrictions {
        get { return result.GuildRestrictions; }
        set { SetGuildRestrictions(value); }
      }
      public Builder SetGuildRestrictions(global::D3.Guild.GuildAccountRestrictions value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasGuildRestrictions = true;
        result.guildRestrictions_ = value;
        return this;
      }
      public Builder SetGuildRestrictions(global::D3.Guild.GuildAccountRestrictions.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasGuildRestrictions = true;
        result.guildRestrictions_ = builderForValue.Build();
        return this;
      }
      public Builder MergeGuildRestrictions(global::D3.Guild.GuildAccountRestrictions value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasGuildRestrictions &&
            result.guildRestrictions_ != global::D3.Guild.GuildAccountRestrictions.DefaultInstance) {
            result.guildRestrictions_ = global::D3.Guild.GuildAccountRestrictions.CreateBuilder(result.guildRestrictions_).MergeFrom(value).BuildPartial();
        } else {
          result.guildRestrictions_ = value;
        }
        result.hasGuildRestrictions = true;
        return this;
      }
      public Builder ClearGuildRestrictions() {
        PrepareBuilder();
        result.hasGuildRestrictions = false;
        result.guildRestrictions_ = null;
        return this;
      }
      
      public bool HasGameAccountSettings {
       get { return result.hasGameAccountSettings; }
      }
      public global::D3.Client.GameAccountSettings GameAccountSettings {
        get { return result.GameAccountSettings; }
        set { SetGameAccountSettings(value); }
      }
      public Builder SetGameAccountSettings(global::D3.Client.GameAccountSettings value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasGameAccountSettings = true;
        result.gameAccountSettings_ = value;
        return this;
      }
      public Builder SetGameAccountSettings(global::D3.Client.GameAccountSettings.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasGameAccountSettings = true;
        result.gameAccountSettings_ = builderForValue.Build();
        return this;
      }
      public Builder MergeGameAccountSettings(global::D3.Client.GameAccountSettings value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasGameAccountSettings &&
            result.gameAccountSettings_ != global::D3.Client.GameAccountSettings.DefaultInstance) {
            result.gameAccountSettings_ = global::D3.Client.GameAccountSettings.CreateBuilder(result.gameAccountSettings_).MergeFrom(value).BuildPartial();
        } else {
          result.gameAccountSettings_ = value;
        }
        result.hasGameAccountSettings = true;
        return this;
      }
      public Builder ClearGameAccountSettings() {
        PrepareBuilder();
        result.hasGameAccountSettings = false;
        result.gameAccountSettings_ = null;
        return this;
      }
      
      public bool HasPreferences {
       get { return result.hasPreferences; }
      }
      public global::D3.Client.Preferences Preferences {
        get { return result.Preferences; }
        set { SetPreferences(value); }
      }
      public Builder SetPreferences(global::D3.Client.Preferences value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPreferences = true;
        result.preferences_ = value;
        return this;
      }
      public Builder SetPreferences(global::D3.Client.Preferences.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPreferences = true;
        result.preferences_ = builderForValue.Build();
        return this;
      }
      public Builder MergePreferences(global::D3.Client.Preferences value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasPreferences &&
            result.preferences_ != global::D3.Client.Preferences.DefaultInstance) {
            result.preferences_ = global::D3.Client.Preferences.CreateBuilder(result.preferences_).MergeFrom(value).BuildPartial();
        } else {
          result.preferences_ = value;
        }
        result.hasPreferences = true;
        return this;
      }
      public Builder ClearPreferences() {
        PrepareBuilder();
        result.hasPreferences = false;
        result.preferences_ = null;
        return this;
      }
      
      public bool HasBanned {
        get { return result.hasBanned; }
      }
      public bool Banned {
        get { return result.Banned; }
        set { SetBanned(value); }
      }
      public Builder SetBanned(bool value) {
        PrepareBuilder();
        result.hasBanned = true;
        result.banned_ = value;
        return this;
      }
      public Builder ClearBanned() {
        PrepareBuilder();
        result.hasBanned = false;
        result.banned_ = false;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.CS.PersonalBests> AllPersonalBestsList {
        get { return PrepareBuilder().allPersonalBests_; }
      }
      public int AllPersonalBestsCount {
        get { return result.AllPersonalBestsCount; }
      }
      public global::D3.CS.PersonalBests GetAllPersonalBests(int index) {
        return result.GetAllPersonalBests(index);
      }
      public Builder SetAllPersonalBests(int index, global::D3.CS.PersonalBests value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.allPersonalBests_[index] = value;
        return this;
      }
      public Builder SetAllPersonalBests(int index, global::D3.CS.PersonalBests.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.allPersonalBests_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddAllPersonalBests(global::D3.CS.PersonalBests value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.allPersonalBests_.Add(value);
        return this;
      }
      public Builder AddAllPersonalBests(global::D3.CS.PersonalBests.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.allPersonalBests_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeAllPersonalBests(scg::IEnumerable<global::D3.CS.PersonalBests> values) {
        PrepareBuilder();
        result.allPersonalBests_.Add(values);
        return this;
      }
      public Builder ClearAllPersonalBests() {
        PrepareBuilder();
        result.allPersonalBests_.Clear();
        return this;
      }
      
      public bool HasDeprecatedConsumedLicenses {
       get { return result.hasDeprecatedConsumedLicenses; }
      }
      public global::D3.CS.ConsumedLicenses_deprecated DeprecatedConsumedLicenses {
        get { return result.DeprecatedConsumedLicenses; }
        set { SetDeprecatedConsumedLicenses(value); }
      }
      public Builder SetDeprecatedConsumedLicenses(global::D3.CS.ConsumedLicenses_deprecated value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDeprecatedConsumedLicenses = true;
        result.deprecatedConsumedLicenses_ = value;
        return this;
      }
      public Builder SetDeprecatedConsumedLicenses(global::D3.CS.ConsumedLicenses_deprecated.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasDeprecatedConsumedLicenses = true;
        result.deprecatedConsumedLicenses_ = builderForValue.Build();
        return this;
      }
      public Builder MergeDeprecatedConsumedLicenses(global::D3.CS.ConsumedLicenses_deprecated value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasDeprecatedConsumedLicenses &&
            result.deprecatedConsumedLicenses_ != global::D3.CS.ConsumedLicenses_deprecated.DefaultInstance) {
            result.deprecatedConsumedLicenses_ = global::D3.CS.ConsumedLicenses_deprecated.CreateBuilder(result.deprecatedConsumedLicenses_).MergeFrom(value).BuildPartial();
        } else {
          result.deprecatedConsumedLicenses_ = value;
        }
        result.hasDeprecatedConsumedLicenses = true;
        return this;
      }
      public Builder ClearDeprecatedConsumedLicenses() {
        PrepareBuilder();
        result.hasDeprecatedConsumedLicenses = false;
        result.deprecatedConsumedLicenses_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Achievements.PartitionSnapshot> AchievementSnapshotsList {
        get { return PrepareBuilder().achievementSnapshots_; }
      }
      public int AchievementSnapshotsCount {
        get { return result.AchievementSnapshotsCount; }
      }
      public global::D3.Achievements.PartitionSnapshot GetAchievementSnapshots(int index) {
        return result.GetAchievementSnapshots(index);
      }
      public Builder SetAchievementSnapshots(int index, global::D3.Achievements.PartitionSnapshot value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.achievementSnapshots_[index] = value;
        return this;
      }
      public Builder SetAchievementSnapshots(int index, global::D3.Achievements.PartitionSnapshot.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.achievementSnapshots_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddAchievementSnapshots(global::D3.Achievements.PartitionSnapshot value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.achievementSnapshots_.Add(value);
        return this;
      }
      public Builder AddAchievementSnapshots(global::D3.Achievements.PartitionSnapshot.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.achievementSnapshots_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeAchievementSnapshots(scg::IEnumerable<global::D3.Achievements.PartitionSnapshot> values) {
        PrepareBuilder();
        result.achievementSnapshots_.Add(values);
        return this;
      }
      public Builder ClearAchievementSnapshots() {
        PrepareBuilder();
        result.achievementSnapshots_.Clear();
        return this;
      }
    }
    static Snapshot() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class SnapshotVersion : pb::GeneratedMessage<SnapshotVersion, SnapshotVersion.Builder> {
    private SnapshotVersion() { }
    private static readonly SnapshotVersion defaultInstance = new SnapshotVersion().MakeReadOnly();
    private static readonly string[] _snapshotVersionFieldNames = new string[] { "snapshot", "version" };
    private static readonly uint[] _snapshotVersionFieldTags = new uint[] { 18, 8 };
    public static SnapshotVersion DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SnapshotVersion DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SnapshotVersion ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_SnapshotVersion__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SnapshotVersion, SnapshotVersion.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_SnapshotVersion__FieldAccessorTable; }
    }
    
    public const int VersionFieldNumber = 1;
    private bool hasVersion;
    private ulong version_;
    public bool HasVersion {
      get { return hasVersion; }
    }
    public ulong Version {
      get { return version_; }
    }
    
    public const int SnapshotFieldNumber = 2;
    private bool hasSnapshot;
    private global::D3.CS.Snapshot snapshot_;
    public bool HasSnapshot {
      get { return hasSnapshot; }
    }
    public global::D3.CS.Snapshot Snapshot {
      get { return snapshot_ ?? global::D3.CS.Snapshot.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasVersion) return false;
        if (!hasSnapshot) return false;
        if (!Snapshot.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _snapshotVersionFieldNames;
      if (hasVersion) {
        output.WriteUInt64(1, field_names[1], Version);
      }
      if (hasSnapshot) {
        output.WriteMessage(2, field_names[0], Snapshot);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasVersion) {
          size += pb::CodedOutputStream.ComputeUInt64Size(1, Version);
        }
        if (hasSnapshot) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Snapshot);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static SnapshotVersion ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SnapshotVersion ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SnapshotVersion ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SnapshotVersion ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SnapshotVersion ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SnapshotVersion ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SnapshotVersion ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SnapshotVersion ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SnapshotVersion ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SnapshotVersion ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SnapshotVersion MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SnapshotVersion prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<SnapshotVersion, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SnapshotVersion cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SnapshotVersion result;
      
      private SnapshotVersion PrepareBuilder() {
        if (resultIsReadOnly) {
          SnapshotVersion original = result;
          result = new SnapshotVersion();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SnapshotVersion MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.SnapshotVersion.Descriptor; }
      }
      
      public override SnapshotVersion DefaultInstanceForType {
        get { return global::D3.CS.SnapshotVersion.DefaultInstance; }
      }
      
      public override SnapshotVersion BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SnapshotVersion) {
          return MergeFrom((SnapshotVersion) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SnapshotVersion other) {
        if (other == global::D3.CS.SnapshotVersion.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasVersion) {
          Version = other.Version;
        }
        if (other.HasSnapshot) {
          MergeSnapshot(other.Snapshot);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_snapshotVersionFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _snapshotVersionFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasVersion = input.ReadUInt64(ref result.version_);
              break;
            }
            case 18: {
              global::D3.CS.Snapshot.Builder subBuilder = global::D3.CS.Snapshot.CreateBuilder();
              if (result.hasSnapshot) {
                subBuilder.MergeFrom(Snapshot);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Snapshot = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasVersion {
        get { return result.hasVersion; }
      }
      public ulong Version {
        get { return result.Version; }
        set { SetVersion(value); }
      }
      public Builder SetVersion(ulong value) {
        PrepareBuilder();
        result.hasVersion = true;
        result.version_ = value;
        return this;
      }
      public Builder ClearVersion() {
        PrepareBuilder();
        result.hasVersion = false;
        result.version_ = 0UL;
        return this;
      }
      
      public bool HasSnapshot {
       get { return result.hasSnapshot; }
      }
      public global::D3.CS.Snapshot Snapshot {
        get { return result.Snapshot; }
        set { SetSnapshot(value); }
      }
      public Builder SetSnapshot(global::D3.CS.Snapshot value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSnapshot = true;
        result.snapshot_ = value;
        return this;
      }
      public Builder SetSnapshot(global::D3.CS.Snapshot.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasSnapshot = true;
        result.snapshot_ = builderForValue.Build();
        return this;
      }
      public Builder MergeSnapshot(global::D3.CS.Snapshot value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasSnapshot &&
            result.snapshot_ != global::D3.CS.Snapshot.DefaultInstance) {
            result.snapshot_ = global::D3.CS.Snapshot.CreateBuilder(result.snapshot_).MergeFrom(value).BuildPartial();
        } else {
          result.snapshot_ = value;
        }
        result.hasSnapshot = true;
        return this;
      }
      public Builder ClearSnapshot() {
        PrepareBuilder();
        result.hasSnapshot = false;
        result.snapshot_ = null;
        return this;
      }
    }
    static SnapshotVersion() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class SnapshotVersions : pb::GeneratedMessage<SnapshotVersions, SnapshotVersions.Builder> {
    private SnapshotVersions() { }
    private static readonly SnapshotVersions defaultInstance = new SnapshotVersions().MakeReadOnly();
    private static readonly string[] _snapshotVersionsFieldNames = new string[] { "current_season_num", "current_season_state", "versions" };
    private static readonly uint[] _snapshotVersionsFieldTags = new uint[] { 16, 24, 10 };
    public static SnapshotVersions DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SnapshotVersions DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SnapshotVersions ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_SnapshotVersions__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SnapshotVersions, SnapshotVersions.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_SnapshotVersions__FieldAccessorTable; }
    }
    
    public const int VersionsFieldNumber = 1;
    private pbc::PopsicleList<global::D3.CS.SnapshotVersion> versions_ = new pbc::PopsicleList<global::D3.CS.SnapshotVersion>();
    public scg::IList<global::D3.CS.SnapshotVersion> VersionsList {
      get { return versions_; }
    }
    public int VersionsCount {
      get { return versions_.Count; }
    }
    public global::D3.CS.SnapshotVersion GetVersions(int index) {
      return versions_[index];
    }
    
    public const int CurrentSeasonNumFieldNumber = 2;
    private bool hasCurrentSeasonNum;
    private uint currentSeasonNum_;
    public bool HasCurrentSeasonNum {
      get { return hasCurrentSeasonNum; }
    }
    public uint CurrentSeasonNum {
      get { return currentSeasonNum_; }
    }
    
    public const int CurrentSeasonStateFieldNumber = 3;
    private bool hasCurrentSeasonState;
    private uint currentSeasonState_;
    public bool HasCurrentSeasonState {
      get { return hasCurrentSeasonState; }
    }
    public uint CurrentSeasonState {
      get { return currentSeasonState_; }
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::D3.CS.SnapshotVersion element in VersionsList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _snapshotVersionsFieldNames;
      if (versions_.Count > 0) {
        output.WriteMessageArray(1, field_names[2], versions_);
      }
      if (hasCurrentSeasonNum) {
        output.WriteUInt32(2, field_names[0], CurrentSeasonNum);
      }
      if (hasCurrentSeasonState) {
        output.WriteUInt32(3, field_names[1], CurrentSeasonState);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::D3.CS.SnapshotVersion element in VersionsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        if (hasCurrentSeasonNum) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, CurrentSeasonNum);
        }
        if (hasCurrentSeasonState) {
          size += pb::CodedOutputStream.ComputeUInt32Size(3, CurrentSeasonState);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static SnapshotVersions ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SnapshotVersions ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SnapshotVersions ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SnapshotVersions ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SnapshotVersions ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SnapshotVersions ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SnapshotVersions ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SnapshotVersions ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SnapshotVersions ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SnapshotVersions ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SnapshotVersions MakeReadOnly() {
      versions_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SnapshotVersions prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<SnapshotVersions, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SnapshotVersions cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SnapshotVersions result;
      
      private SnapshotVersions PrepareBuilder() {
        if (resultIsReadOnly) {
          SnapshotVersions original = result;
          result = new SnapshotVersions();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SnapshotVersions MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.SnapshotVersions.Descriptor; }
      }
      
      public override SnapshotVersions DefaultInstanceForType {
        get { return global::D3.CS.SnapshotVersions.DefaultInstance; }
      }
      
      public override SnapshotVersions BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SnapshotVersions) {
          return MergeFrom((SnapshotVersions) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SnapshotVersions other) {
        if (other == global::D3.CS.SnapshotVersions.DefaultInstance) return this;
        PrepareBuilder();
        if (other.versions_.Count != 0) {
          result.versions_.Add(other.versions_);
        }
        if (other.HasCurrentSeasonNum) {
          CurrentSeasonNum = other.CurrentSeasonNum;
        }
        if (other.HasCurrentSeasonState) {
          CurrentSeasonState = other.CurrentSeasonState;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_snapshotVersionsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _snapshotVersionsFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.versions_, global::D3.CS.SnapshotVersion.DefaultInstance, extensionRegistry);
              break;
            }
            case 16: {
              result.hasCurrentSeasonNum = input.ReadUInt32(ref result.currentSeasonNum_);
              break;
            }
            case 24: {
              result.hasCurrentSeasonState = input.ReadUInt32(ref result.currentSeasonState_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::D3.CS.SnapshotVersion> VersionsList {
        get { return PrepareBuilder().versions_; }
      }
      public int VersionsCount {
        get { return result.VersionsCount; }
      }
      public global::D3.CS.SnapshotVersion GetVersions(int index) {
        return result.GetVersions(index);
      }
      public Builder SetVersions(int index, global::D3.CS.SnapshotVersion value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.versions_[index] = value;
        return this;
      }
      public Builder SetVersions(int index, global::D3.CS.SnapshotVersion.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.versions_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddVersions(global::D3.CS.SnapshotVersion value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.versions_.Add(value);
        return this;
      }
      public Builder AddVersions(global::D3.CS.SnapshotVersion.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.versions_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeVersions(scg::IEnumerable<global::D3.CS.SnapshotVersion> values) {
        PrepareBuilder();
        result.versions_.Add(values);
        return this;
      }
      public Builder ClearVersions() {
        PrepareBuilder();
        result.versions_.Clear();
        return this;
      }
      
      public bool HasCurrentSeasonNum {
        get { return result.hasCurrentSeasonNum; }
      }
      public uint CurrentSeasonNum {
        get { return result.CurrentSeasonNum; }
        set { SetCurrentSeasonNum(value); }
      }
      public Builder SetCurrentSeasonNum(uint value) {
        PrepareBuilder();
        result.hasCurrentSeasonNum = true;
        result.currentSeasonNum_ = value;
        return this;
      }
      public Builder ClearCurrentSeasonNum() {
        PrepareBuilder();
        result.hasCurrentSeasonNum = false;
        result.currentSeasonNum_ = 0;
        return this;
      }
      
      public bool HasCurrentSeasonState {
        get { return result.hasCurrentSeasonState; }
      }
      public uint CurrentSeasonState {
        get { return result.CurrentSeasonState; }
        set { SetCurrentSeasonState(value); }
      }
      public Builder SetCurrentSeasonState(uint value) {
        PrepareBuilder();
        result.hasCurrentSeasonState = true;
        result.currentSeasonState_ = value;
        return this;
      }
      public Builder ClearCurrentSeasonState() {
        PrepareBuilder();
        result.hasCurrentSeasonState = false;
        result.currentSeasonState_ = 0;
        return this;
      }
    }
    static SnapshotVersions() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class PartitionedGBID : pb::GeneratedMessage<PartitionedGBID, PartitionedGBID.Builder> {
    private PartitionedGBID() { }
    private static readonly PartitionedGBID defaultInstance = new PartitionedGBID().MakeReadOnly();
    private static readonly string[] _partitionedGBIDFieldNames = new string[] { "gbid", "partition_id" };
    private static readonly uint[] _partitionedGBIDFieldTags = new uint[] { 13, 16 };
    public static PartitionedGBID DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PartitionedGBID DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PartitionedGBID ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_PartitionedGBID__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PartitionedGBID, PartitionedGBID.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_PartitionedGBID__FieldAccessorTable; }
    }
    
    public const int GbidFieldNumber = 1;
    private bool hasGbid;
    private int gbid_;
    public bool HasGbid {
      get { return hasGbid; }
    }
    public int Gbid {
      get { return gbid_; }
    }
    
    public const int PartitionIdFieldNumber = 2;
    private bool hasPartitionId;
    private uint partitionId_;
    public bool HasPartitionId {
      get { return hasPartitionId; }
    }
    public uint PartitionId {
      get { return partitionId_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasGbid) return false;
        if (!hasPartitionId) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _partitionedGBIDFieldNames;
      if (hasGbid) {
        output.WriteSFixed32(1, field_names[0], Gbid);
      }
      if (hasPartitionId) {
        output.WriteUInt32(2, field_names[1], PartitionId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasGbid) {
          size += pb::CodedOutputStream.ComputeSFixed32Size(1, Gbid);
        }
        if (hasPartitionId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, PartitionId);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PartitionedGBID ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PartitionedGBID ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PartitionedGBID ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PartitionedGBID ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PartitionedGBID ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PartitionedGBID ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PartitionedGBID ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PartitionedGBID ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PartitionedGBID ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PartitionedGBID ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PartitionedGBID MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PartitionedGBID prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<PartitionedGBID, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PartitionedGBID cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PartitionedGBID result;
      
      private PartitionedGBID PrepareBuilder() {
        if (resultIsReadOnly) {
          PartitionedGBID original = result;
          result = new PartitionedGBID();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PartitionedGBID MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.PartitionedGBID.Descriptor; }
      }
      
      public override PartitionedGBID DefaultInstanceForType {
        get { return global::D3.CS.PartitionedGBID.DefaultInstance; }
      }
      
      public override PartitionedGBID BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PartitionedGBID) {
          return MergeFrom((PartitionedGBID) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PartitionedGBID other) {
        if (other == global::D3.CS.PartitionedGBID.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasGbid) {
          Gbid = other.Gbid;
        }
        if (other.HasPartitionId) {
          PartitionId = other.PartitionId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_partitionedGBIDFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _partitionedGBIDFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 13: {
              result.hasGbid = input.ReadSFixed32(ref result.gbid_);
              break;
            }
            case 16: {
              result.hasPartitionId = input.ReadUInt32(ref result.partitionId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasGbid {
        get { return result.hasGbid; }
      }
      public int Gbid {
        get { return result.Gbid; }
        set { SetGbid(value); }
      }
      public Builder SetGbid(int value) {
        PrepareBuilder();
        result.hasGbid = true;
        result.gbid_ = value;
        return this;
      }
      public Builder ClearGbid() {
        PrepareBuilder();
        result.hasGbid = false;
        result.gbid_ = 0;
        return this;
      }
      
      public bool HasPartitionId {
        get { return result.hasPartitionId; }
      }
      public uint PartitionId {
        get { return result.PartitionId; }
        set { SetPartitionId(value); }
      }
      public Builder SetPartitionId(uint value) {
        PrepareBuilder();
        result.hasPartitionId = true;
        result.partitionId_ = value;
        return this;
      }
      public Builder ClearPartitionId() {
        PrepareBuilder();
        result.hasPartitionId = false;
        result.partitionId_ = 0;
        return this;
      }
    }
    static PartitionedGBID() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class PartitionedGBIDList : pb::GeneratedMessage<PartitionedGBIDList, PartitionedGBIDList.Builder> {
    private PartitionedGBIDList() { }
    private static readonly PartitionedGBIDList defaultInstance = new PartitionedGBIDList().MakeReadOnly();
    private static readonly string[] _partitionedGBIDListFieldNames = new string[] { "partitioned_gbids" };
    private static readonly uint[] _partitionedGBIDListFieldTags = new uint[] { 10 };
    public static PartitionedGBIDList DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PartitionedGBIDList DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PartitionedGBIDList ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_PartitionedGBIDList__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PartitionedGBIDList, PartitionedGBIDList.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_PartitionedGBIDList__FieldAccessorTable; }
    }
    
    public const int PartitionedGbidsFieldNumber = 1;
    private pbc::PopsicleList<global::D3.CS.PartitionedGBID> partitionedGbids_ = new pbc::PopsicleList<global::D3.CS.PartitionedGBID>();
    public scg::IList<global::D3.CS.PartitionedGBID> PartitionedGbidsList {
      get { return partitionedGbids_; }
    }
    public int PartitionedGbidsCount {
      get { return partitionedGbids_.Count; }
    }
    public global::D3.CS.PartitionedGBID GetPartitionedGbids(int index) {
      return partitionedGbids_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::D3.CS.PartitionedGBID element in PartitionedGbidsList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _partitionedGBIDListFieldNames;
      if (partitionedGbids_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], partitionedGbids_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::D3.CS.PartitionedGBID element in PartitionedGbidsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PartitionedGBIDList ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PartitionedGBIDList ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PartitionedGBIDList ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PartitionedGBIDList ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PartitionedGBIDList ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PartitionedGBIDList ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PartitionedGBIDList ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PartitionedGBIDList ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PartitionedGBIDList ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PartitionedGBIDList ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PartitionedGBIDList MakeReadOnly() {
      partitionedGbids_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PartitionedGBIDList prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<PartitionedGBIDList, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PartitionedGBIDList cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PartitionedGBIDList result;
      
      private PartitionedGBIDList PrepareBuilder() {
        if (resultIsReadOnly) {
          PartitionedGBIDList original = result;
          result = new PartitionedGBIDList();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PartitionedGBIDList MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.PartitionedGBIDList.Descriptor; }
      }
      
      public override PartitionedGBIDList DefaultInstanceForType {
        get { return global::D3.CS.PartitionedGBIDList.DefaultInstance; }
      }
      
      public override PartitionedGBIDList BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PartitionedGBIDList) {
          return MergeFrom((PartitionedGBIDList) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PartitionedGBIDList other) {
        if (other == global::D3.CS.PartitionedGBIDList.DefaultInstance) return this;
        PrepareBuilder();
        if (other.partitionedGbids_.Count != 0) {
          result.partitionedGbids_.Add(other.partitionedGbids_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_partitionedGBIDListFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _partitionedGBIDListFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.partitionedGbids_, global::D3.CS.PartitionedGBID.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::D3.CS.PartitionedGBID> PartitionedGbidsList {
        get { return PrepareBuilder().partitionedGbids_; }
      }
      public int PartitionedGbidsCount {
        get { return result.PartitionedGbidsCount; }
      }
      public global::D3.CS.PartitionedGBID GetPartitionedGbids(int index) {
        return result.GetPartitionedGbids(index);
      }
      public Builder SetPartitionedGbids(int index, global::D3.CS.PartitionedGBID value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.partitionedGbids_[index] = value;
        return this;
      }
      public Builder SetPartitionedGbids(int index, global::D3.CS.PartitionedGBID.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.partitionedGbids_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddPartitionedGbids(global::D3.CS.PartitionedGBID value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.partitionedGbids_.Add(value);
        return this;
      }
      public Builder AddPartitionedGbids(global::D3.CS.PartitionedGBID.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.partitionedGbids_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangePartitionedGbids(scg::IEnumerable<global::D3.CS.PartitionedGBID> values) {
        PrepareBuilder();
        result.partitionedGbids_.Add(values);
        return this;
      }
      public Builder ClearPartitionedGbids() {
        PrepareBuilder();
        result.partitionedGbids_.Clear();
        return this;
      }
    }
    static PartitionedGBIDList() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class PartitionedGBIDCapQuantity : pb::GeneratedMessage<PartitionedGBIDCapQuantity, PartitionedGBIDCapQuantity.Builder> {
    private PartitionedGBIDCapQuantity() { }
    private static readonly PartitionedGBIDCapQuantity defaultInstance = new PartitionedGBIDCapQuantity().MakeReadOnly();
    private static readonly string[] _partitionedGBIDCapQuantityFieldNames = new string[] { "cap_quantity", "gbid", "partition_id" };
    private static readonly uint[] _partitionedGBIDCapQuantityFieldTags = new uint[] { 24, 13, 16 };
    public static PartitionedGBIDCapQuantity DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PartitionedGBIDCapQuantity DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PartitionedGBIDCapQuantity ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_PartitionedGBIDCapQuantity__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PartitionedGBIDCapQuantity, PartitionedGBIDCapQuantity.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_PartitionedGBIDCapQuantity__FieldAccessorTable; }
    }
    
    public const int GbidFieldNumber = 1;
    private bool hasGbid;
    private int gbid_;
    public bool HasGbid {
      get { return hasGbid; }
    }
    public int Gbid {
      get { return gbid_; }
    }
    
    public const int PartitionIdFieldNumber = 2;
    private bool hasPartitionId;
    private uint partitionId_;
    public bool HasPartitionId {
      get { return hasPartitionId; }
    }
    public uint PartitionId {
      get { return partitionId_; }
    }
    
    public const int CapQuantityFieldNumber = 3;
    private bool hasCapQuantity;
    private ulong capQuantity_;
    public bool HasCapQuantity {
      get { return hasCapQuantity; }
    }
    public ulong CapQuantity {
      get { return capQuantity_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasGbid) return false;
        if (!hasPartitionId) return false;
        if (!hasCapQuantity) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _partitionedGBIDCapQuantityFieldNames;
      if (hasGbid) {
        output.WriteSFixed32(1, field_names[1], Gbid);
      }
      if (hasPartitionId) {
        output.WriteUInt32(2, field_names[2], PartitionId);
      }
      if (hasCapQuantity) {
        output.WriteUInt64(3, field_names[0], CapQuantity);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasGbid) {
          size += pb::CodedOutputStream.ComputeSFixed32Size(1, Gbid);
        }
        if (hasPartitionId) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, PartitionId);
        }
        if (hasCapQuantity) {
          size += pb::CodedOutputStream.ComputeUInt64Size(3, CapQuantity);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PartitionedGBIDCapQuantity ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PartitionedGBIDCapQuantity ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PartitionedGBIDCapQuantity ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PartitionedGBIDCapQuantity ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PartitionedGBIDCapQuantity ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PartitionedGBIDCapQuantity ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PartitionedGBIDCapQuantity ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PartitionedGBIDCapQuantity ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PartitionedGBIDCapQuantity ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PartitionedGBIDCapQuantity ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PartitionedGBIDCapQuantity MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PartitionedGBIDCapQuantity prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<PartitionedGBIDCapQuantity, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PartitionedGBIDCapQuantity cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PartitionedGBIDCapQuantity result;
      
      private PartitionedGBIDCapQuantity PrepareBuilder() {
        if (resultIsReadOnly) {
          PartitionedGBIDCapQuantity original = result;
          result = new PartitionedGBIDCapQuantity();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PartitionedGBIDCapQuantity MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.PartitionedGBIDCapQuantity.Descriptor; }
      }
      
      public override PartitionedGBIDCapQuantity DefaultInstanceForType {
        get { return global::D3.CS.PartitionedGBIDCapQuantity.DefaultInstance; }
      }
      
      public override PartitionedGBIDCapQuantity BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PartitionedGBIDCapQuantity) {
          return MergeFrom((PartitionedGBIDCapQuantity) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PartitionedGBIDCapQuantity other) {
        if (other == global::D3.CS.PartitionedGBIDCapQuantity.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasGbid) {
          Gbid = other.Gbid;
        }
        if (other.HasPartitionId) {
          PartitionId = other.PartitionId;
        }
        if (other.HasCapQuantity) {
          CapQuantity = other.CapQuantity;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_partitionedGBIDCapQuantityFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _partitionedGBIDCapQuantityFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 13: {
              result.hasGbid = input.ReadSFixed32(ref result.gbid_);
              break;
            }
            case 16: {
              result.hasPartitionId = input.ReadUInt32(ref result.partitionId_);
              break;
            }
            case 24: {
              result.hasCapQuantity = input.ReadUInt64(ref result.capQuantity_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasGbid {
        get { return result.hasGbid; }
      }
      public int Gbid {
        get { return result.Gbid; }
        set { SetGbid(value); }
      }
      public Builder SetGbid(int value) {
        PrepareBuilder();
        result.hasGbid = true;
        result.gbid_ = value;
        return this;
      }
      public Builder ClearGbid() {
        PrepareBuilder();
        result.hasGbid = false;
        result.gbid_ = 0;
        return this;
      }
      
      public bool HasPartitionId {
        get { return result.hasPartitionId; }
      }
      public uint PartitionId {
        get { return result.PartitionId; }
        set { SetPartitionId(value); }
      }
      public Builder SetPartitionId(uint value) {
        PrepareBuilder();
        result.hasPartitionId = true;
        result.partitionId_ = value;
        return this;
      }
      public Builder ClearPartitionId() {
        PrepareBuilder();
        result.hasPartitionId = false;
        result.partitionId_ = 0;
        return this;
      }
      
      public bool HasCapQuantity {
        get { return result.hasCapQuantity; }
      }
      public ulong CapQuantity {
        get { return result.CapQuantity; }
        set { SetCapQuantity(value); }
      }
      public Builder SetCapQuantity(ulong value) {
        PrepareBuilder();
        result.hasCapQuantity = true;
        result.capQuantity_ = value;
        return this;
      }
      public Builder ClearCapQuantity() {
        PrepareBuilder();
        result.hasCapQuantity = false;
        result.capQuantity_ = 0UL;
        return this;
      }
    }
    static PartitionedGBIDCapQuantity() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class PartitionedGBIDCapQuantityList : pb::GeneratedMessage<PartitionedGBIDCapQuantityList, PartitionedGBIDCapQuantityList.Builder> {
    private PartitionedGBIDCapQuantityList() { }
    private static readonly PartitionedGBIDCapQuantityList defaultInstance = new PartitionedGBIDCapQuantityList().MakeReadOnly();
    private static readonly string[] _partitionedGBIDCapQuantityListFieldNames = new string[] { "partitioned_gbids" };
    private static readonly uint[] _partitionedGBIDCapQuantityListFieldTags = new uint[] { 10 };
    public static PartitionedGBIDCapQuantityList DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PartitionedGBIDCapQuantityList DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PartitionedGBIDCapQuantityList ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_PartitionedGBIDCapQuantityList__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PartitionedGBIDCapQuantityList, PartitionedGBIDCapQuantityList.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_PartitionedGBIDCapQuantityList__FieldAccessorTable; }
    }
    
    public const int PartitionedGbidsFieldNumber = 1;
    private pbc::PopsicleList<global::D3.CS.PartitionedGBIDCapQuantity> partitionedGbids_ = new pbc::PopsicleList<global::D3.CS.PartitionedGBIDCapQuantity>();
    public scg::IList<global::D3.CS.PartitionedGBIDCapQuantity> PartitionedGbidsList {
      get { return partitionedGbids_; }
    }
    public int PartitionedGbidsCount {
      get { return partitionedGbids_.Count; }
    }
    public global::D3.CS.PartitionedGBIDCapQuantity GetPartitionedGbids(int index) {
      return partitionedGbids_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::D3.CS.PartitionedGBIDCapQuantity element in PartitionedGbidsList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _partitionedGBIDCapQuantityListFieldNames;
      if (partitionedGbids_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], partitionedGbids_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::D3.CS.PartitionedGBIDCapQuantity element in PartitionedGbidsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PartitionedGBIDCapQuantityList ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PartitionedGBIDCapQuantityList ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PartitionedGBIDCapQuantityList ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PartitionedGBIDCapQuantityList ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PartitionedGBIDCapQuantityList ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PartitionedGBIDCapQuantityList ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PartitionedGBIDCapQuantityList ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PartitionedGBIDCapQuantityList ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PartitionedGBIDCapQuantityList ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PartitionedGBIDCapQuantityList ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PartitionedGBIDCapQuantityList MakeReadOnly() {
      partitionedGbids_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PartitionedGBIDCapQuantityList prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<PartitionedGBIDCapQuantityList, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PartitionedGBIDCapQuantityList cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PartitionedGBIDCapQuantityList result;
      
      private PartitionedGBIDCapQuantityList PrepareBuilder() {
        if (resultIsReadOnly) {
          PartitionedGBIDCapQuantityList original = result;
          result = new PartitionedGBIDCapQuantityList();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PartitionedGBIDCapQuantityList MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.PartitionedGBIDCapQuantityList.Descriptor; }
      }
      
      public override PartitionedGBIDCapQuantityList DefaultInstanceForType {
        get { return global::D3.CS.PartitionedGBIDCapQuantityList.DefaultInstance; }
      }
      
      public override PartitionedGBIDCapQuantityList BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PartitionedGBIDCapQuantityList) {
          return MergeFrom((PartitionedGBIDCapQuantityList) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PartitionedGBIDCapQuantityList other) {
        if (other == global::D3.CS.PartitionedGBIDCapQuantityList.DefaultInstance) return this;
        PrepareBuilder();
        if (other.partitionedGbids_.Count != 0) {
          result.partitionedGbids_.Add(other.partitionedGbids_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_partitionedGBIDCapQuantityListFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _partitionedGBIDCapQuantityListFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.partitionedGbids_, global::D3.CS.PartitionedGBIDCapQuantity.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::D3.CS.PartitionedGBIDCapQuantity> PartitionedGbidsList {
        get { return PrepareBuilder().partitionedGbids_; }
      }
      public int PartitionedGbidsCount {
        get { return result.PartitionedGbidsCount; }
      }
      public global::D3.CS.PartitionedGBIDCapQuantity GetPartitionedGbids(int index) {
        return result.GetPartitionedGbids(index);
      }
      public Builder SetPartitionedGbids(int index, global::D3.CS.PartitionedGBIDCapQuantity value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.partitionedGbids_[index] = value;
        return this;
      }
      public Builder SetPartitionedGbids(int index, global::D3.CS.PartitionedGBIDCapQuantity.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.partitionedGbids_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddPartitionedGbids(global::D3.CS.PartitionedGBIDCapQuantity value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.partitionedGbids_.Add(value);
        return this;
      }
      public Builder AddPartitionedGbids(global::D3.CS.PartitionedGBIDCapQuantity.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.partitionedGbids_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangePartitionedGbids(scg::IEnumerable<global::D3.CS.PartitionedGBIDCapQuantity> values) {
        PrepareBuilder();
        result.partitionedGbids_.Add(values);
        return this;
      }
      public Builder ClearPartitionedGbids() {
        PrepareBuilder();
        result.partitionedGbids_.Clear();
        return this;
      }
    }
    static PartitionedGBIDCapQuantityList() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class AccountData : pb::GeneratedMessage<AccountData, AccountData.Builder> {
    private AccountData() { }
    private static readonly AccountData defaultInstance = new AccountData().MakeReadOnly();
    private static readonly string[] _accountDataFieldNames = new string[] { "account_wide_currency_data", "digest", "partitions" };
    private static readonly uint[] _accountDataFieldTags = new uint[] { 26, 10, 18 };
    public static AccountData DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AccountData DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AccountData ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.CS.CS.internal__static_D3_CS_AccountData__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<AccountData, AccountData.Builder> InternalFieldAccessors {
      get { return global::D3.CS.CS.internal__static_D3_CS_AccountData__FieldAccessorTable; }
    }
    
    public const int DigestFieldNumber = 1;
    private bool hasDigest;
    private global::D3.Account.Digest digest_;
    public bool HasDigest {
      get { return hasDigest; }
    }
    public global::D3.Account.Digest Digest {
      get { return digest_ ?? global::D3.Account.Digest.DefaultInstance; }
    }
    
    public const int PartitionsFieldNumber = 2;
    private pbc::PopsicleList<global::D3.Account.AccountPartition> partitions_ = new pbc::PopsicleList<global::D3.Account.AccountPartition>();
    public scg::IList<global::D3.Account.AccountPartition> PartitionsList {
      get { return partitions_; }
    }
    public int PartitionsCount {
      get { return partitions_.Count; }
    }
    public global::D3.Account.AccountPartition GetPartitions(int index) {
      return partitions_[index];
    }
    
    public const int AccountWideCurrencyDataFieldNumber = 3;
    private bool hasAccountWideCurrencyData;
    private global::D3.Items.CurrencySavedData accountWideCurrencyData_;
    public bool HasAccountWideCurrencyData {
      get { return hasAccountWideCurrencyData; }
    }
    public global::D3.Items.CurrencySavedData AccountWideCurrencyData {
      get { return accountWideCurrencyData_ ?? global::D3.Items.CurrencySavedData.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasDigest) return false;
        if (!Digest.IsInitialized) return false;
        foreach (global::D3.Account.AccountPartition element in PartitionsList) {
          if (!element.IsInitialized) return false;
        }
        if (HasAccountWideCurrencyData) {
          if (!AccountWideCurrencyData.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _accountDataFieldNames;
      if (hasDigest) {
        output.WriteMessage(1, field_names[1], Digest);
      }
      if (partitions_.Count > 0) {
        output.WriteMessageArray(2, field_names[2], partitions_);
      }
      if (hasAccountWideCurrencyData) {
        output.WriteMessage(3, field_names[0], AccountWideCurrencyData);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasDigest) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Digest);
        }
        foreach (global::D3.Account.AccountPartition element in PartitionsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, element);
        }
        if (hasAccountWideCurrencyData) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, AccountWideCurrencyData);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static AccountData ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AccountData ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AccountData ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AccountData ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AccountData ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AccountData ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AccountData ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AccountData ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AccountData ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AccountData ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AccountData MakeReadOnly() {
      partitions_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AccountData prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<AccountData, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AccountData cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AccountData result;
      
      private AccountData PrepareBuilder() {
        if (resultIsReadOnly) {
          AccountData original = result;
          result = new AccountData();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AccountData MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.CS.AccountData.Descriptor; }
      }
      
      public override AccountData DefaultInstanceForType {
        get { return global::D3.CS.AccountData.DefaultInstance; }
      }
      
      public override AccountData BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is AccountData) {
          return MergeFrom((AccountData) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AccountData other) {
        if (other == global::D3.CS.AccountData.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasDigest) {
          MergeDigest(other.Digest);
        }
        if (other.partitions_.Count != 0) {
          result.partitions_.Add(other.partitions_);
        }
        if (other.HasAccountWideCurrencyData) {
          MergeAccountWideCurrencyData(other.AccountWideCurrencyData);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_accountDataFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _accountDataFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.Account.Digest.Builder subBuilder = global::D3.Account.Digest.CreateBuilder();
              if (result.hasDigest) {
                subBuilder.MergeFrom(Digest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Digest = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.partitions_, global::D3.Account.AccountPartition.DefaultInstance, extensionRegistry);
              break;
            }
            case 26: {
              global::D3.Items.CurrencySavedData.Builder subBuilder = global::D3.Items.CurrencySavedData.CreateBuilder();
              if (result.hasAccountWideCurrencyData) {
                subBuilder.MergeFrom(AccountWideCurrencyData);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              AccountWideCurrencyData = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasDigest {
       get { return result.hasDigest; }
      }
      public global::D3.Account.Digest Digest {
        get { return result.Digest; }
        set { SetDigest(value); }
      }
      public Builder SetDigest(global::D3.Account.Digest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDigest = true;
        result.digest_ = value;
        return this;
      }
      public Builder SetDigest(global::D3.Account.Digest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasDigest = true;
        result.digest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeDigest(global::D3.Account.Digest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasDigest &&
            result.digest_ != global::D3.Account.Digest.DefaultInstance) {
            result.digest_ = global::D3.Account.Digest.CreateBuilder(result.digest_).MergeFrom(value).BuildPartial();
        } else {
          result.digest_ = value;
        }
        result.hasDigest = true;
        return this;
      }
      public Builder ClearDigest() {
        PrepareBuilder();
        result.hasDigest = false;
        result.digest_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Account.AccountPartition> PartitionsList {
        get { return PrepareBuilder().partitions_; }
      }
      public int PartitionsCount {
        get { return result.PartitionsCount; }
      }
      public global::D3.Account.AccountPartition GetPartitions(int index) {
        return result.GetPartitions(index);
      }
      public Builder SetPartitions(int index, global::D3.Account.AccountPartition value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.partitions_[index] = value;
        return this;
      }
      public Builder SetPartitions(int index, global::D3.Account.AccountPartition.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.partitions_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddPartitions(global::D3.Account.AccountPartition value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.partitions_.Add(value);
        return this;
      }
      public Builder AddPartitions(global::D3.Account.AccountPartition.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.partitions_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangePartitions(scg::IEnumerable<global::D3.Account.AccountPartition> values) {
        PrepareBuilder();
        result.partitions_.Add(values);
        return this;
      }
      public Builder ClearPartitions() {
        PrepareBuilder();
        result.partitions_.Clear();
        return this;
      }
      
      public bool HasAccountWideCurrencyData {
       get { return result.hasAccountWideCurrencyData; }
      }
      public global::D3.Items.CurrencySavedData AccountWideCurrencyData {
        get { return result.AccountWideCurrencyData; }
        set { SetAccountWideCurrencyData(value); }
      }
      public Builder SetAccountWideCurrencyData(global::D3.Items.CurrencySavedData value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAccountWideCurrencyData = true;
        result.accountWideCurrencyData_ = value;
        return this;
      }
      public Builder SetAccountWideCurrencyData(global::D3.Items.CurrencySavedData.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasAccountWideCurrencyData = true;
        result.accountWideCurrencyData_ = builderForValue.Build();
        return this;
      }
      public Builder MergeAccountWideCurrencyData(global::D3.Items.CurrencySavedData value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasAccountWideCurrencyData &&
            result.accountWideCurrencyData_ != global::D3.Items.CurrencySavedData.DefaultInstance) {
            result.accountWideCurrencyData_ = global::D3.Items.CurrencySavedData.CreateBuilder(result.accountWideCurrencyData_).MergeFrom(value).BuildPartial();
        } else {
          result.accountWideCurrencyData_ = value;
        }
        result.hasAccountWideCurrencyData = true;
        return this;
      }
      public Builder ClearAccountWideCurrencyData() {
        PrepareBuilder();
        result.hasAccountWideCurrencyData = false;
        result.accountWideCurrencyData_ = null;
        return this;
      }
    }
    static AccountData() {
      object.ReferenceEquals(global::D3.CS.CS.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
